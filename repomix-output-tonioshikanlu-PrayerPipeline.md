This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where security check has been disabled.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information

## Additional Info

# Directory Structure
```
attached_assets/
  Pasted--todo-md-A-comprehensive-task-by-task-checklist-for-building-the-Prayer-Pipeline-App-covering-bot-1743038928019.txt
client/
  public/
    badge-72.svg
    icon-192.svg
    service-worker.js
  src/
    components/
      ui/
        accordion.tsx
        alert-dialog.tsx
        alert.tsx
        aspect-ratio.tsx
        avatar.tsx
        badge.tsx
        breadcrumb.tsx
        button.tsx
        calendar.tsx
        card.tsx
        carousel.tsx
        chart.tsx
        checkbox.tsx
        collapsible.tsx
        command.tsx
        context-menu.tsx
        dialog.tsx
        drawer.tsx
        dropdown-menu.tsx
        form.tsx
        hover-card.tsx
        input-otp.tsx
        input.tsx
        label.tsx
        menubar.tsx
        navigation-menu.tsx
        pagination.tsx
        popover.tsx
        progress.tsx
        radio-group.tsx
        resizable.tsx
        scroll-area.tsx
        select.tsx
        separator.tsx
        sheet.tsx
        sidebar.tsx
        skeleton.tsx
        slider.tsx
        switch.tsx
        table.tsx
        tabs.tsx
        textarea.tsx
        toast.tsx
        toaster.tsx
        toggle-group.tsx
        toggle.tsx
        tooltip.tsx
      category-groups.tsx
      comment-card.tsx
      create-group-modal.tsx
      create-meeting-modal.tsx
      create-request-modal.tsx
      favorite-groups-section.tsx
      group-card.tsx
      groups-list.tsx
      header.tsx
      meeting-card.tsx
      meetings-tab.tsx
      mobile-nav.tsx
      notifications-dropdown.tsx
      organization-selector.tsx
      prayer-card.tsx
      prayer-reminder-dialog.tsx
      prayer-reminders-card.tsx
      update-status-modal.tsx
    hooks/
      use-auth.tsx
      use-favorite-groups.tsx
      use-group-notification-preferences.tsx
      use-meeting-notes.tsx
      use-meetings.tsx
      use-mobile.tsx
      use-notification-preferences.tsx
      use-organizations.tsx
      use-prayer-reminders.tsx
      use-push-notifications.tsx
      use-query-params.ts
      use-toast.ts
    lib/
      organization-protected-route.tsx
      protected-route.tsx
      push-notifications.ts
      queryClient.ts
      utils.ts
    pages/
      auth-page.tsx
      explore-groups-page.tsx
      forgot-password-page.tsx
      group-details.tsx
      home-page.tsx
      meeting-details.tsx
      not-found.tsx
      organization-details-page.tsx
      organization-onboarding.tsx
      organizations-page.tsx
      prayer-requests-page.tsx
      profile-page.tsx
      request-details.tsx
      reset-password-page.tsx
      settings-page.tsx
    App.tsx
    index.css
    main.tsx
  index.html
mobile/
  src/
    api/
      queryClient.ts
    context/
      AuthContext.tsx
      NotificationContext.tsx
    hooks/
      useAuth.ts
      useNotifications.ts
    navigation/
      AppNavigator.tsx
      MainNavigator.tsx
    screens/
      AuthScreen.tsx
      ChangePasswordScreen.tsx
      CreateGroupScreen.tsx
      CreateRequestScreen.tsx
      EditProfileScreen.tsx
      EditRequestScreen.tsx
      ExploreGroupsScreen.tsx
      ForgotPasswordScreen.tsx
      GroupDetailsScreen.tsx
      HomeScreen.tsx
      MeetingDetailsScreen.tsx
      OrganizationDetailsScreen.tsx
      OrganizationOnboardingScreen.tsx
      OrganizationsScreen.tsx
      PrayerRequestsScreen.tsx
      RequestDetailsScreen.tsx
      ResetPasswordScreen.tsx
      SettingsScreen.tsx
    services/
      notificationService.ts
  App.tsx
  babel.config.js
  package.json
  tsconfig.json
server/
  auth.ts
  db.ts
  index.ts
  migrations.ts
  push-notifications.ts
  routes.ts
  storage.ts
  vite.ts
shared/
  schema.ts
.gitignore
.replit
db-migrate.js
drizzle.config.ts
package.json
postcss.config.js
replit.nix
tailwind.config.ts
theme.json
tsconfig.json
update-schema.cjs
vite.config.ts
```

# Files

## File: attached_assets/Pasted--todo-md-A-comprehensive-task-by-task-checklist-for-building-the-Prayer-Pipeline-App-covering-bot-1743038928019.txt
```
# todo.md

A comprehensive task-by-task checklist for building the Prayer Pipeline App, covering both backend and frontend steps.  
Check off each item as you complete it to stay organized and on track.

---

## 1. Project Setup & Scaffolding

- [ ] **Create Git repository**  
  - [ ] Make a local folder named `prayer-pipeline`  
  - [ ] Initialize a Git repo (`git init`)  
  - [ ] Create an empty `README.md` with a project name and short summary  
  - [ ] Make the initial commit

- [ ] **Set up backend framework**  
  - [ ] Choose backend framework (e.g., Node.js + Express)  
  - [ ] Initialize project (e.g., `npm init` or equivalent)  
  - [ ] Install core dependencies (Express, etc.)  
  - [ ] Create a basic `index.js` (or `app.js`) with a "Hello World" route  
  - [ ] Test to confirm the server runs on localhost

- [ ] **Database configuration**  
  - [ ] Choose database (e.g., PostgreSQL)  
  - [ ] Install DB drivers/ORM library (e.g., `pg`, Sequelize)  
  - [ ] Create a `.env` file with DB credentials (dev/test)  
  - [ ] Update DB config in `index.js` or appropriate config files  
  - [ ] Confirm DB connection by running a simple test query (if desired)

- [ ] **(Optional) Docker environment**  
  - [ ] Create a `Dockerfile` for the backend  
  - [ ] Create a `docker-compose.yml` to manage backend + DB containers  
  - [ ] Ensure `docker-compose up` works without errors

- [ ] **Directory structure**  
  - [ ] Create folders: `routes/`, `controllers/`, `models/`, `tests/`  
  - [ ] Place your initial code files in each folder (even if just placeholders)

---

## 2. Database Schema & Migrations

- [ ] **Install and configure ORM**  
  - [ ] Install Sequelize (or ORM of choice)  
  - [ ] Configure ORM with DB credentials in a config file

- [ ] **Create basic models and migrations**  
  - [ ] `User` model + migration  
  - [ ] `Group` model + migration  
  - [ ] `PrayerRequest` model + migration  
  - [ ] `Comment` model + migration  
  - [ ] `Notification` model + migration

- [ ] **Run migrations**  
  - [ ] Use migration commands (e.g., `sequelize db:migrate`)  
  - [ ] Confirm tables are created successfully

- [ ] **(Optional) Model validation**  
  - [ ] Add field validations (e.g., email format, required fields)

---

## 3. User Model & Authentication

- [ ] **User registration endpoint**  
  - [ ] `POST /auth/register` with fields: email, password, role (optional)  
  - [ ] Hash passwords using bcrypt (or similar) before storing  
  - [ ] Validate email/unique constraints

- [ ] **User login endpoint**  
  - [ ] `POST /auth/login`  
  - [ ] Compare hashed password with user input  
  - [ ] Generate JWT if credentials are valid  
  - [ ] Return token in response

- [ ] **JWT secret key**  
  - [ ] Add a `JWT_SECRET` in `.env`  
  - [ ] Use environment variable in the authentication logic

- [ ] **Error handling**  
  - [ ] Handle duplicate email on registration  
  - [ ] Handle incorrect credentials on login  
  - [ ] Return helpful error messages

- [ ] **Basic testing**  
  - [ ] Unit test for registration  
  - [ ] Unit test for login  
  - [ ] Check token validity

---

## 4. Roles & Permissions

- [ ] **Extend `User` model**  
  - [ ] Role attribute: "regular", "leader", "admin"

- [ ] **Middleware for role checks**  
  - [ ] Create a role-checking middleware (e.g., `requireRole('admin')`)  
  - [ ] Restrict access to certain routes based on role

- [ ] **Test role-based access**  
  - [ ] Verify admin-only routes  
  - [ ] Verify leader or admin routes  
  - [ ] Verify regular user routes

---

## 5. Group Management

- [ ] **Group CRUD endpoints**  
  - [ ] `POST /groups` (leader or admin)  
  - [ ] `GET /groups` (all users)  
  - [ ] `GET /groups/:id` (all users)  
  - [ ] `PUT /groups/:id` (leader or admin)  
  - [ ] `DELETE /groups/:id` (admin only)

- [ ] **Add/remove members**  
  - [ ] `POST /groups/:id/members` (leader or admin)  
  - [ ] `DELETE /groups/:id/members/:userId` (leader or admin)

- [ ] **Privacy settings**  
  - [ ] Integrate into `Group` model (open, invite-only, request-to-join)

- [ ] **Leadership rotation**  
  - [ ] Basic logic for rotating leadership every 30 days (if applicable)

- [ ] **Group tests**  
  - [ ] Create groups  
  - [ ] Add members  
  - [ ] Ensure role-based restrictions  
  - [ ] Update/delete groups

---

## 6. Prayer Requests & Comments

- [ ] **`PrayerRequest` model**  
  - [ ] Fields: id, userId, groupId, title, description, urgency, followUpDate, isAnonymous, status, timestamps

- [ ] **Prayer request endpoints**  
  - [ ] `POST /groups/:groupId/requests`  
  - [ ] `GET /groups/:groupId/requests`  
  - [ ] `GET /groups/:groupId/requests/:requestId`  
  - [ ] `PUT /groups/:groupId/requests/:requestId`  
  - [ ] `DELETE /groups/:groupId/requests/:requestId`

- [ ] **Comment model**  
  - [ ] Fields: id, prayerRequestId, userId, text, isPrivate, timestamps

- [ ] **Comment endpoints**  
  - [ ] `POST /requests/:requestId/comments`  
  - [ ] `GET /requests/:requestId/comments`  
  - [ ] `PUT /requests/:requestId/comments/:commentId`  
  - [ ] `DELETE /requests/:requestId/comments/:commentId`

- [ ] **Permissions & anonymity**  
  - [ ] Ensure users can only edit/delete their own requests/comments  
  - [ ] Anonymity toggle (user is hidden unless turned off)  
  - [ ] Status updates (Still Waiting, Answered, God Said No)

- [ ] **Testing**  
  - [ ] Unit tests for request creation, editing  
  - [ ] Unit tests for comment creation, editing  
  - [ ] Integration tests (linking request to group, etc.)

---

## 7. Notifications & Activity Feed

- [ ] **Notification model**  
  - [ ] Fields: id, userId, message, read, type, referenceId, timestamps

- [ ] **Notification creation**  
  - [ ] Auto-generate a notification when a new prayer request is added  
  - [ ] Auto-generate a notification when a comment is posted (for the request owner)  
  - [ ] (Optional) Additional notifications for leadership changes or other events

- [ ] **Notification endpoints**  
  - [ ] `GET /notifications` (fetch user's notifications)  
  - [ ] `PATCH /notifications/:id` (mark notification as read)  
  - [ ] `PATCH /notifications/mark-all-read` (mark all as read)  
  - [ ] `DELETE /notifications/:id` (remove notification)

- [ ] **Push notification integration** (e.g., Firebase/OneSignal)  
  - [ ] Set up push notification tokens if you want mobile push notifications  
  - [ ] Confirm that a push is triggered on event (e.g., new request)

- [ ] **Testing**  
  - [ ] Validate notifications are created in the DB as expected  
  - [ ] Confirm correct notifications for group members vs. request owners

---

## 8. Admin & Moderation

- [ ] **Admin dashboard**  
  - [ ] `GET /admin/dashboard` for summary stats (user count, group count, prayer requests, etc.)

- [ ] **Moderation**  
  - [ ] `DELETE /admin/requests/:requestId` to remove flagged/inappropriate requests  
  - [ ] `DELETE /admin/comments/:commentId` to remove flagged/inappropriate comments

- [ ] **User management**  
  - [ ] `GET /admin/users` to list all users  
  - [ ] `PATCH /admin/users/:userId/role` to update user roles

- [ ] **Security checks**  
  - [ ] Restrict admin routes to "admin" role only  
  - [ ] Proper error handling if non-admin attempts to access admin routes

- [ ] **Testing**  
  - [ ] Confirm only admin can call these routes  
  - [ ] Confirm relevant items (requests/users) can be removed

---

## 9. Frontend Implementation (Mobile)

- [ ] **Initialize mobile app**  
  - [ ] Choose a framework (React Native, Flutter, etc.)  
  - [ ] Create basic project structure (using CLI tools)

- [ ] **UI scaffolding**  
  - [ ] Login screen  
  - [ ] Registration screen (if needed)  
  - [ ] Home / dashboard screen  
  - [ ] Group listing screen  
  - [ ] Group detail screen (show prayer requests)  
  - [ ] Request detail screen (show comments)

- [ ] **State management**  
  - [ ] Integrate Redux/Provider/BLoC (framework dependent)  
  - [ ] Set up basic actions and reducers (e.g., auth, groups, requests)

- [ ] **API integration**  
  - [ ] Use Axios (or fetch) for network calls  
  - [ ] Implement login call to `/auth/login`  
  - [ ] Save JWT in Redux or secure storage  
  - [ ] Use JWT in headers for subsequent requests (groups, requests, etc.)

- [ ] **Error handling / UI feedback**  
  - [ ] Display errors for invalid credentials, network failures  
  - [ ] Show loading states (spinners, progress indicators)

---

## 10. Testing & Deployment

- [ ] **Unit tests**  
  - [ ] Comprehensive test coverage in the backend (routes, controllers, models)  
  - [ ] Frontend component tests (if desired, e.g., Jest for React Native)

- [ ] **Integration tests**  
  - [ ] Confirm full flows (create group -> add user -> user adds request -> comment -> notification triggers)  
  - [ ] Check multi-role interactions (admin vs. leader vs. user)

- [ ] **CI/CD pipeline**  
  - [ ] Set up GitHub Actions, GitLab CI, or Jenkins  
  - [ ] Automate tests on pull requests or merges  
  - [ ] Automated deployment to staging/production (if applicable)

- [ ] **Deployment**  
  - [ ] Deploy backend to a server (Heroku, AWS, Azure, etc.)  
  - [ ] Deploy mobile apps (release or test build to iOS/Android)  
  - [ ] Confirm environment variable settings in production

- [ ] **Monitoring**  
  - [ ] Integrate logging service (Sentry, Datadog, etc.)  
  - [ ] Track errors and performance issues in production  
  - [ ] Set up analytics for mobile usage

---

## 11. Mobile Screens & Flows

Below is a detailed step-by-step checklist for **all the major mobile flows and screens** in the Prayer Pipeline App. Check off each step as you go to ensure thorough coverage.

### 11.1. Onboarding & Authentication

- [ ] **Splash / Onboarding Screens (Optional)**  
  - [ ] Decide whether you have an onboarding flow (introduction slides, usage tips)  
  - [ ] Create UI layout for splash screen or onboarding carousel  
  - [ ] Implement navigation from onboarding to the login screen

- [ ] **Registration Flow**  
  - [ ] Screen design: Registration form (email, password, confirm password)  
  - [ ] Form validation: Check email format, password length, matching passwords  
  - [ ] API integration: `POST /auth/register` with form data  
  - [ ] Success handling: Automatically log in user or navigate them to Login screen  
  - [ ] Error handling: Display user-friendly messages for server errors  
  - [ ] UI/UX checks: Provide loading indicators

- [ ] **Login Flow**  
  - [ ] Screen design: Login form (email, password)  
  - [ ] API integration: `POST /auth/login`  
  - [ ] JWT handling: Save token in secure storage or Redux store  
  - [ ] Error handling: Show invalid credentials or server errors  
  - [ ] (Optional) “Remember Me / Stay Signed In” toggle  
  - [ ] Navigation: Redirect to Home or Dashboard screen upon success

- [ ] **Password Reset / Forgot Password (Optional)**  
  - [ ] Forgot Password screen (email input, instructions)  
  - [ ] API integration: `POST /auth/forgot-password` (if supported)  
  - [ ] Display success message (“Password reset link sent”)  
  - [ ] Loading spinners, error messages

---

### 11.2. Home / Dashboard

- [ ] **Home Screen Design**  
  - [ ] Welcome banner (user’s name or greeting)  
  - [ ] Navigation elements (tabs or buttons: Groups, Notifications, Profile)  
  - [ ] Recent activity (optional list of recent requests or announcements)

- [ ] **State Management (Redux, etc.)**  
  - [ ] Fetch initial data (user info, group summary, etc.)  
  - [ ] Store data in Redux or equivalent

- [ ] **Navigation from Home**  
  - [ ] Links to Group Listing  
  - [ ] Links to Notifications screen  
  - [ ] Links to Profile or Settings  
  - [ ] (Optional) Quick actions (new prayer request button, pinned announcements)

---

### 11.3. Group Listing & Details

- [ ] **Group Listing Screen**  
  - [ ] Design layout (group name, description)  
  - [ ] API integration: `GET /groups`  
  - [ ] Pull-to-refresh or infinite scroll (optional)  
  - [ ] (Leader/Admin) Create group button -> “Create Group” screen

- [ ] **Create / Edit Group Screen (Leader/Admin)**  
  - [ ] Form fields: Name, description, privacy (open, request-to-join, invite-only)  
  - [ ] API calls: `POST /groups`, `PUT /groups/:id`  
  - [ ] Validation, UI feedback (loading, success/failure)

- [ ] **Group Detail Screen**  
  - [ ] Display group name, description, privacy, leader info, membership count  
  - [ ] API call: `GET /groups/:id`  
  - [ ] (Optional) Member list  
  - [ ] Join / Leave group button (depends on user role/permissions)  
  - [ ] Link to group’s prayer requests

- [ ] **Manage Members Flow (Leader/Admin)**  
  - [ ] Add members (UI for searching or typing emails) -> `POST /groups/:id/members`  
  - [ ] Remove members -> `DELETE /groups/:id/members/:userId`  
  - [ ] Role-based checks: only leader/admin sees these

---

### 11.4. Prayer Requests & Comments

- [ ] **Prayer Request Listing Screen**  
  - [ ] Display list of requests, with urgency, partial text  
  - [ ] API: `GET /groups/:groupId/requests`  
  - [ ] (Optional) Filter or sort by urgency/status

- [ ] **Create / Edit Prayer Request Screen**  
  - [ ] Title, description, urgency, follow-up date, isAnonymous toggle  
  - [ ] `POST /groups/:groupId/requests`, `PUT /groups/:groupId/requests/:requestId`  
  - [ ] Validation, UI feedback

- [ ] **Prayer Request Detail Screen**  
  - [ ] Show full request text, urgency, follow-up date, status  
  - [ ] Actions: Change status, edit, delete (if owner or leader/admin)  
  - [ ] Show or link to comment section

- [ ] **Commenting Flow**  
  - [ ] Comment list (user name or "Anonymous" if private)  
  - [ ] Add comment: `POST /requests/:requestId/comments`  
  - [ ] isPrivate toggle if supported  
  - [ ] Edit / Delete comment: only if owner  
  - [ ] UI feedback, loading states, error messages

---

### 11.5. Notifications

- [ ] **Notifications Screen**  
  - [ ] List notifications (text, timestamp, read/unread)  
  - [ ] `GET /notifications`  
  - [ ] Mark as read: `PATCH /notifications/:id`  
  - [ ] Pull-to-refresh or auto-refresh logic

- [ ] **Push Notifications (Optional)**  
  - [ ] Obtain device token (Firebase/OneSignal)  
  - [ ] Send token to backend if needed  
  - [ ] Handle push (system notification or in-app alert)  
  - [ ] If user is active, update UI in real time (optional)

---

### 11.6. Profile & Settings

- [ ] **Profile Screen**  
  - [ ] User name, email, avatar (optional)  
  - [ ] API call: `GET /users/:id` or “current user”  
  - [ ] Edit profile: update name, avatar (optional)

- [ ] **Settings Screen**  
  - [ ] Privacy options (default anonymity)  
  - [ ] Notification settings (push/email toggles)  
  - [ ] Dark mode (optional)  
  - [ ] Logout (clear JWT, navigate to Login)

---

### 11.7. Admin-Specific Flows (Optional)

- [ ] **Admin Dashboard Screen**  
  - [ ] Show totals (users, groups, flagged requests)  
  - [ ] `GET /admin/dashboard`

- [ ] **Moderation Flow**  
  - [ ] Remove flagged requests: `DELETE /admin/requests/:requestId`  
  - [ ] Possibly ban users or manage user roles: `PUT /admin/users/:userId`  
  - [ ] Role-based UI checks (only admin sees these options)

---

### 11.8. Navigation & Routing

- [ ] **Navigation library** (React Navigation, Flutter Navigator, etc.)  
  - [ ] Define screens: Login, Registration, Home, GroupListing, GroupDetails, Requests, Comments, Profile, Notifications, Admin  
  - [ ] Tabs or drawer if multi-tab approach  
  - [ ] (Optional) Deep links for push notifications that open a specific screen

- [ ] **State Management**  
  - [ ] Redux (or alternative) store: auth slice, groups slice, requests slice, notifications slice  
  - [ ] Actions / reducers for CRUD operations  
  - [ ] Async flows (Redux Thunk, Saga)  
  - [ ] (Optional) local/offline caching

- [ ] **Testing & QA**  
  - [ ] Unit testing (component tests)  
  - [ ] Integration testing (end-to-end flows)  
  - [ ] Usability checks (accessibility, error handling)

---

### 11.9. Deployment & Distribution

- [ ] **Platform builds**  
  - [ ] Android: Generate signed APK or AAB  
  - [ ] iOS: Generate IPA, handle provisioning profiles

- [ ] **App Store release**  
  - [ ] Google Play Store listing  
  - [ ] Apple App Store listing  
  - [ ] App icons, screenshots, descriptions

- [ ] **Versioning & updates**  
  - [ ] Bump version codes for each release  
  - [ ] Test upgrade path for existing users

---

## 12. Optional Additional Enhancements

- [ ] **Live Prayer Session Links**  
  - [ ] Support Zoom/Google Meet/FaceTime links in group events  
  - [ ] Notify group members when a live session is scheduled

- [ ] **Exporting Data**  
  - [ ] PDF/CSV export for a user’s private prayer journal  
  - [ ] Provide a download link in the user profile page or settings

- [ ] **Theming**  
  - [ ] Light/dark mode toggle  
  - [ ] Consistent branding, color scheme

- [ ] **Offline Mode**  
  - [ ] Cache certain data locally to allow some offline functionality

---

**Happy Building!**  

Use this checklist as a living document. As you progress, mark tasks as complete, adjust for changing requirements, and maintain a clear overview of what remains to be done.
```

## File: client/public/badge-72.svg
```
<?xml version="1.0" encoding="UTF-8"?>
<svg width="72px" height="72px" viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Prayer Pipeline Badge</title>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <circle fill="#4F46E5" cx="36" cy="36" r="36"></circle>
        <path d="M36,20 C39.866,20 43,23.134 43,27 C43,30.866 39.866,34 36,34 C32.134,34 29,30.866 29,27 C29,23.134 32.134,20 36,20 Z M36,24 C34.343,24 33,25.343 33,27 C33,28.657 34.343,30 36,30 C37.657,30 39,28.657 39,27 C39,25.343 37.657,24 36,24 Z" fill="#FFFFFF"></path>
        <path d="M36,38 C39.866,38 43,41.134 43,45 C43,48.866 39.866,52 36,52 C32.134,52 29,48.866 29,45 C29,41.134 32.134,38 36,38 Z M36,42 C34.343,42 33,43.343 33,45 C33,46.657 34.343,48 36,48 C37.657,48 39,46.657 39,45 C39,43.343 37.657,42 36,42 Z" fill="#FFFFFF"></path>
    </g>
</svg>
```

## File: client/public/icon-192.svg
```
<?xml version="1.0" encoding="UTF-8"?>
<svg width="192px" height="192px" viewBox="0 0 192 192" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <title>Prayer Pipeline Icon</title>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <circle fill="#4F46E5" cx="96" cy="96" r="96"></circle>
        <path d="M129.6,60 C135.124,60 139.6,64.476 139.6,70 L139.6,70 L139.6,98 C139.6,103.524 135.124,108 129.6,108 L129.6,108 L119.6,108 L119.6,132 L89.6,108 L62.4,108 C56.876,108 52.4,103.524 52.4,98 L52.4,98 L52.4,70 C52.4,64.476 56.876,60 62.4,60 L62.4,60 Z" fill="#FFFFFF"></path>
        <path d="M96,48 C111.464,48 124,60.536 124,76 C124,91.464 111.464,104 96,104 C80.536,104 68,91.464 68,76 C68,60.536 80.536,48 96,48 Z M96,58 C86.059,58 78,66.059 78,76 C78,85.941 86.059,94 96,94 C105.941,94 114,85.941 114,76 C114,66.059 105.941,58 96,58 Z" fill="#FFFFFF"></path>
        <path d="M96,72 C98.209,72 100,73.791 100,76 C100,78.209 98.209,80 96,80 C93.791,80 92,78.209 92,76 C92,73.791 93.791,72 96,72 Z" fill="#FFFFFF"></path>
        <path d="M96,124 C102.075,124 107.192,125.961 111.002,129.275 C114.812,132.588 116.998,137.027 116.998,142 C116.998,146.973 114.812,151.412 111.002,154.725 C107.192,158.039 102.075,160 96,160 C89.925,160 84.808,158.039 80.998,154.725 C77.188,151.412 75.002,146.973 75.002,142 C75.002,137.027 77.188,132.588 80.998,129.275 C84.808,125.961 89.925,124 96,124 Z M96,134 C92.817,134 89.765,135.264 87.515,137.515 C85.264,139.765 84,142.817 84,146 C84,149.183 85.264,152.235 87.515,154.485 C89.765,156.736 92.817,158 96,158 C99.183,158 102.235,156.736 104.485,154.485 C106.736,152.235 108,149.183 108,146 C108,142.817 106.736,139.765 104.485,137.515 C102.235,135.264 99.183,134 96,134 Z" fill="#FFFFFF"></path>
    </g>
</svg>
```

## File: client/public/service-worker.js
```javascript
// Service Worker for Push Notifications
self.addEventListener('install', (event) => {
  console.log('Service Worker installing');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('Service Worker activating');
  return self.clients.claim();
});

// Handle incoming push notifications
self.addEventListener('push', (event) => {
  console.log('Push notification received', event);

  if (!event.data) {
    console.log('Push event but no data');
    return;
  }

  try {
    // Parse the notification data
    const data = event.data.json();
    console.log('Received notification data:', data);

    // Show the notification
    event.waitUntil(
      self.registration.showNotification(data.title || 'Prayer Pipeline', {
        body: data.body || 'You have a new notification',
        icon: '/icon-192.png',
        badge: '/badge-72.png',
        data: {
          url: data.url || '/'
        },
        timestamp: data.timestamp || Date.now(),
        vibrate: [100, 50, 100],
        actions: [
          {
            action: 'open',
            title: 'Open',
          },
          {
            action: 'close',
            title: 'Close',
          },
        ],
      })
    );
  } catch (error) {
    console.error('Error displaying push notification:', error);
  }
});

// Handle notification click
self.addEventListener('notificationclick', (event) => {
  console.log('Notification click received', event);

  // Close the notification
  event.notification.close();

  // Get the notification data
  const data = event.notification.data;
  const url = data?.url || '/';

  // Handle different actions
  if (event.action === 'close') {
    return;
  }

  // Default action (or "open" action): Open the app
  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clientList) => {
      // Check if there's already a window open
      for (const client of clientList) {
        if (client.url.includes(self.location.origin) && 'focus' in client) {
          // Navigate to the target URL in the existing window
          client.navigate(url);
          return client.focus();
        }
      }

      // If no window is open, open a new one
      if (self.clients.openWindow) {
        return self.clients.openWindow(url);
      }
    })
  );
});
```

## File: client/src/components/ui/accordion.tsx
```typescript
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
```

## File: client/src/components/ui/alert-dialog.tsx
```typescript
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
```

## File: client/src/components/ui/alert.tsx
```typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
```

## File: client/src/components/ui/aspect-ratio.tsx
```typescript
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }
```

## File: client/src/components/ui/avatar.tsx
```typescript
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
```

## File: client/src/components/ui/badge.tsx
```typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
```

## File: client/src/components/ui/breadcrumb.tsx
```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
```

## File: client/src/components/ui/button.tsx
```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
```

## File: client/src/components/ui/calendar.tsx
```typescript
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
```

## File: client/src/components/ui/card.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

## File: client/src/components/ui/carousel.tsx
```typescript
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
```

## File: client/src/components/ui/chart.tsx
```typescript
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
```

## File: client/src/components/ui/checkbox.tsx
```typescript
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
```

## File: client/src/components/ui/collapsible.tsx
```typescript
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
```

## File: client/src/components/ui/command.tsx
```typescript
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
```

## File: client/src/components/ui/context-menu.tsx
```typescript
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
```

## File: client/src/components/ui/dialog.tsx
```typescript
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
```

## File: client/src/components/ui/drawer.tsx
```typescript
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
```

## File: client/src/components/ui/dropdown-menu.tsx
```typescript
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
```

## File: client/src/components/ui/form.tsx
```typescript
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
```

## File: client/src/components/ui/hover-card.tsx
```typescript
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }
```

## File: client/src/components/ui/input-otp.tsx
```typescript
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
```

## File: client/src/components/ui/input.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```

## File: client/src/components/ui/label.tsx
```typescript
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
```

## File: client/src/components/ui/menubar.tsx
```typescript
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
```

## File: client/src/components/ui/navigation-menu.tsx
```typescript
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
```

## File: client/src/components/ui/pagination.tsx
```typescript
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
```

## File: client/src/components/ui/popover.tsx
```typescript
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
```

## File: client/src/components/ui/progress.tsx
```typescript
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
```

## File: client/src/components/ui/radio-group.tsx
```typescript
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
```

## File: client/src/components/ui/resizable.tsx
```typescript
import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
```

## File: client/src/components/ui/scroll-area.tsx
```typescript
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
```

## File: client/src/components/ui/select.tsx
```typescript
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
```

## File: client/src/components/ui/separator.tsx
```typescript
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
```

## File: client/src/components/ui/sheet.tsx
```typescript
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
```

## File: client/src/components/ui/sidebar.tsx
```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        if (setOpenProp) {
          return setOpenProp?.(
            typeof value === "function" ? value(open) : value
          )
        }

        _setOpen(value)

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${open}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full text-sidebar-foreground has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
```

## File: client/src/components/ui/skeleton.tsx
```typescript
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
```

## File: client/src/components/ui/slider.tsx
```typescript
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
```

## File: client/src/components/ui/switch.tsx
```typescript
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
```

## File: client/src/components/ui/table.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
```

## File: client/src/components/ui/tabs.tsx
```typescript
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
```

## File: client/src/components/ui/textarea.tsx
```typescript
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
```

## File: client/src/components/ui/toast.tsx
```typescript
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
```

## File: client/src/components/ui/toaster.tsx
```typescript
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
```

## File: client/src/components/ui/toggle-group.tsx
```typescript
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
```

## File: client/src/components/ui/toggle.tsx
```typescript
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
```

## File: client/src/components/ui/tooltip.tsx
```typescript
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
```

## File: client/src/components/category-groups.tsx
```typescript
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { 
  Tabs, 
  TabsContent, 
  TabsList, 
  TabsTrigger 
} from "@/components/ui/tabs";
import { Skeleton } from "@/components/ui/skeleton";
import GroupCard from "@/components/group-card";

interface CategoryGroupsProps {
  currentOrganizationId?: number;
  activeTab: string;
  onChangeTab: (tab: string) => void;
}

export default function CategoryGroups({ currentOrganizationId, activeTab, onChangeTab }: CategoryGroupsProps) {
  const [_, navigate] = useLocation();
  const [activeCategory, setActiveCategory] = useState("all");
  
  // Fetch all groups
  const {
    data: allGroups,
    isLoading: isLoadingAllGroups,
  } = useQuery({
    queryKey: ["/api/groups", currentOrganizationId],
    queryFn: () => {
      if (!currentOrganizationId) return Promise.resolve([]);
      return fetch(`/api/groups?organizationId=${currentOrganizationId}`)
        .then(res => {
          if (!res.ok) throw new Error('Failed to fetch groups');
          return res.json();
        });
    },
    enabled: !!currentOrganizationId && activeTab === "explore",
  });

  // Fetch user's groups
  const {
    data: userGroups,
    isLoading: isLoadingUserGroups,
  } = useQuery({
    queryKey: ["/api/groups/user", currentOrganizationId],
    queryFn: () => {
      if (!currentOrganizationId) return Promise.resolve([]);
      return fetch(`/api/groups/user?organizationId=${currentOrganizationId}`)
        .then(res => {
          if (!res.ok) throw new Error('Failed to fetch user groups');
          return res.json();
        });
    },
    enabled: !!currentOrganizationId && activeTab === "my-groups",
  });

  // Fetch groups by category when a category is selected
  const {
    data: categoryGroups,
    isLoading: isLoadingCategoryGroups,
  } = useQuery({
    queryKey: ["/api/groups/category", activeCategory, currentOrganizationId],
    queryFn: () => {
      if (!currentOrganizationId) return Promise.resolve([]);
      return fetch(`/api/groups/category/${activeCategory}?organizationId=${currentOrganizationId}`)
        .then(res => {
          if (!res.ok) throw new Error(`Failed to fetch ${activeCategory} groups`);
          return res.json();
        });
    },
    enabled: activeCategory !== "all" && !!currentOrganizationId && activeTab === "explore",
  });

  // Determine which groups to display
  let displayGroups;
  let isLoading;
  
  if (activeTab === "my-groups") {
    displayGroups = userGroups;
    isLoading = isLoadingUserGroups;
  } else {
    // For explore tab
    displayGroups = activeCategory === "all" ? allGroups : categoryGroups;
    isLoading = activeCategory === "all" ? isLoadingAllGroups : isLoadingCategoryGroups;
  }

  const handleCategoryChange = (category: string) => {
    setActiveCategory(category);
  };

  return (
    <div className="space-y-6">
      <Tabs defaultValue={activeTab} onValueChange={onChangeTab} className="w-full">
        <TabsList className="grid grid-cols-2 mb-6">
          <TabsTrigger value="explore">Explore Groups</TabsTrigger>
          <TabsTrigger value="my-groups">My Groups</TabsTrigger>
        </TabsList>

        <TabsContent value="explore" className="mt-0">
          <h2 className="text-2xl font-bold mb-4">Explore Prayer Groups</h2>
          
          <Tabs defaultValue="all" onValueChange={handleCategoryChange} className="w-full">
            <TabsList className="grid grid-cols-5 mb-6">
              <TabsTrigger value="all">All</TabsTrigger>
              <TabsTrigger value="health">Health</TabsTrigger>
              <TabsTrigger value="family">Family</TabsTrigger>
              <TabsTrigger value="career">Career</TabsTrigger>
              <TabsTrigger value="relationship">Relationships</TabsTrigger>
            </TabsList>

            <TabsContent value="all" className="mt-0">
              <GroupsList groups={allGroups} isLoading={isLoadingAllGroups} onGroupClick={(id) => navigate(`/groups/${id}`)} />
            </TabsContent>
            
            <TabsContent value="health" className="mt-0">
              <GroupsList groups={categoryGroups} isLoading={isLoadingCategoryGroups} onGroupClick={(id) => navigate(`/groups/${id}`)} />
            </TabsContent>
            
            <TabsContent value="family" className="mt-0">
              <GroupsList groups={categoryGroups} isLoading={isLoadingCategoryGroups} onGroupClick={(id) => navigate(`/groups/${id}`)} />
            </TabsContent>
            
            <TabsContent value="career" className="mt-0">
              <GroupsList groups={categoryGroups} isLoading={isLoadingCategoryGroups} onGroupClick={(id) => navigate(`/groups/${id}`)} />
            </TabsContent>
            
            <TabsContent value="relationship" className="mt-0">
              <GroupsList groups={categoryGroups} isLoading={isLoadingCategoryGroups} onGroupClick={(id) => navigate(`/groups/${id}`)} />
            </TabsContent>
          </Tabs>
        </TabsContent>
        
        <TabsContent value="my-groups" className="mt-0">
          <h2 className="text-2xl font-bold mb-4">My Prayer Groups</h2>
          <GroupsList 
            groups={userGroups} 
            isLoading={isLoadingUserGroups} 
            onGroupClick={(id) => navigate(`/groups/${id}`)}
            emptyMessage="You haven't joined any groups yet."
          />
        </TabsContent>
      </Tabs>
    </div>
  );
}

function GroupsList({ 
  groups, 
  isLoading, 
  onGroupClick,
  emptyMessage = "No groups found for this category."
}: { 
  groups?: any[];
  isLoading: boolean;
  onGroupClick: (id: number) => void;
  emptyMessage?: string;
}) {
  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {Array(6).fill(0).map((_, index) => (
          <Skeleton key={index} className="h-48 w-full rounded-lg" />
        ))}
      </div>
    );
  }

  if (!groups || groups.length === 0) {
    return (
      <div className="text-center py-10 bg-neutral-50 rounded-lg">
        <p className="text-neutral-600">{emptyMessage}</p>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {groups.map((group) => (
        <GroupCard 
          key={group.id} 
          group={group} 
          onClick={() => onGroupClick(group.id)}
        />
      ))}
    </div>
  );
}
```

## File: client/src/components/comment-card.tsx
```typescript
import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

type CommentCardProps = {
  comment: any;
  requestId: number;
};

export default function CommentCard({ comment, requestId }: CommentCardProps) {
  const { toast } = useToast();
  const [isEditing, setIsEditing] = useState(false);
  const [editedText, setEditedText] = useState(comment.text);
  const [isPrivate, setIsPrivate] = useState(comment.isPrivate);
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);

  // Format date to relative time (e.g., 2 days ago)
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
      return "Today";
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (diffDays < 30) {
      return `${diffDays} days ago`;
    } else {
      return date.toLocaleDateString();
    }
  };

  // Update comment mutation
  const updateCommentMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("PUT", `/api/comments/${comment.id}`, {
        text: editedText,
        isPrivate,
      });
    },
    onSuccess: () => {
      toast({
        title: "Comment updated",
        description: "Your comment has been updated successfully.",
      });
      setIsEditing(false);
      queryClient.invalidateQueries({
        queryKey: [`/api/requests/${requestId}/comments`],
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Delete comment mutation
  const deleteCommentMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/comments/${comment.id}`, {});
    },
    onSuccess: () => {
      toast({
        title: "Comment deleted",
        description: "Your comment has been removed",
      });
      queryClient.invalidateQueries({
        queryKey: [`/api/requests/${requestId}/comments`],
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const getInitials = (name: string) => {
    return name
      .split(" ")
      .map((n) => n[0])
      .join("")
      .substring(0, 2)
      .toUpperCase();
  };

  return (
    <div className="bg-white rounded-lg shadow p-4">
      <div className="flex justify-between">
        <div className="flex items-center">
          <span className="h-8 w-8 rounded-full bg-primary-100 flex items-center justify-center text-primary-800 font-medium">
            {getInitials(comment.author.name)}
          </span>
          <div className="ml-2">
            <h4 className="font-medium text-neutral-800 text-sm">
              {comment.author.name}
            </h4>
            <p className="text-xs text-neutral-500">
              {formatDate(comment.createdAt)}
            </p>
          </div>
        </div>
        <div className="flex items-center">
          {comment.isPrivate && (
            <span className="text-xs text-primary-600 bg-primary-50 px-2 py-1 rounded-full">
              Private
            </span>
          )}
        </div>
      </div>

      {isEditing ? (
        <div className="mt-3">
          <Textarea
            value={editedText}
            onChange={(e) => setEditedText(e.target.value)}
            rows={3}
            className="w-full px-3 py-2 border border-neutral-200 rounded-lg"
          />
          <div className="flex items-center justify-between mt-2">
            <div className="flex items-center space-x-2">
              <Checkbox
                id="editIsPrivate"
                checked={isPrivate}
                onCheckedChange={(checked) => setIsPrivate(!!checked)}
              />
              <label
                htmlFor="editIsPrivate"
                className="text-xs text-neutral-600 cursor-pointer"
              >
                Private
              </label>
            </div>
            <div className="flex space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => {
                  setIsEditing(false);
                  setEditedText(comment.text);
                  setIsPrivate(comment.isPrivate);
                }}
              >
                Cancel
              </Button>
              <Button
                size="sm"
                onClick={() => updateCommentMutation.mutate()}
                disabled={!editedText.trim() || updateCommentMutation.isPending}
              >
                {updateCommentMutation.isPending ? "Saving..." : "Save"}
              </Button>
            </div>
          </div>
        </div>
      ) : (
        <>
          <p className="text-neutral-700 text-sm mt-3">{comment.text}</p>
          {comment.isOwn && (
            <div className="mt-2 text-right">
              <Button
                variant="ghost"
                size="sm"
                className="text-xs text-neutral-500 hover:text-neutral-700"
                onClick={() => setIsEditing(true)}
              >
                Edit
              </Button>
              <Button
                variant="ghost"
                size="sm"
                className="text-xs text-red-500 hover:text-red-700 ml-2"
                onClick={() => setDeleteConfirmOpen(true)}
              >
                Delete
              </Button>
            </div>
          )}
        </>
      )}

      {/* Delete Comment Confirmation */}
      <AlertDialog
        open={deleteConfirmOpen}
        onOpenChange={setDeleteConfirmOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Comment</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this comment? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => deleteCommentMutation.mutate()}
              className="bg-red-600 text-white hover:bg-red-700"
            >
              {deleteCommentMutation.isPending ? "Deleting..." : "Delete Comment"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```

## File: client/src/components/create-group-modal.tsx
```typescript
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "@tanstack/react-query";
import { insertGroupSchema } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { useOrganizations } from "@/hooks/use-organizations";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

type CreateGroupModalProps = {
  open: boolean;
  setOpen: (open: boolean) => void;
  organizationId?: number; // Optional organization ID prop
};

export default function CreateGroupModal({
  open,
  setOpen,
  organizationId,
}: CreateGroupModalProps) {
  const { toast } = useToast();
  const { user } = useAuth();
  const { organizations: userOrgs } = useOrganizations();
  
  // If no organizationId is provided, use the first organization the user is a member of
  // This ensures we always have a valid organization ID for group creation
  const activeOrgId = organizationId || (userOrgs.length ? userOrgs[0].id : undefined);

  // Define our form schema type
  const createGroupSchema = insertGroupSchema.omit({ createdBy: true });
  type CreateGroupInput = z.infer<typeof createGroupSchema>;
  
  const form = useForm<CreateGroupInput>({
    resolver: zodResolver(createGroupSchema),
    defaultValues: {
      name: "",
      description: "",
      category: "other",
      privacy: "request",
      leaderRotation: 0,
      organizationId: activeOrgId,
    },
  });

  // Update form when organizationId changes
  useEffect(() => {
    if (activeOrgId) {
      form.setValue("organizationId", activeOrgId);
    }
  }, [activeOrgId, form]);

  const createGroupMutation = useMutation({
    mutationFn: async (data: CreateGroupInput) => {
      await apiRequest("POST", "/api/groups", data);
    },
    onSuccess: () => {
      toast({
        title: "Group created",
        description: "Your new prayer group has been created successfully.",
      });
      // Reset form and close modal
      form.reset();
      setOpen(false);
      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: ["/api/groups/user"] });
      queryClient.invalidateQueries({ queryKey: ["/api/groups"] });
    },
    onError: (error) => {
      toast({
        title: "Error creating group",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: CreateGroupInput) => {
    // Don't allow submitting without an organization ID
    if (!data.organizationId) {
      toast({
        title: "Error creating group",
        description: "You must be a member of an organization to create a group.",
        variant: "destructive",
      });
      return;
    }
    
    createGroupMutation.mutate(data);
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="text-xl font-bold">
            Create New Prayer Group
          </DialogTitle>
          <DialogDescription>
            Create a new group to share prayer requests with others.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Group Name</FormLabel>
                  <FormControl>
                    <Input
                      placeholder="e.g., Morning Prayer Group"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="What is this prayer group about?"
                      rows={3}
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="category"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Category</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select a category" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="health">Health</SelectItem>
                      <SelectItem value="career">Career</SelectItem>
                      <SelectItem value="family">Family</SelectItem>
                      <SelectItem value="relationship">Relationship</SelectItem>
                      <SelectItem value="other">Other</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="privacy"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Privacy Settings</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select group privacy" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="open">
                        Open (Anyone can join)
                      </SelectItem>
                      <SelectItem value="request">
                        Request to Join
                      </SelectItem>
                      <SelectItem value="invite">
                        Invite Only
                      </SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="leaderRotation"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Leadership Rotation</FormLabel>
                  <Select
                    onValueChange={(val) => field.onChange(parseInt(val))}
                    defaultValue={field.value.toString()}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select leadership rotation" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="0">
                        No Rotation (Fixed Leader)
                      </SelectItem>
                      <SelectItem value="30">
                        Rotate Every 30 Days
                      </SelectItem>
                      <SelectItem value="60">
                        Rotate Every 60 Days
                      </SelectItem>
                      <SelectItem value="90">
                        Rotate Every 90 Days
                      </SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="pt-2">
              <Button
                type="button"
                variant="outline"
                onClick={() => setOpen(false)}
              >
                Cancel
              </Button>
              <Button 
                type="submit"
                disabled={createGroupMutation.isPending}
              >
                {createGroupMutation.isPending ? (
                  <div className="flex items-center">
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                    </svg>
                    Creating...
                  </div>
                ) : (
                  "Create Group"
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

## File: client/src/components/create-meeting-modal.tsx
```typescript
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from "@/components/ui/form";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { insertMeetingSchema } from "@shared/schema";
import { CreateMeetingInput, useMeetings } from "@/hooks/use-meetings";
import { Loader2, Calendar, Clock, RotateCw } from "lucide-react";
import { format, addDays } from "date-fns";
import { Checkbox } from "@/components/ui/checkbox";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";

type CreateMeetingModalProps = {
  groupId: number;
  open: boolean;
  onOpenChange: (open: boolean) => void;
};

export default function CreateMeetingModal({ groupId, open, onOpenChange }: CreateMeetingModalProps) {
  const { createMeeting, isCreatingMeeting } = useMeetings(groupId);
  const [meetingPlatform, setMeetingPlatform] = useState<"zoom" | "google" | "physical">("zoom");
  const [isRecurring, setIsRecurring] = useState(false);

  // Create a form schema with validations
  const formSchema = insertMeetingSchema.extend({
    // Add form-specific fields
    meetingDate: z.string().refine(
      (val) => {
        try {
          const date = new Date(val);
          return !isNaN(date.getTime()) && date > new Date();
        } catch (e) {
          return false;
        }
      },
      {
        message: "Meeting date must be in the future",
      }
    ),
    meetingTime: z.string().refine(
      (val) => {
        return /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(val);
      },
      {
        message: "Meeting time must be in HH:MM format",
      }
    ),
    // Override date fields to use strings for form handling
    recurringUntil: z.string().optional(),
  }).omit({ 
    groupId: true, 
    createdBy: true, 
    parentMeetingId: true,
    // Remove the Date fields that we're replacing with string versions
    startTime: true,
    endTime: true,
  });

  // Get form methods
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: "",
      description: "",
      meetingDate: format(new Date(Date.now() + 86400000), "yyyy-MM-dd"), // Tomorrow
      meetingTime: "18:00",
      meetingType: "zoom" as "zoom" | "google_meet",
      meetingLink: "",
      isRecurring: false,
      recurringPattern: "weekly" as "daily" | "weekly" | "biweekly" | "monthly",
      recurringDay: null,
      recurringUntil: format(addDays(new Date(), 90), "yyyy-MM-dd"), // Default to 90 days
    },
  });

  // Handle form submission
  const onSubmit = (values: z.infer<typeof formSchema>) => {
    // Combine date and time into a single ISO string
    const meetingDateTime = new Date(`${values.meetingDate}T${values.meetingTime}`);
    
    // Set the meetingType based on platform selection
    let meetingType: "zoom" | "google_meet" = values.meetingType;
    if (meetingPlatform === "zoom") {
      meetingType = "zoom";
    } else if (meetingPlatform === "google") {
      meetingType = "google_meet";
    }
    
    // Create meeting data object with proper Date objects
    const meetingData: CreateMeetingInput = {
      groupId,
      title: values.title,
      description: values.description || "",
      startTime: meetingDateTime, // Using Date object directly
      endTime: null, // Can be enhanced to add end time field
      meetingType,
      meetingLink: meetingPlatform === "physical" ? "In Person" : values.meetingLink,
      isRecurring: values.isRecurring,
      createdBy: 0, // Will be set by the server
    };
    
    // Add recurring meeting fields if applicable
    if (values.isRecurring && values.recurringPattern) {
      meetingData.recurringPattern = values.recurringPattern;
      
      // Set the recurringDay based on the pattern
      if (values.recurringPattern === "monthly" && values.recurringDay !== null) {
        meetingData.recurringDay = values.recurringDay;
      } else if (values.recurringPattern === "weekly") {
        // For weekly, store the day of week (0-6, where 0 is Sunday)
        meetingData.recurringDay = meetingDateTime.getDay();
      }
      
      // Set the recurring end date
      if (values.recurringUntil) {
        // Create a Date object from the string date
        meetingData.recurringUntil = new Date(`${values.recurringUntil}T23:59:59`);
      }
    }
    
    // Submit the form
    createMeeting(meetingData, {
      onSuccess: () => {
        // Close the modal and reset form
        onOpenChange(false);
        form.reset();
        setIsRecurring(false);
      },
    });
  };

  // Handle meeting platform selection
  const handlePlatformChange = (platform: typeof meetingPlatform) => {
    setMeetingPlatform(platform);
    
    // Set the meetingType based on platform
    if (platform === "zoom") {
      form.setValue("meetingType", "zoom");
    } else if (platform === "google") {
      form.setValue("meetingType", "google_meet");
    }
  };

  // Watch the isRecurring field
  const watchIsRecurring = form.watch("isRecurring");
  
  // Update state when form value changes
  const onIsRecurringChange = (checked: boolean) => {
    setIsRecurring(checked);
    form.setValue("isRecurring", checked);
  };

  // Watch the recurringPattern to determine which fields to show
  const watchRecurringPattern = form.watch("recurringPattern");

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Schedule a Meeting</DialogTitle>
          <DialogDescription>
            Create a new prayer meeting for your group.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="title"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Meeting Title</FormLabel>
                  <FormControl>
                    <Input placeholder="Weekly Prayer Meeting" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="Join us for our weekly prayer session"
                      onChange={field.onChange}
                      onBlur={field.onBlur}
                      ref={field.ref}
                      name={field.name}
                      value={field.value || ""}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="meetingDate"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Calendar className="h-4 w-4" />
                      Date
                    </FormLabel>
                    <FormControl>
                      <Input type="date" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="meetingTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel className="flex items-center gap-2">
                      <Clock className="h-4 w-4" />
                      Time
                    </FormLabel>
                    <FormControl>
                      <Input type="time" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <div className="space-y-2">
              <FormLabel>Meeting Type</FormLabel>
              <div className="flex gap-2">
                <Button
                  type="button"
                  variant={meetingPlatform === "zoom" ? "default" : "outline"}
                  className="flex-1"
                  onClick={() => handlePlatformChange("zoom")}
                >
                  Zoom
                </Button>
                <Button
                  type="button"
                  variant={meetingPlatform === "google" ? "default" : "outline"}
                  className="flex-1"
                  onClick={() => handlePlatformChange("google")}
                >
                  Google Meet
                </Button>
                <Button
                  type="button"
                  variant={meetingPlatform === "physical" ? "default" : "outline"}
                  className="flex-1"
                  onClick={() => handlePlatformChange("physical")}
                >
                  In Person
                </Button>
              </div>
            </div>

            {meetingPlatform !== "physical" && (
              <FormField
                control={form.control}
                name="meetingLink"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Meeting Link</FormLabel>
                    <FormControl>
                      <Input
                        placeholder={`${meetingPlatform === "zoom" ? "Zoom" : "Google Meet"} meeting link`}
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            )}

            <div className="border-t pt-4">
              <FormField
                control={form.control}
                name="isRecurring"
                render={({ field }) => (
                  <FormItem className="flex flex-row items-center space-x-3 space-y-0 py-2">
                    <FormControl>
                      <Checkbox 
                        checked={field.value} 
                        onCheckedChange={onIsRecurringChange}
                      />
                    </FormControl>
                    <div className="space-y-1 leading-none">
                      <FormLabel className="flex items-center gap-2">
                        <RotateCw className="h-4 w-4" />
                        Recurring Meeting
                      </FormLabel>
                      <FormDescription>
                        Create a series of meetings that repeat automatically
                      </FormDescription>
                    </div>
                  </FormItem>
                )}
              />
            </div>

            {watchIsRecurring && (
              <div className="border rounded-md p-4 space-y-4 bg-muted/20">
                <FormField
                  control={form.control}
                  name="recurringPattern"
                  render={({ field }) => (
                    <FormItem className="space-y-3">
                      <FormLabel>Recurrence Pattern</FormLabel>
                      <FormControl>
                        <RadioGroup 
                          onValueChange={(value) => {
                            // Explicitly cast the value to the expected type
                            field.onChange(value as "daily" | "weekly" | "biweekly" | "monthly");
                          }} 
                          defaultValue={field.value || "weekly"} 
                          className="flex flex-col space-y-1"
                        >
                          <FormItem className="flex items-center space-x-3 space-y-0">
                            <FormControl>
                              <RadioGroupItem value="daily" />
                            </FormControl>
                            <FormLabel className="font-normal">
                              Daily
                            </FormLabel>
                          </FormItem>
                          <FormItem className="flex items-center space-x-3 space-y-0">
                            <FormControl>
                              <RadioGroupItem value="weekly" />
                            </FormControl>
                            <FormLabel className="font-normal">
                              Weekly
                            </FormLabel>
                          </FormItem>
                          <FormItem className="flex items-center space-x-3 space-y-0">
                            <FormControl>
                              <RadioGroupItem value="biweekly" />
                            </FormControl>
                            <FormLabel className="font-normal">
                              Bi-weekly
                            </FormLabel>
                          </FormItem>
                          <FormItem className="flex items-center space-x-3 space-y-0">
                            <FormControl>
                              <RadioGroupItem value="monthly" />
                            </FormControl>
                            <FormLabel className="font-normal">
                              Monthly
                            </FormLabel>
                          </FormItem>
                        </RadioGroup>
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                {watchRecurringPattern === "monthly" && (
                  <FormField
                    control={form.control}
                    name="recurringDay"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Day of Month</FormLabel>
                        <Select 
                          onValueChange={(value) => field.onChange(parseInt(value))}
                          defaultValue={field.value?.toString() || ""}
                        >
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder="Select a day" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            {[...Array(31)].map((_, i) => (
                              <SelectItem key={i + 1} value={(i + 1).toString()}>
                                {i + 1}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                        <FormDescription>
                          For months with fewer days, the last day of the month will be used.
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                )}

                <FormField
                  control={form.control}
                  name="recurringUntil"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>End Date</FormLabel>
                      <FormControl>
                        <Input 
                          type="date" 
                          {...field}
                          value={typeof field.value === 'string' ? field.value : format(new Date(), 'yyyy-MM-dd')}
                        />
                      </FormControl>
                      <FormDescription>
                        When the recurring meetings should end (maximum 90 days)
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            )}

            <DialogFooter>
              <Button 
                variant="outline" 
                type="button" 
                onClick={() => onOpenChange(false)}
                disabled={isCreatingMeeting}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isCreatingMeeting}>
                {isCreatingMeeting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                {watchIsRecurring ? 'Schedule Recurring Meetings' : 'Schedule Meeting'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

## File: client/src/components/create-request-modal.tsx
```typescript
import { useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useQuery, useMutation } from "@tanstack/react-query";
import { insertPrayerRequestSchema } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { 
  Popover, 
  PopoverContent, 
  PopoverTrigger 
} from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { format } from "date-fns";
import { CalendarIcon } from "lucide-react";

type CreateRequestModalProps = {
  open: boolean;
  setOpen: (open: boolean) => void;
  defaultGroupId?: number;
};

export default function CreateRequestModal({
  open,
  setOpen,
  defaultGroupId,
}: CreateRequestModalProps) {
  const { toast } = useToast();

  // Fetch user's groups
  const { data: userGroups = [] } = useQuery<any[]>({
    queryKey: ["/api/groups/user"],
  });

  // Define our form schema type
  const createRequestSchema = insertPrayerRequestSchema.omit({ userId: true });
  type CreateRequestInput = z.infer<typeof createRequestSchema>;
  
  const form = useForm<CreateRequestInput>({
    resolver: zodResolver(createRequestSchema),
    defaultValues: {
      title: "",
      description: "",
      groupId: defaultGroupId || 0,
      urgency: "medium",
      isAnonymous: false,
      status: "waiting",
      followUpDate: undefined,
    },
  });

  // Update the form when defaultGroupId changes
  useEffect(() => {
    if (defaultGroupId) {
      form.setValue("groupId", defaultGroupId);
    }
  }, [defaultGroupId, form]);

  const createRequestMutation = useMutation({
    mutationFn: async (data: CreateRequestInput): Promise<void> => {
      await apiRequest("POST", `/api/groups/${data.groupId}/requests`, data);
    },
    onSuccess: () => {
      toast({
        title: "Prayer request created",
        description: "Your prayer request has been submitted successfully.",
      });
      // Reset form and close modal
      form.reset();
      setOpen(false);
      // Invalidate relevant queries
      if (defaultGroupId) {
        queryClient.invalidateQueries({ queryKey: [`/api/groups/${defaultGroupId}/requests`] });
      }
      queryClient.invalidateQueries({ queryKey: ["/api/requests/user/recent"] });
    },
    onError: (error) => {
      toast({
        title: "Error creating prayer request",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: CreateRequestInput) => {
    // Handle date conversion for followUpDate
    const formattedData = {
      ...data,
      // Convert string date to Date object if it exists
      followUpDate: data.followUpDate ? new Date(data.followUpDate) : undefined
    };
    
    createRequestMutation.mutate(formattedData);
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="text-xl font-bold">
            New Prayer Request
          </DialogTitle>
          <DialogDescription>
            Share your prayer need with your group.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="title"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Title</FormLabel>
                  <FormControl>
                    <Input
                      placeholder="e.g., Healing for my mother"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {!defaultGroupId && (
              <FormField
                control={form.control}
                name="groupId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Group</FormLabel>
                    <Select
                      onValueChange={(value) => field.onChange(parseInt(value))}
                      defaultValue={field.value?.toString() || ""}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select a group" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {userGroups?.map((group) => (
                          <SelectItem key={group.id} value={group.id.toString()}>
                            {group.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            )}

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="Share details about your prayer request..."
                      rows={4}
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="urgency"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Urgency</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select urgency level" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="low">
                        Low - Ongoing need
                      </SelectItem>
                      <SelectItem value="medium">
                        Medium - Important but not critical
                      </SelectItem>
                      <SelectItem value="high">
                        High - Urgent situation
                      </SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="isAnonymous"
              render={({ field }) => (
                <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md p-2">
                  <FormControl>
                    <Checkbox
                      checked={field.value}
                      onCheckedChange={field.onChange}
                    />
                  </FormControl>
                  <div className="space-y-1 leading-none">
                    <FormLabel>
                      Post anonymously (your name won't be shown)
                    </FormLabel>
                  </div>
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="followUpDate"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <FormLabel>Follow-up Date</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant="outline"
                          className={`w-full pl-3 text-left font-normal ${!field.value && "text-muted-foreground"}`}
                        >
                          {field.value ? (
                            format(new Date(field.value), "PPP")
                          ) : (
                            <span>Pick a date for follow-up</span>
                          )}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={field.value ? new Date(field.value) : undefined}
                        onSelect={field.onChange}
                        disabled={(date) => date < new Date()}
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                  <FormDescription>
                    Set a date to check back on this prayer request. You'll receive a reminder when this date arrives.
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="pt-2">
              <Button
                type="button"
                variant="outline"
                onClick={() => setOpen(false)}
              >
                Cancel
              </Button>
              <Button 
                type="submit"
                disabled={createRequestMutation.isPending}
              >
                {createRequestMutation.isPending ? (
                  <div className="flex items-center">
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                    </svg>
                    Submitting...
                  </div>
                ) : (
                  "Submit Request"
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

## File: client/src/components/favorite-groups-section.tsx
```typescript
import React from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Link } from "wouter";
import { Group } from "@shared/schema";
import { Loader2 } from "lucide-react";
import { useFavoriteGroups, FavoriteButton } from "@/hooks/use-favorite-groups";

export default function FavoriteGroupsSection() {
  const { favoriteGroups, isLoading, removeFromFavorites } = useFavoriteGroups();

  if (isLoading) {
    return (
      <Card className="mb-6">
        <CardHeader>
          <CardTitle>Your Favorite Groups</CardTitle>
          <CardDescription>Quick access to your favorite prayer groups</CardDescription>
        </CardHeader>
        <CardContent className="flex items-center justify-center py-8">
          <Loader2 className="h-8 w-8 animate-spin text-border" />
        </CardContent>
      </Card>
    );
  }

  if (favoriteGroups.length === 0) {
    return (
      <Card className="mb-6">
        <CardHeader>
          <CardTitle>Your Favorite Groups</CardTitle>
          <CardDescription>Star groups to add them to your favorites</CardDescription>
        </CardHeader>
        <CardContent className="text-center text-muted-foreground py-6">
          <p>You haven't added any groups to your favorites yet.</p>
          <p className="text-sm mt-2">
            Add groups to favorites to quickly access them here.
          </p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="mb-6">
      <CardHeader>
        <CardTitle>Your Favorite Groups</CardTitle>
        <CardDescription>Quick access to your favorite prayer groups</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="grid gap-3">
          {favoriteGroups.map((group) => (
            <GroupCard 
              key={group.id} 
              group={group} 
              onRemoveFavorite={() => removeFromFavorites(group.id)} 
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
}

function GroupCard({ 
  group, 
  onRemoveFavorite 
}: { 
  group: Group, 
  onRemoveFavorite: () => void 
}) {
  return (
    <Link href={`/groups/${group.id}`}>
      <div className="relative p-4 border rounded-lg hover:bg-accent/50 transition-colors cursor-pointer group flex justify-between items-center">
        <div>
          <h3 className="font-medium text-primary">{group.name}</h3>
          <p className="text-sm text-muted-foreground line-clamp-1">
            {group.description || "No description available"}
          </p>
        </div>
        <div className="absolute top-2 right-2">
          <FavoriteButton 
            groupId={group.id} 
            isFavorite={true} 
            isLoading={false} 
            onToggle={onRemoveFavorite} 
            size="sm"
          />
        </div>
      </div>
    </Link>
  );
}
```

## File: client/src/components/group-card.tsx
```typescript
import { Button } from "@/components/ui/button";
import { useFavoriteGroups, FavoriteButton } from "@/hooks/use-favorite-groups";
import { Group } from "@shared/schema";

type GroupCardProps = {
  group: Group;
  onClick?: () => void;
  showFavoriteButton?: boolean;
};

export default function GroupCard({ 
  group, 
  onClick,
  showFavoriteButton = true
}: GroupCardProps) {
  // Use a default member count since the actual member count might not be available in the Group object
  // In a real implementation, you would get this from the group.members.length
  const memberCount = 0;

  return (
    <div 
      className="bg-white rounded-lg shadow p-4 hover:shadow-md transition-shadow cursor-pointer"
      onClick={onClick}
    >
      <div className="flex justify-between items-start">
        <div>
          <h4 className="font-medium text-neutral-800">{group.name}</h4>
          <p className="text-sm text-neutral-600 mt-1 line-clamp-1">{group.description}</p>
        </div>
        {showFavoriteButton && (
          <div onClick={(e) => e.stopPropagation()}>
            <GroupFavoriteButton groupId={group.id} />
          </div>
        )}
      </div>
      <div className="mt-3 flex items-center justify-between">
        <div className="flex items-center">
          <div className="flex -space-x-1 overflow-hidden">
            {/* This would be actual member avatars in a real implementation */}
            <span className="h-6 w-6 rounded-full bg-primary-100 text-primary-800 text-xs flex items-center justify-center">A</span>
            <span className="h-6 w-6 rounded-full bg-green-100 text-green-800 text-xs flex items-center justify-center">B</span>
            <span className="h-6 w-6 rounded-full bg-neutral-100 text-neutral-800 text-xs flex items-center justify-center">+</span>
          </div>
          <span className="ml-2 text-xs text-neutral-500">{memberCount} members</span>
        </div>
        <Button
          variant="ghost"
          size="sm"
          className="text-primary text-sm hover:text-primary/90"
          onClick={(e) => {
            e.stopPropagation();
            onClick && onClick();
          }}
        >
          View
        </Button>
      </div>
    </div>
  );
}

// GroupFavoriteButton component to handle favorite status for a group
function GroupFavoriteButton({ groupId }: { groupId: number }) {
  const { isFavorite, toggleFavorite, isPendingAdd, isPendingRemove } = useFavoriteGroups();
  
  // Use the isFavorite function to check if this group is favorited
  const isGroupFavorite = isFavorite(groupId);
  const isPending = isPendingAdd || isPendingRemove;

  return (
    <FavoriteButton 
      groupId={groupId}
      isFavorite={isGroupFavorite}
      isLoading={isPending}
      onToggle={() => toggleFavorite(groupId, isGroupFavorite)}
      size="sm"
    />
  );
}
```

## File: client/src/components/groups-list.tsx
```typescript
import React from "react";
import { Group } from "@shared/schema";
import { useFavoriteGroups } from "@/hooks/use-favorite-groups";
import GroupCard from "@/components/group-card";
import { Button } from "@/components/ui/button";
import { useLocation } from "wouter";

interface GroupsListProps {
  groups: Group[];
  onGroupClick: (groupId: number) => void;
  maxShown?: number;
}

export default function GroupsList({ 
  groups, 
  onGroupClick, 
  maxShown = 5 
}: GroupsListProps) {
  const { favoriteGroups } = useFavoriteGroups();
  const [, navigate] = useLocation();
  
  // Find favorite groups that are also in the user's groups
  const favoriteGroupIds = new Set(favoriteGroups.map(g => g.id));
  
  // Split groups into favorites and non-favorites
  const favorites = groups.filter(group => favoriteGroupIds.has(group.id));
  const nonFavorites = groups.filter(group => !favoriteGroupIds.has(group.id));
  
  // Combine them with favorites first, limited to maxShown
  const displayGroups = [...favorites, ...nonFavorites].slice(0, maxShown);
  
  // Check if we need to show "View All" button
  const hasMoreGroups = groups.length > maxShown;
  
  if (groups.length === 0) {
    return (
      <div className="text-center py-8 bg-neutral-50 rounded-lg border border-neutral-200">
        <p className="text-neutral-600 mb-4">No groups to display.</p>
      </div>
    );
  }
  
  return (
    <div className="space-y-4">
      {displayGroups.map((group) => (
        <GroupCard 
          key={group.id} 
          group={group} 
          onClick={() => onGroupClick(group.id)}
          showFavoriteButton={true}
        />
      ))}
      
      {hasMoreGroups && (
        <Button
          variant="outline"
          className="text-center w-full border border-neutral-200 rounded-lg py-2 text-sm text-neutral-600 hover:bg-neutral-50 transition-colors"
          onClick={() => navigate("/explore")}
        >
          View All Groups
        </Button>
      )}
    </div>
  );
}
```

## File: client/src/components/header.tsx
```typescript
import { useState, useRef, useEffect } from "react";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import NotificationsDropdown from "./notifications-dropdown";
import OrganizationSelector from "./organization-selector";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Bell, User } from "lucide-react";

export default function Header() {
  const { user, logoutMutation } = useAuth();
  const [_, navigate] = useLocation();
  const [userMenuOpen, setUserMenuOpen] = useState(false);
  const userMenuRef = useRef<HTMLDivElement>(null);

  // Close menu when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (userMenuRef.current && !userMenuRef.current.contains(event.target as Node)) {
        setUserMenuOpen(false);
      }
    }

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  const handleLogout = () => {
    logoutMutation.mutate();
  };

  const getInitials = (name: string) => {
    return name
      .split(" ")
      .map((n) => n[0])
      .join("")
      .substring(0, 2)
      .toUpperCase();
  };

  return (
    <header className="bg-white shadow-sm fixed top-0 inset-x-0 z-10">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
        <div className="flex items-center">
          <div className="cursor-pointer flex items-center" onClick={() => navigate("/")}>
            <svg
              className="h-8 w-8 text-primary"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fillRule="evenodd"
                d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 14a6 6 0 100-12 6 6 0 000 12zm0-9a1 1 0 011 1v3a1 1 0 01-1 1H7a1 1 0 110-2h2V8a1 1 0 011-1z"
                clipRule="evenodd"
              />
            </svg>
            <h1 className="ml-2 text-xl font-bold font-heading text-neutral-800">
              Prayer Pipeline
            </h1>
          </div>
          
          <nav className="ml-10 hidden md:flex space-x-6">
            <a 
              className="text-neutral-600 hover:text-primary font-medium cursor-pointer"
              onClick={() => navigate("/")}
            >
              Home
            </a>
            <a 
              className="text-neutral-600 hover:text-primary font-medium cursor-pointer"
              onClick={() => navigate("/explore")}
            >
              Explore
            </a>

          </nav>
        </div>
        <div className="flex items-center space-x-4">
          {user && <OrganizationSelector />}
          <NotificationsDropdown />
          
          <div className="relative" ref={userMenuRef}>
            <DropdownMenu open={userMenuOpen} onOpenChange={setUserMenuOpen}>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" className="p-1">
                  <div className="flex items-center space-x-2">
                    <span className="h-8 w-8 rounded-full bg-primary-100 flex items-center justify-center text-primary-800 font-medium">
                      {user?.name ? getInitials(user.name) : <User className="h-5 w-5" />}
                    </span>
                    <span className="hidden md:block text-sm font-medium text-neutral-700">
                      {user?.name || "User"}
                    </span>
                  </div>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">

                <DropdownMenuItem 
                  className="cursor-pointer"
                  onClick={() => navigate("/organizations")}
                >
                  Organizations
                </DropdownMenuItem>
                <DropdownMenuItem 
                  className="cursor-pointer"
                  onClick={() => navigate("/settings")}
                >
                  Settings
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem 
                  className="cursor-pointer"
                  onClick={handleLogout}
                  disabled={logoutMutation.isPending}
                >
                  {logoutMutation.isPending ? "Signing out..." : "Sign out"}
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </header>
  );
}
```

## File: client/src/components/meeting-card.tsx
```typescript
import { Meeting } from "@shared/schema";
import { format } from "date-fns";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Video, MapPin, Calendar, Clock, User, ExternalLink, Pencil, Trash2 } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";

interface MeetingCardProps {
  meeting: Meeting;
  isLeader?: boolean;
  onEdit?: (meeting: Meeting) => void;
  onDelete?: (meeting: Meeting) => void;
  onViewNotes?: (meeting: Meeting) => void;
}

export default function MeetingCard({ 
  meeting, 
  isLeader = false,
  onEdit,
  onDelete,
  onViewNotes 
}: MeetingCardProps) {
  const { toast } = useToast();
  const { user } = useAuth();

  // Check if the meeting is in the past
  const isPastMeeting = new Date(meeting.startTime) < new Date();
  
  // Format the meeting date and time
  const meetingDate = format(new Date(meeting.startTime), "EEEE, MMMM d, yyyy");
  const meetingTime = format(new Date(meeting.startTime), "h:mm a");
  
  // Determine if the meeting is virtual (Zoom or Google Meet)
  const isVirtual = meeting.meetingType === 'zoom' || meeting.meetingType === 'google_meet';
  
  // Handle join meeting click
  const handleJoinMeeting = () => {
    if (meeting.meetingLink) {
      window.open(meeting.meetingLink, "_blank");
    } else {
      toast({
        title: "No meeting link provided",
        description: "This meeting doesn't have a virtual meeting link.",
        variant: "destructive",
      });
    }
  };
  
  // Handle copy meeting info
  const handleCopyInfo = () => {
    const meetingInfo = `
Meeting: ${meeting.title}
Date: ${meetingDate}
Time: ${meetingTime}
${isVirtual ? `URL: ${meeting.meetingLink}` : 'In-person meeting'}
Description: ${meeting.description || 'No description provided'}
    `.trim();
    
    navigator.clipboard.writeText(meetingInfo);
    
    toast({
      title: "Meeting info copied",
      description: "Meeting details have been copied to clipboard",
    });
  };
  
  // Determine if the current user is the creator of this meeting
  const isCreator = user?.id === meeting.createdBy;

  return (
    <Card className="overflow-hidden transition-all hover:shadow-md">
      <CardHeader className="pb-2">
        <div className="flex justify-between items-start">
          <div>
            <CardTitle className="text-xl mb-1">{meeting.title}</CardTitle>
            <CardDescription className="text-sm flex items-center gap-1">
              <Calendar className="h-3.5 w-3.5" />
              {meetingDate}
            </CardDescription>
            <CardDescription className="text-sm flex items-center gap-1">
              <Clock className="h-3.5 w-3.5" />
              {meetingTime}
            </CardDescription>
          </div>
          
          {(isLeader || isCreator) && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-4 w-4">
                    <circle cx="12" cy="12" r="1" />
                    <circle cx="19" cy="12" r="1" />
                    <circle cx="5" cy="12" r="1" />
                  </svg>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-[160px]">
                {!isPastMeeting && (
                  <DropdownMenuItem onClick={() => onEdit?.(meeting)}>
                    <Pencil className="mr-2 h-4 w-4" />
                    <span>Edit Meeting</span>
                  </DropdownMenuItem>
                )}
                <DropdownMenuItem onClick={() => onDelete?.(meeting)}>
                  <Trash2 className="mr-2 h-4 w-4" />
                  <span>Delete Meeting</span>
                </DropdownMenuItem>
                {isPastMeeting && (
                  <DropdownMenuItem onClick={() => onViewNotes?.(meeting)}>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-4 w-4">
                      <path d="M14 3v4a1 1 0 0 0 1 1h4" />
                      <path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z" />
                      <line x1="9" y1="9" x2="10" y2="9" />
                      <line x1="9" y1="13" x2="15" y2="13" />
                      <line x1="9" y1="17" x2="15" y2="17" />
                    </svg>
                    <span>View Notes</span>
                  </DropdownMenuItem>
                )}
                <DropdownMenuItem onClick={handleCopyInfo}>
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-4 w-4">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                  </svg>
                  <span>Copy Info</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          )}
        </div>
      </CardHeader>
      <CardContent className="pb-2">
        <div className="flex items-center gap-2 text-sm text-muted-foreground mb-2">
          {isVirtual ? (
            <Badge className="bg-blue-100 text-blue-800 hover:bg-blue-200">
              <Video className="h-3 w-3 mr-1" />
              Virtual
            </Badge>
          ) : (
            <Badge className="bg-amber-100 text-amber-800 hover:bg-amber-200">
              <MapPin className="h-3 w-3 mr-1" />
              In-Person
            </Badge>
          )}
          
          <Badge className="bg-neutral-100 text-neutral-800 hover:bg-neutral-200">
            <User className="h-3 w-3 mr-1" />
            Host: {user?.id === meeting.createdBy ? "You" : "User " + meeting.createdBy}
          </Badge>
          
          {isPastMeeting && (
            <Badge variant="outline" className="border-neutral-200 text-neutral-500">
              Completed
            </Badge>
          )}
        </div>
        
        {meeting.description && (
          <p className="text-sm text-neutral-600 line-clamp-2">
            {meeting.description}
          </p>
        )}
        
        {isVirtual && (
          <div className="mt-2 text-sm text-primary truncate">
            <a href={meeting.meetingLink} target="_blank" rel="noopener noreferrer" className="flex items-center hover:underline">
              <ExternalLink className="h-3.5 w-3.5 mr-1" />
              {meeting.meetingLink}
            </a>
          </div>
        )}
        
        {!isVirtual && (
          <div className="mt-2 text-sm text-neutral-600 flex items-start gap-1">
            <MapPin className="h-3.5 w-3.5 mt-0.5" />
            <span>In-person meeting</span>
          </div>
        )}
      </CardContent>
      <CardFooter className="pt-2">
        <div className="w-full flex justify-end gap-2">
          {!isPastMeeting && isVirtual && (
            <Button size="sm" onClick={handleJoinMeeting}>
              <Video className="h-4 w-4 mr-1" />
              Join Meeting
            </Button>
          )}
          
          {isPastMeeting && (
            <Button size="sm" variant="outline" onClick={() => onViewNotes?.(meeting)}>
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-4 w-4 mr-1">
                <path d="M14 3v4a1 1 0 0 0 1 1h4" />
                <path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z" />
                <line x1="9" y1="9" x2="10" y2="9" />
                <line x1="9" y1="13" x2="15" y2="13" />
                <line x1="9" y1="17" x2="15" y2="17" />
              </svg>
              View Notes
            </Button>
          )}
        </div>
      </CardFooter>
    </Card>
  );
}
```

## File: client/src/components/meetings-tab.tsx
```typescript
import { useState } from "react";
import { Meeting, Group } from "@shared/schema";
import { useMeetings } from "@/hooks/use-meetings";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { PlusIcon, CalendarDays, ChevronRight, ChevronDown, ChevronUp } from "lucide-react";
import MeetingCard from "@/components/meeting-card";
import CreateMeetingModal from "@/components/create-meeting-modal";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useLocation } from "wouter";

interface MeetingsTabProps {
  group: Group;
  isLeader: boolean;
}

export default function MeetingsTab({ group, isLeader }: MeetingsTabProps) {
  const [_, navigate] = useLocation();
  const [createModalOpen, setCreateModalOpen] = useState(false);
  const [meetingToDelete, setMeetingToDelete] = useState<Meeting | null>(null);
  const [meetingsTab, setMeetingsTab] = useState<"upcoming" | "past">("upcoming");
  const [expandedUpcoming, setExpandedUpcoming] = useState(false);
  const [expandedPast, setExpandedPast] = useState(false);
  
  const { 
    meetings,
    isLoadingMeetings,
    deleteMeeting,
    isDeletingMeeting
  } = useMeetings(group.id);
  
  // Sort and filter meetings
  const now = new Date();
  
  // Get all upcoming meetings first for counting
  const allUpcomingMeetings = meetings
    .filter(meeting => new Date(meeting.startTime) >= now)
    .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());
  
  // Then slice to get only the first 3
  const upcomingMeetings = allUpcomingMeetings.slice(0, 3);
  const hasMoreUpcoming = allUpcomingMeetings.length > 3;
  
  // Same for past meetings
  const allPastMeetings = meetings
    .filter(meeting => new Date(meeting.startTime) < now)
    .sort((a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime());
  
  const pastMeetings = allPastMeetings.slice(0, 3);
  const hasMorePast = allPastMeetings.length > 3;
  
  // Handle meeting edit - redirect to meeting details page
  const handleEditMeeting = (meeting: Meeting) => {
    navigate(`/meetings/${meeting.id}`);
  };
  
  // Handle meeting delete
  const handleDeleteMeeting = (meeting: Meeting) => {
    setMeetingToDelete(meeting);
  };
  
  // Confirm meeting deletion
  const confirmDeleteMeeting = () => {
    if (meetingToDelete) {
      deleteMeeting(meetingToDelete.id);
      setMeetingToDelete(null);
    }
  };
  
  // Handle view meeting notes
  const handleViewNotes = (meeting: Meeting) => {
    navigate(`/meetings/${meeting.id}/notes`);
  };
  
  // Handle toggling the expanded view for meetings
  const handleToggleExpand = (type: "upcoming" | "past") => {
    if (type === "upcoming") {
      setExpandedUpcoming(!expandedUpcoming);
    } else {
      setExpandedPast(!expandedPast);
    }
  };
  
  return (
    <div>
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-medium font-heading text-neutral-800">
          Meetings
        </h3>
        {isLeader && (
          <Button
            onClick={() => setCreateModalOpen(true)}
            className="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition flex items-center text-sm"
          >
            <PlusIcon className="h-4 w-4 mr-1" />
            Schedule Meeting
          </Button>
        )}
      </div>
      
      {/* Meetings Tabs */}
      <Tabs
        value={meetingsTab}
        onValueChange={(value) => setMeetingsTab(value as "upcoming" | "past")}
        className="w-full mb-6"
      >
        <TabsList className="mb-4 border-b border-neutral-200 w-full justify-start rounded-none bg-transparent p-0">
          <TabsTrigger
            value="upcoming"
            className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
          >
            Upcoming ({allUpcomingMeetings.length})
          </TabsTrigger>
          <TabsTrigger
            value="past"
            className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
          >
            Past ({allPastMeetings.length})
          </TabsTrigger>
        </TabsList>
        
        <TabsContent value="upcoming" className="mt-0">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {isLoadingMeetings ? (
              <>
                <Skeleton className="h-40 w-full" />
                <Skeleton className="h-40 w-full" />
              </>
            ) : upcomingMeetings.length > 0 ? (
              <>
                {upcomingMeetings.map((meeting) => (
                  <MeetingCard
                    key={meeting.id}
                    meeting={meeting}
                    isLeader={isLeader}
                    onEdit={handleEditMeeting}
                    onDelete={handleDeleteMeeting}
                    onViewNotes={handleViewNotes}
                  />
                ))}
                {hasMoreUpcoming && (
                  <div className="col-span-full mt-2 text-center">
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className="text-primary hover:text-primary hover:bg-primary/5" 
                      onClick={() => handleToggleExpand("upcoming")}
                    >
                      {expandedUpcoming ? (
                        <>Collapse <ChevronUp className="h-4 w-4 ml-1" /></>
                      ) : (
                        <>View all {allUpcomingMeetings.length} upcoming meetings <ChevronDown className="h-4 w-4 ml-1" /></>
                      )}
                    </Button>
                  </div>
                )}
                
                {/* Expanded upcoming meetings section */}
                {expandedUpcoming && hasMoreUpcoming && (
                  <div className="col-span-full mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                    {allUpcomingMeetings.slice(3).map((meeting) => (
                      <MeetingCard
                        key={meeting.id}
                        meeting={meeting}
                        isLeader={isLeader}
                        onEdit={handleEditMeeting}
                        onDelete={handleDeleteMeeting}
                        onViewNotes={handleViewNotes}
                      />
                    ))}
                  </div>
                )}
              </>
            ) : (
              <div className="col-span-full text-center py-12 bg-neutral-50 rounded-lg border border-neutral-200">
                <CalendarDays className="h-10 w-10 mx-auto text-neutral-400 mb-2" />
                <p className="text-neutral-600 mb-4">
                  No upcoming meetings scheduled.
                </p>
                {isLeader && (
                  <Button onClick={() => setCreateModalOpen(true)}>
                    Schedule First Meeting
                  </Button>
                )}
              </div>
            )}
          </div>
        </TabsContent>
        
        <TabsContent value="past" className="mt-0">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {isLoadingMeetings ? (
              <>
                <Skeleton className="h-40 w-full" />
                <Skeleton className="h-40 w-full" />
              </>
            ) : pastMeetings.length > 0 ? (
              <>
                {pastMeetings.map((meeting) => (
                  <MeetingCard
                    key={meeting.id}
                    meeting={meeting}
                    isLeader={isLeader}
                    onDelete={handleDeleteMeeting}
                    onViewNotes={handleViewNotes}
                  />
                ))}
                {hasMorePast && (
                  <div className="col-span-full mt-2 text-center">
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className="text-primary hover:text-primary hover:bg-primary/5" 
                      onClick={() => handleToggleExpand("past")}
                    >
                      {expandedPast ? (
                        <>Collapse <ChevronUp className="h-4 w-4 ml-1" /></>
                      ) : (
                        <>View all {allPastMeetings.length} past meetings <ChevronDown className="h-4 w-4 ml-1" /></>
                      )}
                    </Button>
                  </div>
                )}
                
                {/* Expanded past meetings section */}
                {expandedPast && hasMorePast && (
                  <div className="col-span-full mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                    {allPastMeetings.slice(3).map((meeting) => (
                      <MeetingCard
                        key={meeting.id}
                        meeting={meeting}
                        isLeader={isLeader}
                        onDelete={handleDeleteMeeting}
                        onViewNotes={handleViewNotes}
                      />
                    ))}
                  </div>
                )}
              </>
            ) : (
              <div className="col-span-full text-center py-12 bg-neutral-50 rounded-lg border border-neutral-200">
                <CalendarDays className="h-10 w-10 mx-auto text-neutral-400 mb-2" />
                <p className="text-neutral-600">
                  No past meetings found.
                </p>
              </div>
            )}
          </div>
        </TabsContent>
      </Tabs>
      
      {/* Create Meeting Modal */}
      <CreateMeetingModal
        groupId={group.id}
        open={createModalOpen}
        onOpenChange={setCreateModalOpen}
      />
      
      {/* Delete Confirmation Dialog */}
      <AlertDialog
        open={!!meetingToDelete}
        onOpenChange={(open) => !open && setMeetingToDelete(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm Deletion</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this meeting? This action cannot be undone.
              {meetingToDelete && new Date(meetingToDelete.startTime) > new Date() && (
                <span className="block mt-2 text-red-500 font-medium">
                  Note: This will cancel the meeting for all participants.
                </span>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeletingMeeting}>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDeleteMeeting}
              disabled={isDeletingMeeting}
              className="bg-red-500 hover:bg-red-600"
            >
              {isDeletingMeeting ? "Deleting..." : "Delete Meeting"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>


    </div>
  );
}
```

## File: client/src/components/mobile-nav.tsx
```typescript
import { useLocation } from "wouter";
import { Home, User, Search } from "lucide-react";

type MobileNavProps = {
  active: "home" | "explore" | "profile";
};

export default function MobileNav({ active }: MobileNavProps) {
  const [_, navigate] = useLocation();

  return (
    <nav className="fixed bottom-0 inset-x-0 bg-white border-t border-neutral-200 py-2 md:hidden">
      <div className="grid grid-cols-3 gap-1">
        <button
          onClick={() => navigate("/")}
          className={`flex flex-col items-center justify-center py-1 ${
            active === "home" ? "text-primary" : "text-neutral-500 hover:text-primary"
          }`}
        >
          <Home className="h-6 w-6" />
          <span className="text-xs mt-1">Home</span>
        </button>
        <button
          onClick={() => {
            navigate("/explore");
          }}
          className={`flex flex-col items-center justify-center py-1 ${
            active === "explore" ? "text-primary" : "text-neutral-500 hover:text-primary"
          }`}
        >
          <Search className="h-6 w-6" />
          <span className="text-xs mt-1">Explore</span>
        </button>
        <button
          onClick={() => {
            navigate("/profile");
          }}
          className={`flex flex-col items-center justify-center py-1 ${
            active === "profile" ? "text-primary" : "text-neutral-500 hover:text-primary"
          }`}
        >
          <User className="h-6 w-6" />
          <span className="text-xs mt-1">Profile</span>
        </button>
      </div>
    </nav>
  );
}
```

## File: client/src/components/notifications-dropdown.tsx
```typescript
import { useState, useRef, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useLocation } from "wouter";
import { useOrganizations } from "@/hooks/use-organizations";
import { Button } from "@/components/ui/button";
import { Bell } from "lucide-react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { Notification } from "@shared/schema";

export default function NotificationsDropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { toast } = useToast();
  const [_, navigate] = useLocation();
  const { currentOrganization } = useOrganizations();

  // Close dropdown when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  // Fetch notifications
  const { data: notifications, isLoading } = useQuery<Notification[]>({
    queryKey: ["/api/notifications", currentOrganization?.id],
    queryFn: () => {
      const url = currentOrganization?.id
        ? `/api/notifications?organizationId=${currentOrganization.id}`
        : "/api/notifications";
      return fetch(url).then(res => {
        if (!res.ok) throw new Error("Failed to fetch notifications");
        return res.json();
      });
    },
    enabled: !!currentOrganization?.id, // Only fetch when we have an organization
  });

  // Mark all notifications as read
  const markAllReadMutation = useMutation({
    mutationFn: async () => {
      const url = currentOrganization?.id
        ? `/api/notifications/mark-all-read?organizationId=${currentOrganization.id}`
        : "/api/notifications/mark-all-read";
      await apiRequest("PATCH", url, {});
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notifications", currentOrganization?.id] });
      toast({
        title: "Notifications marked as read",
        description: "All notifications have been marked as read.",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Mark single notification as read
  const markReadMutation = useMutation({
    mutationFn: async (id: number) => {
      const url = currentOrganization?.id
        ? `/api/notifications/${id}/read?organizationId=${currentOrganization.id}`
        : `/api/notifications/${id}/read`;
      await apiRequest("PATCH", url, {});
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/notifications", currentOrganization?.id] });
    },
  });

  // Handle notification click
  const handleNotificationClick = (notification: Notification) => {
    // Mark as read if it's not already
    if (!notification.read) {
      markReadMutation.mutate(notification.id);
    }

    // Navigate based on notification type
    if (notification.type === "new_request" || notification.type === "status_update") {
      // Navigate to the prayer request
      navigate(`/requests/${notification.referenceId}`);
    } else if (notification.type === "new_comment") {
      // Navigate to the prayer request with the comment
      navigate(`/requests/${notification.referenceId}`);
    } else if (notification.type === "added_to_group") {
      // Navigate to the group
      navigate(`/groups/${notification.referenceId}`);
    } else if (notification.type === "added_to_organization" || notification.type === "org_role_changed") {
      // Navigate to organization details
      navigate(`/organizations/${notification.referenceId}`);
    } else if (notification.type === "invited_to_organization") {
      // Navigate to organizations page
      navigate('/organizations');
    } else if (notification.type === "new_meeting" || notification.type === "meeting_updated" ||
               notification.type === "meeting_cancelled" || notification.type === "meeting_reminder") {
      // Navigate to meeting details
      navigate(`/meetings/${notification.referenceId}`);
    }

    setIsOpen(false);
  };

  // Format date to relative time
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / (1000 * 60));
    
    if (diffMins < 60) {
      return diffMins === 0 ? "Just now" : `${diffMins} min ago`;
    } else if (diffMins < 24 * 60) {
      const hours = Math.floor(diffMins / 60);
      return `${hours} hour${hours > 1 ? "s" : ""} ago`;
    } else {
      const days = Math.floor(diffMins / (60 * 24));
      if (days < 7) {
        return `${days} day${days > 1 ? "s" : ""} ago`;
      } else {
        return date.toLocaleDateString();
      }
    }
  };

  // Count unread notifications
  const unreadCount = notifications?.filter(
    (notification: Notification) => !notification.read
  ).length || 0;

  return (
    <div className="relative" ref={dropdownRef}>
      <Button
        onClick={() => setIsOpen(!isOpen)}
        variant="ghost"
        size="icon"
        className="relative p-1 rounded-full text-neutral-600 hover:text-primary focus:outline-none"
      >
        <Bell className="h-6 w-6" />
        {unreadCount > 0 && (
          <span className="absolute top-0 right-0 block h-4 w-4 rounded-full bg-amber-500 text-white text-xs flex items-center justify-center font-medium">
            {unreadCount > 9 ? "9+" : unreadCount}
          </span>
        )}
      </Button>

      {isOpen && (
        <div className="absolute right-0 mt-2 w-80 bg-white rounded-lg shadow-lg py-2 z-20">
          <div className="px-4 py-2 border-b border-neutral-100 flex justify-between items-center">
            <h3 className="text-sm font-medium text-neutral-800">Notifications</h3>
            {unreadCount > 0 && (
              <Button
                variant="ghost"
                size="sm"
                className="text-sm text-primary hover:text-primary/90"
                onClick={() => markAllReadMutation.mutate()}
                disabled={markAllReadMutation.isPending}
              >
                {markAllReadMutation.isPending ? "Marking..." : "Mark all as read"}
              </Button>
            )}
          </div>
          <ScrollArea className="max-h-96">
            {isLoading ? (
              <div className="p-4 space-y-4">
                <Skeleton className="h-12 w-full" />
                <Skeleton className="h-12 w-full" />
                <Skeleton className="h-12 w-full" />
              </div>
            ) : notifications && notifications.length > 0 ? (
              notifications.map((notification: Notification) => (
                <div
                  key={notification.id}
                  className={`px-4 py-3 hover:bg-neutral-50 cursor-pointer border-b border-neutral-100 last:border-b-0 ${
                    !notification.read ? "bg-primary-50" : ""
                  }`}
                  onClick={() => handleNotificationClick(notification)}
                >
                  <p className={`text-sm ${!notification.read ? "font-medium text-neutral-800" : "text-neutral-700"}`}>
                    {notification.message}
                  </p>
                  <p className="text-xs text-neutral-500 mt-1">
                    {formatDate(notification.createdAt)}
                  </p>
                </div>
              ))
            ) : (
              <div className="px-4 py-6 text-center">
                <p className="text-sm text-neutral-600">No notifications</p>
              </div>
            )}
          </ScrollArea>
        </div>
      )}
    </div>
  );
}
```

## File: client/src/components/organization-selector.tsx
```typescript
import { useState } from "react";
import { useOrganizations } from "@/hooks/use-organizations";
import { useLocation } from "wouter";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { 
  Building, 
  Plus,
  Loader2,
  LogOut
} from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { insertOrganizationSchema } from "@shared/schema";
import { z } from "zod";

const createOrgSchema = insertOrganizationSchema.omit({ createdBy: true });
type CreateOrgData = z.infer<typeof createOrgSchema>;

export default function OrganizationSelector() {
  const [_, navigate] = useLocation();
  const [dialogOpen, setDialogOpen] = useState(false);
  const [switchOrgDialogOpen, setSwitchOrgDialogOpen] = useState(false);
  const { 
    organizations, 
    currentOrganization, 
    setCurrentOrganizationId, 
    isLoading,
    createOrganizationMutation,
    leaveOrganizationMutation
  } = useOrganizations();

  const form = useForm<CreateOrgData>({
    resolver: zodResolver(createOrgSchema),
    defaultValues: {
      name: "",
      description: "",
    },
  });

  const handleCreateOrganization = async (data: CreateOrgData) => {
    await createOrganizationMutation.mutateAsync(data);
    form.reset();
    setDialogOpen(false);
  };

  const handleOrgChange = (orgId: string) => {
    if (orgId === "manage") {
      navigate("/organizations");
    } else if (orgId === "create") {
      setDialogOpen(true);
    } else if (orgId === "leave" && currentOrganization) {
      // Open confirmation dialog for leaving the current organization
      setSwitchOrgDialogOpen(true);
    } else {
      setCurrentOrganizationId(parseInt(orgId));
    }
  };

  const handleLeaveOrganization = async () => {
    if (!currentOrganization) return;
    
    try {
      await leaveOrganizationMutation.mutateAsync(currentOrganization.id);
      setSwitchOrgDialogOpen(false);
    } catch (error) {
      console.error("Failed to leave organization:", error);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center gap-2 text-muted-foreground">
        <Loader2 className="h-4 w-4 animate-spin" />
        <span>Loading...</span>
      </div>
    );
  }

  return (
    <>
      <div className="flex items-center gap-2">
        <Building className="h-5 w-5 text-primary" />
        <Select
          value={currentOrganization ? String(currentOrganization.id) : ""}
          onValueChange={handleOrgChange}
        >
          <SelectTrigger className="w-[180px] md:w-[240px]">
            <SelectValue placeholder="Select organization" />
          </SelectTrigger>
          <SelectContent>
            <SelectGroup>
              <SelectLabel>Your organizations</SelectLabel>
              {organizations.length === 0 && (
                <div className="px-2 py-1.5 text-sm text-muted-foreground">
                  No organizations yet
                </div>
              )}
              {organizations.map((org) => (
                <SelectItem key={org.id} value={String(org.id)}>
                  {org.name}
                </SelectItem>
              ))}
            </SelectGroup>
            <SelectGroup>
              <SelectLabel>Options</SelectLabel>
              <SelectItem value="manage">
                <div className="flex items-center gap-2">
                  <Building className="h-4 w-4" />
                  Manage organizations
                </div>
              </SelectItem>
              <SelectItem value="create">
                <div className="flex items-center gap-2">
                  <Plus className="h-4 w-4" />
                  Create organization
                </div>
              </SelectItem>
              {currentOrganization && organizations.length > 1 && (
                <SelectItem value="leave">
                  <div className="flex items-center gap-2 text-red-500">
                    <Loader2 className={`h-4 w-4 ${leaveOrganizationMutation.isPending ? 'animate-spin' : 'hidden'}`} />
                    Leave {currentOrganization.name}
                  </div>
                </SelectItem>
              )}
            </SelectGroup>
          </SelectContent>
        </Select>
      </div>

      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Create New Organization</DialogTitle>
            <DialogDescription>
              Create a new organization to manage prayer groups and members.
            </DialogDescription>
          </DialogHeader>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(handleCreateOrganization)} className="space-y-4">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Name</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter organization name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Description (optional)</FormLabel>
                    <FormControl>
                      <Textarea
                        placeholder="Describe your organization"
                        className="resize-none h-20"
                        {...field}
                        value={field.value || ""}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <DialogFooter>
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setDialogOpen(false)}
                  disabled={createOrganizationMutation.isPending}
                >
                  Cancel
                </Button>
                <Button
                  type="submit"
                  disabled={createOrganizationMutation.isPending}
                >
                  {createOrganizationMutation.isPending ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Creating...
                    </>
                  ) : (
                    "Create Organization"
                  )}
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>

      {/* Leave Organization Dialog */}
      <Dialog open={switchOrgDialogOpen} onOpenChange={setSwitchOrgDialogOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Leave Organization</DialogTitle>
            <DialogDescription>
              {currentOrganization?.name && `You are about to leave ${currentOrganization.name}. You will need to select another organization to continue.`}
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            <h3 className="text-sm font-medium mb-2">Select an organization to join:</h3>
            
            <div className="space-y-2 max-h-48 overflow-y-auto">
              {organizations
                .filter(org => org.id !== currentOrganization?.id)
                .map(org => (
                  <button
                    key={org.id}
                    className="flex items-center w-full p-2 rounded-md hover:bg-gray-100 transition-colors"
                    onClick={() => {
                      if (currentOrganization) {
                        leaveOrganizationMutation.mutate(currentOrganization.id);
                        setCurrentOrganizationId(org.id);
                        setSwitchOrgDialogOpen(false);
                      }
                    }}
                  >
                    <Building className="h-5 w-5 mr-2 text-primary" />
                    <span>{org.name}</span>
                  </button>
                ))
              }
            </div>
          </div>

          <DialogFooter>
            <Button
              type="button"
              variant="outline"
              onClick={() => setSwitchOrgDialogOpen(false)}
              disabled={leaveOrganizationMutation.isPending}
            >
              Cancel
            </Button>
            <Button
              type="button"
              variant="destructive"
              onClick={handleLeaveOrganization}
              disabled={leaveOrganizationMutation.isPending}
            >
              {leaveOrganizationMutation.isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Leaving...
                </>
              ) : (
                <>
                  <LogOut className="mr-2 h-4 w-4" />
                  Leave Organization
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}
```

## File: client/src/components/prayer-card.tsx
```typescript
import { MessageSquare } from "lucide-react";
import { Button } from "@/components/ui/button";

type PrayerCardProps = {
  request: any;
  onClick?: () => void;
};

export default function PrayerCard({ request, onClick }: PrayerCardProps) {
  const getStatusBadgeClass = (status: string) => {
    switch (status) {
      case "waiting":
        return "bg-amber-50 text-amber-500";
      case "answered":
        return "bg-green-50 text-green-600";
      case "declined":
        return "bg-neutral-50 text-neutral-500";
      default:
        return "bg-neutral-50 text-neutral-500";
    }
  };

  const getStatusText = (status: string) => {
    switch (status) {
      case "waiting":
        return "Still Waiting";
      case "answered":
        return "Answered!";
      case "declined":
        return "God Said No";
      default:
        return "Unknown";
    }
  };

  // Format date to relative time (e.g., 2 days ago)
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
      return "Today";
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (diffDays < 30) {
      return `${diffDays} days ago`;
    } else {
      return date.toLocaleDateString();
    }
  };

  return (
    <div 
      className="prayer-card bg-white rounded-lg shadow p-4 hover:shadow-md transition cursor-pointer transform hover:-translate-y-0.5"
      onClick={onClick}
    >
      <div className="flex justify-between items-start">
        <div>
          <h4 className="font-medium text-neutral-800">{request.title}</h4>
          <p className="text-xs text-neutral-500 mt-1">
            {request.group ? `In ${request.group.name} • ` : ''}
            {request.isAnonymous 
              ? "Posted anonymously" 
              : `Posted by ${request.author?.name || "Unknown"}`} • {formatDate(request.createdAt)}
          </p>
        </div>
        <span className={`inline-flex items-center px-3 py-1 rounded-full text-xs font-medium ${getStatusBadgeClass(request.status)}`}>
          {getStatusText(request.status)}
        </span>
      </div>
      <p className="text-sm text-neutral-600 mt-3 line-clamp-2">
        {request.description}
      </p>
      <div className="mt-3 flex items-center justify-between">
        <div className="flex items-center text-neutral-500 text-xs">
          <MessageSquare className="h-4 w-4 mr-1" />
          <span>{request.commentCount || 0} comments</span>
        </div>
        <Button 
          variant="ghost"
          size="sm"
          className="text-primary text-sm hover:text-primary/90"
          onClick={(e) => {
            e.stopPropagation();
            onClick && onClick();
          }}
        >
          View
        </Button>
      </div>
    </div>
  );
}
```

## File: client/src/components/prayer-reminder-dialog.tsx
```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Checkbox } from '@/components/ui/checkbox';
import { Textarea } from '@/components/ui/textarea';
import { usePrayerReminders, PrayerReminderWithDays, CreatePrayerReminderData } from '@/hooks/use-prayer-reminders';
import { CalendarIcon, Clock, Plus } from 'lucide-react';
import { format } from 'date-fns';
import { cn } from '@/lib/utils';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar } from '@/components/ui/calendar';
import { PrayerReminder } from '@shared/schema';

interface PrayerReminderDialogProps {
  mode: 'create' | 'edit';
  existingReminder?: PrayerReminderWithDays;
  trigger?: React.ReactNode;
}

const daysOfWeek = [
  { id: 'sunday', label: 'Sun' },
  { id: 'monday', label: 'Mon' },
  { id: 'tuesday', label: 'Tue' },
  { id: 'wednesday', label: 'Wed' },
  { id: 'thursday', label: 'Thu' },
  { id: 'friday', label: 'Fri' },
  { id: 'saturday', label: 'Sat' },
] as const;

export function PrayerReminderDialog({
  mode = 'create',
  existingReminder,
  trigger,
}: PrayerReminderDialogProps) {
  const [open, setOpen] = useState(false);
  const { createReminder, updateReminder, isCreating, isUpdating } = usePrayerReminders();
  
  // Form state
  const [title, setTitle] = useState(existingReminder?.title || 'Prayer Time');
  const [description, setDescription] = useState(existingReminder?.description || '');
  const [reminderTime, setReminderTime] = useState(existingReminder?.reminderTime?.toString().substring(0, 5) || '08:00');
  const [isRecurring, setIsRecurring] = useState(existingReminder?.isRecurring || false);
  const [recurringDays, setRecurringDays] = useState<string[]>(
    existingReminder?.recurringDays || ['monday', 'wednesday', 'friday']
  );
  const [activeUntil, setActiveUntil] = useState<Date | undefined>(
    existingReminder?.activeUntil ? new Date(existingReminder.activeUntil) : undefined
  );
  const [isActive, setIsActive] = useState(existingReminder?.isActive ?? true);

  const resetForm = () => {
    if (mode === 'create') {
      setTitle('Prayer Time');
      setDescription('');
      setReminderTime('08:00');
      setIsRecurring(false);
      setRecurringDays(['monday', 'wednesday', 'friday']);
      setActiveUntil(undefined);
      setIsActive(true);
    }
  };

  const handleToggleDay = (day: string) => {
    setRecurringDays(prev => {
      if (prev.includes(day)) {
        return prev.filter(d => d !== day);
      } else {
        return [...prev, day];
      }
    });
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Ensure we have at least one day selected if recurring
    if (isRecurring && recurringDays.length === 0) {
      alert('Please select at least one day for recurring reminders');
      return;
    }

    const reminderData: CreatePrayerReminderData = {
      title,
      description,
      reminderTime,
      isRecurring,
      recurringDays: isRecurring ? recurringDays : undefined,
      activeUntil: activeUntil || undefined,
      isActive,
    };

    if (mode === 'create') {
      createReminder(reminderData, {
        onSuccess: () => {
          setOpen(false);
          resetForm();
        }
      });
    } else if (existingReminder) {
      updateReminder({
        id: existingReminder.id,
        data: reminderData
      }, {
        onSuccess: () => {
          setOpen(false);
        }
      });
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {trigger || (
          <Button
            size="sm"
            className="gap-1"
          >
            <Plus className="h-4 w-4" />
            {mode === 'create' ? 'Add Reminder' : 'Edit'}
          </Button>
        )}
      </DialogTrigger>
      
      <DialogContent className="sm:max-w-[450px]">
        <DialogHeader>
          <DialogTitle>
            {mode === 'create' ? 'Create Prayer Reminder' : 'Edit Prayer Reminder'}
          </DialogTitle>
          <DialogDescription>
            Set up reminders to help establish a consistent prayer routine.
          </DialogDescription>
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4 py-2">
          <div className="space-y-2">
            <Label htmlFor="title">Title</Label>
            <Input
              id="title"
              value={title}
              onChange={e => setTitle(e.target.value)}
              placeholder="Prayer Time"
              required
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="description">Description (Optional)</Label>
            <Textarea
              id="description"
              value={description || ''}
              onChange={e => setDescription(e.target.value)}
              placeholder="Time to pray for..."
              className="resize-none"
            />
          </div>
          
          <div className="space-y-2">
            <Label htmlFor="reminderTime">Reminder Time</Label>
            <div className="flex items-center">
              <Input
                id="reminderTime"
                type="time"
                value={reminderTime}
                onChange={e => setReminderTime(e.target.value)}
                required
                className="flex-1"
              />
              <Clock className="ml-2 h-4 w-4 text-muted-foreground" />
            </div>
          </div>
          
          <div className="flex items-center justify-between space-x-2">
            <Label htmlFor="isRecurring">Recurring Reminder</Label>
            <Switch
              id="isRecurring"
              checked={isRecurring}
              onCheckedChange={setIsRecurring}
            />
          </div>
          
          {isRecurring && (
            <div className="space-y-2 border rounded-md p-3 bg-muted/30">
              <Label>Repeat on days</Label>
              <div className="flex flex-wrap gap-2 mt-1">
                {daysOfWeek.map((day) => (
                  <div key={day.id} className="flex items-center space-x-1">
                    <Checkbox
                      id={`day-${day.id}`}
                      checked={recurringDays.includes(day.id)}
                      onCheckedChange={() => handleToggleDay(day.id)}
                    />
                    <Label htmlFor={`day-${day.id}`} className="text-sm cursor-pointer">{day.label}</Label>
                  </div>
                ))}
              </div>
              
              <div className="mt-4 space-y-2">
                <Label>Active until (optional)</Label>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      variant="outline"
                      className={cn(
                        "w-full justify-start text-left font-normal",
                        !activeUntil && "text-muted-foreground"
                      )}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {activeUntil ? format(activeUntil, "PPP") : "No end date"}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0">
                    <Calendar
                      mode="single"
                      selected={activeUntil}
                      onSelect={setActiveUntil}
                      initialFocus
                      disabled={(date) => date < new Date()}
                    />
                    {activeUntil && (
                      <div className="p-2 border-t border-border">
                        <Button 
                          variant="ghost" 
                          size="sm" 
                          className="w-full"
                          onClick={() => setActiveUntil(undefined)}
                        >
                          Clear date
                        </Button>
                      </div>
                    )}
                  </PopoverContent>
                </Popover>
              </div>
            </div>
          )}
          
          <div className="flex items-center justify-between space-x-2">
            <Label htmlFor="isActive">Active</Label>
            <Switch
              id="isActive"
              checked={isActive}
              onCheckedChange={setIsActive}
            />
          </div>

          <DialogFooter className="pt-4">
            <Button 
              variant="outline" 
              type="button" 
              onClick={() => setOpen(false)}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isCreating || isUpdating}
            >
              {isCreating || isUpdating ? 'Saving...' : mode === 'create' ? 'Create' : 'Save'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}
```

## File: client/src/components/prayer-reminders-card.tsx
```typescript
import { useState } from 'react';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { usePrayerReminders, PrayerReminderWithDays } from '@/hooks/use-prayer-reminders';
import { PrayerReminderDialog } from './prayer-reminder-dialog';
import { Clock, Edit2, Plus, ToggleLeft, ToggleRight, Trash2 } from 'lucide-react';
import { format } from 'date-fns';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';

export function PrayerRemindersCard() {
  const { reminders, isLoading, updateReminder, deleteReminder, isUpdating, isDeleting } = usePrayerReminders();
  const [reminderToDelete, setReminderToDelete] = useState<PrayerReminderWithDays | null>(null);

  const handleStatusToggle = (reminder: PrayerReminderWithDays) => {
    updateReminder({
      id: reminder.id,
      data: { isActive: !reminder.isActive }
    });
  };

  const handleDeleteReminder = () => {
    if (reminderToDelete) {
      deleteReminder(reminderToDelete.id, {
        onSuccess: () => setReminderToDelete(null)
      });
    }
  };

  const formatReminderSchedule = (reminder: PrayerReminderWithDays) => {
    if (!reminder.isRecurring) {
      return 'One-time';
    }

    // Convert day names to short form (e.g., "Mon, Wed, Fri")
    const shortDayMap: Record<string, string> = {
      sunday: 'Sun',
      monday: 'Mon',
      tuesday: 'Tue',
      wednesday: 'Wed',
      thursday: 'Thu',
      friday: 'Fri',
      saturday: 'Sat',
    };

    const formattedDays = reminder.recurringDays
      .map(day => shortDayMap[day] || day)
      .join(', ');

    return formattedDays;
  };

  return (
    <Card>
      <CardHeader className="pb-3">
        <div className="flex justify-between items-center">
          <CardTitle>Prayer Reminders</CardTitle>
          <PrayerReminderDialog mode="create" />
        </div>
        <CardDescription>
          Set up reminders to maintain a consistent prayer routine
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {isLoading ? (
          <div className="text-center py-6 text-muted-foreground">Loading reminders...</div>
        ) : reminders.length === 0 ? (
          <div className="text-center py-6 space-y-4">
            <p className="text-muted-foreground">No prayer reminders set up yet</p>
            <PrayerReminderDialog
              mode="create"
              trigger={
                <Button variant="outline" className="gap-2">
                  <Plus className="h-4 w-4" />
                  Add your first reminder
                </Button>
              }
            />
          </div>
        ) : (
          reminders.map((reminder) => (
            <div
              key={reminder.id}
              className={`flex flex-col border rounded-lg p-3 
                ${!reminder.isActive ? 'bg-muted/30 border-dashed' : ''}`}
            >
              <div className="flex justify-between items-start mb-2">
                <div className="flex flex-col">
                  <div className="font-medium flex items-center gap-1">
                    {reminder.title}
                    {!reminder.isActive && (
                      <Badge variant="outline" className="ml-2">Disabled</Badge>
                    )}
                  </div>
                  {reminder.description && (
                    <p className="text-sm text-muted-foreground">{reminder.description}</p>
                  )}
                </div>
                <div className="flex space-x-1">
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          className="h-8 w-8"
                          onClick={() => handleStatusToggle(reminder)}
                          disabled={isUpdating}
                        >
                          {reminder.isActive ? (
                            <ToggleRight className="h-4 w-4" />
                          ) : (
                            <ToggleLeft className="h-4 w-4" />
                          )}
                        </Button>
                      </TooltipTrigger>
                      <TooltipContent>
                        {reminder.isActive ? 'Disable reminder' : 'Enable reminder'}
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                  
                  <PrayerReminderDialog
                    mode="edit"
                    existingReminder={reminder}
                    trigger={
                      <TooltipProvider>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Button variant="ghost" size="icon" className="h-8 w-8">
                              <Edit2 className="h-4 w-4" />
                            </Button>
                          </TooltipTrigger>
                          <TooltipContent>Edit reminder</TooltipContent>
                        </Tooltip>
                      </TooltipProvider>
                    }
                  />

                  <AlertDialog open={reminderToDelete?.id === reminder.id} onOpenChange={(open) => {
                    if (!open) setReminderToDelete(null);
                  }}>
                    <AlertDialogTrigger asChild>
                      <TooltipProvider>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Button 
                              variant="ghost" 
                              size="icon" 
                              className="h-8 w-8 text-destructive hover:text-destructive"
                              onClick={() => setReminderToDelete(reminder)}
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </TooltipTrigger>
                          <TooltipContent>Delete reminder</TooltipContent>
                        </Tooltip>
                      </TooltipProvider>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Delete Prayer Reminder</AlertDialogTitle>
                        <AlertDialogDescription>
                          Are you sure you want to delete this prayer reminder? This action cannot be undone.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                          onClick={handleDeleteReminder}
                          disabled={isDeleting}
                          className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                        >
                          {isDeleting ? 'Deleting...' : 'Delete'}
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                </div>
              </div>
              
              <div className="flex gap-4 items-center mt-1 text-sm text-muted-foreground">
                <div className="flex items-center gap-1">
                  <Clock className="h-3.5 w-3.5" />
                  {reminder.reminderTime?.toString().substring(0, 5)}
                </div>
                
                {reminder.isRecurring && (
                  <div>
                    {formatReminderSchedule(reminder)}
                  </div>
                )}
                
                {reminder.activeUntil && (
                  <div>
                    Until {format(new Date(reminder.activeUntil), 'MMM d, yyyy')}
                  </div>
                )}
              </div>
            </div>
          ))
        )}
      </CardContent>
    </Card>
  );
}
```

## File: client/src/components/update-status-modal.tsx
```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMutation } from "@tanstack/react-query";
import { insertPrayerRequestSchema } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { z } from "zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

type UpdateStatusModalProps = {
  open: boolean;
  setOpen: (open: boolean) => void;
  requestId: number;
  currentStatus?: string;
};

export default function UpdateStatusModal({
  open,
  setOpen,
  requestId,
  currentStatus = "waiting",
}: UpdateStatusModalProps) {
  const { toast } = useToast();

  const form = useForm<{ status: string }>({
    resolver: zodResolver(
      z.object({
        status: z.enum(["waiting", "answered", "declined"]),
      })
    ),
    defaultValues: {
      status: currentStatus,
    },
    values: {
      status: currentStatus,
    },
  });

  const updateStatusMutation = useMutation({
    mutationFn: async (data: { status: string }) => {
      await apiRequest("PUT", `/api/requests/${requestId}`, data);
    },
    onSuccess: () => {
      toast({
        title: "Status updated",
        description: "The prayer request status has been updated successfully.",
      });
      // Close modal
      setOpen(false);
      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: [`/api/requests/${requestId}`] });
    },
    onError: (error) => {
      toast({
        title: "Error updating status",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: { status: string }) => {
    updateStatusMutation.mutate(data);
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogContent className="sm:max-w-[400px]">
        <DialogHeader>
          <DialogTitle className="text-xl font-bold">
            Update Prayer Status
          </DialogTitle>
          <DialogDescription>
            Update the status of your prayer request.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="status"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Status</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select status" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="waiting">
                        Still Waiting
                      </SelectItem>
                      <SelectItem value="answered">
                        Answered!
                      </SelectItem>
                      <SelectItem value="declined">
                        God Said No
                      </SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <DialogFooter className="pt-2">
              <Button
                type="button"
                variant="outline"
                onClick={() => setOpen(false)}
              >
                Cancel
              </Button>
              <Button 
                type="submit"
                disabled={updateStatusMutation.isPending}
              >
                {updateStatusMutation.isPending ? (
                  <div className="flex items-center">
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                    </svg>
                    Updating...
                  </div>
                ) : (
                  "Update Status"
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

## File: client/src/hooks/use-auth.tsx
```typescript
import { createContext, ReactNode, useContext } from "react";
import {
  useQuery,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { LoginData, RegisterData, User as SelectUser } from "@shared/schema";
import { getQueryFn, apiRequest, queryClient } from "../lib/queryClient";
import { useToast } from "@/hooks/use-toast";

type AuthContextType = {
  user: SelectUser | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: UseMutationResult<SelectUser, Error, LoginData>;
  logoutMutation: UseMutationResult<void, Error, void>;
  registerMutation: UseMutationResult<SelectUser, Error, RegisterData>;
};

export const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();
  const {
    data: user,
    error,
    isLoading,
  } = useQuery<SelectUser | undefined, Error>({
    queryKey: ["/api/user"],
    queryFn: getQueryFn({ on401: "returnNull" }),
  });

  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginData) => {
      const res = await apiRequest("POST", "/api/login", credentials);
      return await res.json();
    },
    onSuccess: (user: SelectUser) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Welcome back!",
        description: "You've successfully logged in.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Login failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const registerMutation = useMutation({
    mutationFn: async (credentials: RegisterData) => {
      const res = await apiRequest("POST", "/api/register", credentials);
      return await res.json();
    },
    onSuccess: (user: SelectUser) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Account created!",
        description: "Welcome to Prayer Pipeline.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const logoutMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", "/api/logout");
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
      toast({
        title: "Logged out",
        description: "You've been successfully logged out.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Logout failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return (
    <AuthContext.Provider
      value={{
        user: user ?? null,
        isLoading,
        error,
        loginMutation,
        logoutMutation,
        registerMutation,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
```

## File: client/src/hooks/use-favorite-groups.tsx
```typescript
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { Group } from "@shared/schema";
import { useToast } from "@/hooks/use-toast";
import { Star } from "lucide-react";

export function useFavoriteGroups() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Get all favorite groups
  const {
    data: favoriteGroups = [],
    isLoading,
    error,
  } = useQuery<Group[]>({
    queryKey: ["/api/groups/favorites"],
    enabled: true,
  });

  // Check if a group is favorited
  const isFavorite = (groupId: number): boolean => {
    return favoriteGroups.some(group => group.id === groupId);
  };

  // Add a group to favorites
  const addToFavoritesMutation = useMutation({
    mutationFn: async (groupId: number) => {
      const res = await apiRequest("POST", `/api/groups/${groupId}/favorite`);
      return await res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/groups/favorites"] });
      toast({
        title: "Group added to favorites",
        description: "You can now find this group in your favorites.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to add to favorites",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Remove a group from favorites
  const removeFromFavoritesMutation = useMutation({
    mutationFn: async (groupId: number) => {
      const res = await apiRequest("DELETE", `/api/groups/${groupId}/favorite`);
      return await res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/groups/favorites"] });
      toast({
        title: "Group removed from favorites",
        description: "The group has been removed from your favorites.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to remove from favorites",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Toggle favorite status
  const toggleFavorite = (groupId: number, currentStatus: boolean) => {
    if (currentStatus) {
      return removeFromFavoritesMutation.mutate(groupId);
    } else {
      return addToFavoritesMutation.mutate(groupId);
    }
  };

  return {
    favoriteGroups,
    isLoading,
    error,
    isFavorite,
    addToFavorites: addToFavoritesMutation.mutate,
    removeFromFavorites: removeFromFavoritesMutation.mutate,
    toggleFavorite,
    isPendingAdd: addToFavoritesMutation.isPending,
    isPendingRemove: removeFromFavoritesMutation.isPending,
  };
}

// FavoriteButton component
export function FavoriteButton({ 
  groupId,
  isFavorite,
  isLoading,
  onToggle,
  size = "default" 
}: { 
  groupId: number; 
  isFavorite: boolean;
  isLoading: boolean;
  onToggle: () => void;
  size?: "default" | "sm" | "lg"
}) {
  const sizeClasses = {
    "default": "h-6 w-6",
    "sm": "h-4 w-4",
    "lg": "h-8 w-8",
  };
  
  return (
    <button
      className="text-yellow-500 hover:text-yellow-600 transition-colors duration-200 focus:outline-none"
      onClick={(e) => {
        e.preventDefault();
        e.stopPropagation();
        onToggle();
      }}
      title={isFavorite ? "Remove from favorites" : "Add to favorites"}
      disabled={isLoading}
    >
      <Star 
        className={`${sizeClasses[size]} transition-all duration-300 ${isFavorite ? "fill-yellow-500" : "fill-none"} ${isLoading ? "opacity-50" : "opacity-100"}`} 
      />
    </button>
  );
}
```

## File: client/src/hooks/use-group-notification-preferences.tsx
```typescript
import { useMutation, useQuery } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { GroupNotificationPreference } from "@shared/schema";
import { useToast } from "@/hooks/use-toast";

export function useGroupNotificationPreferences(groupId: number) {
  const { toast } = useToast();
  
  const queryKey = [`/api/groups/${groupId}/notification-preferences`];
  
  const {
    data: preferences,
    isLoading,
    error,
  } = useQuery<GroupNotificationPreference>({
    queryKey,
    staleTime: 1000 * 60 * 5, // 5 minutes
    enabled: !!groupId, // Only run the query if groupId is provided
  });

  const updatePreferencesMutation = useMutation({
    mutationFn: async (updatedPreferences: Partial<GroupNotificationPreference>) => {
      const res = await apiRequest(
        "PATCH", 
        `/api/groups/${groupId}/notification-preferences`, 
        updatedPreferences
      );
      return await res.json();
    },
    onSuccess: (updatedPreferences: GroupNotificationPreference) => {
      queryClient.setQueryData(queryKey, updatedPreferences);
      toast({
        title: "Group preferences updated",
        description: "Your notification preferences for this group have been updated successfully",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to update group preferences",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return {
    preferences,
    isLoading,
    error,
    updatePreferences: updatePreferencesMutation.mutate,
    isPending: updatePreferencesMutation.isPending,
  };
}
```

## File: client/src/hooks/use-meeting-notes.tsx
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { MeetingNote, insertMeetingNotesSchema } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { z } from "zod";

// Type for creating meeting notes
export type CreateMeetingNotesInput = z.infer<typeof insertMeetingNotesSchema>;

// Type for updating meeting notes
export type UpdateMeetingNotesInput = Partial<CreateMeetingNotesInput>;

export function useMeetingNotes(meetingId?: number) {
  const { toast } = useToast();
  
  // Get all notes for a meeting
  const {
    data: notes = [],
    isLoading: isLoadingNotes,
    isError: isNotesError,
    error: notesError,
  } = useQuery<MeetingNote[]>({
    queryKey: ['/api/meetings', meetingId, 'notes'],
    enabled: !!meetingId,
  });

  // Create meeting notes
  const createNotesMutation = useMutation({
    mutationFn: async (data: CreateMeetingNotesInput) => {
      const response = await apiRequest(
        "POST", 
        `/api/meetings/${data.meetingId}/notes`, 
        data
      );
      return await response.json();
    },
    onSuccess: (_data, variables) => {
      toast({
        title: "Notes created",
        description: "Meeting notes have been saved successfully.",
      });
      
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['/api/meetings', variables.meetingId, 'notes'] });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to create notes",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Update meeting notes
  const updateNotesMutation = useMutation({
    mutationFn: async ({ 
      noteId, 
      data 
    }: { 
      noteId: number; 
      data: UpdateMeetingNotesInput 
    }) => {
      const response = await apiRequest(
        "PUT", 
        `/api/meetings/${data.meetingId}/notes/${noteId}`, 
        data
      );
      return await response.json();
    },
    onSuccess: (_data, variables) => {
      toast({
        title: "Notes updated",
        description: "Meeting notes have been updated successfully.",
      });
      
      // Invalidate related queries
      queryClient.invalidateQueries({ 
        queryKey: ['/api/meetings', variables.data.meetingId, 'notes'] 
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to update notes",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Delete meeting notes
  const deleteNotesMutation = useMutation({
    mutationFn: async ({ 
      meetingId, 
      noteId 
    }: { 
      meetingId: number; 
      noteId: number 
    }) => {
      await apiRequest(
        "DELETE", 
        `/api/meetings/${meetingId}/notes/${noteId}`
      );
    },
    onSuccess: (_data, variables) => {
      toast({
        title: "Notes deleted",
        description: "Meeting notes have been deleted successfully.",
      });
      
      // Invalidate related queries
      queryClient.invalidateQueries({ 
        queryKey: ['/api/meetings', variables.meetingId, 'notes'] 
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to delete notes",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Create prayer requests from meeting notes
  const createRequestsFromNotesMutation = useMutation({
    mutationFn: async (meetingId: number) => {
      const response = await apiRequest(
        "POST", 
        `/api/meetings/${meetingId}/create-requests`,
        {}
      );
      return await response.json();
    },
    onSuccess: () => {
      toast({
        title: "Prayer requests created",
        description: "Prayer requests have been created from meeting notes.",
      });
      
      // Invalidate prayer requests
      queryClient.invalidateQueries({ 
        queryKey: ['/api/requests/user/recent'] 
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to create prayer requests",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return {
    // Queries
    notes,
    isLoadingNotes,
    isNotesError,
    notesError,
    
    // Mutations
    createNotes: createNotesMutation.mutate,
    isCreatingNotes: createNotesMutation.isPending,
    
    updateNotes: updateNotesMutation.mutate,
    isUpdatingNotes: updateNotesMutation.isPending,
    
    deleteNotes: deleteNotesMutation.mutate,
    isDeletingNotes: deleteNotesMutation.isPending,
    
    createRequestsFromNotes: createRequestsFromNotesMutation.mutate,
    isCreatingRequests: createRequestsFromNotesMutation.isPending,
  };
}
```

## File: client/src/hooks/use-meetings.tsx
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { Meeting, insertMeetingSchema } from "@shared/schema";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { z } from "zod";

// Type for creating a new meeting - with additional frontend-only fields
export type CreateMeetingInput = z.infer<typeof insertMeetingSchema> & {
  // Optional overrides for form processing
  recurringDay?: number | null;
  recurringUntil?: Date | null;
};

// Type for updating a meeting
export type UpdateMeetingInput = Partial<CreateMeetingInput>;

export function useMeetings(groupId?: number) {
  const { toast } = useToast();
  
  // Get all meetings for a group
  const {
    data: meetings = [],
    isLoading: isLoadingMeetings,
    isError: isMeetingsError,
    error: meetingsError,
  } = useQuery<Meeting[]>({
    queryKey: ['/api/groups', groupId, 'meetings'],
    enabled: !!groupId,
  });

  // Get a specific meeting
  const getMeeting = (meetingId: number) => {
    return useQuery<Meeting>({
      queryKey: ['/api/meetings', meetingId],
    });
  };

  // Get upcoming meetings for the current user
  const {
    data: upcomingMeetings = [],
    isLoading: isLoadingUpcoming,
    isError: isUpcomingError,
    error: upcomingError,
  } = useQuery<Meeting[]>({
    queryKey: ['/api/meetings/upcoming'],
  });

  // Create a new meeting
  const createMeetingMutation = useMutation({
    mutationFn: async (data: CreateMeetingInput) => {
      const response = await apiRequest(
        "POST", 
        `/api/groups/${data.groupId}/meetings`, 
        data
      );
      return await response.json();
    },
    onSuccess: (_data, variables) => {
      toast({
        title: "Meeting created",
        description: "Your meeting has been scheduled successfully.",
      });
      
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['/api/groups', variables.groupId, 'meetings'] });
      queryClient.invalidateQueries({ queryKey: ['/api/meetings/upcoming'] });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to create meeting",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Update a meeting
  const updateMeetingMutation = useMutation({
    mutationFn: async ({ 
      meetingId, 
      data 
    }: { 
      meetingId: number; 
      data: UpdateMeetingInput 
    }) => {
      const response = await apiRequest(
        "PUT", 
        `/api/meetings/${meetingId}`, 
        data
      );
      return await response.json();
    },
    onSuccess: (_data, variables) => {
      toast({
        title: "Meeting updated",
        description: "Your meeting has been updated successfully.",
      });
      
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['/api/meetings', variables.meetingId] });
      queryClient.invalidateQueries({ queryKey: ['/api/meetings/upcoming'] });
      
      // If we know the group ID, invalidate that too
      if (groupId) {
        queryClient.invalidateQueries({ queryKey: ['/api/groups', groupId, 'meetings'] });
      }
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to update meeting",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Delete a meeting
  const deleteMeetingMutation = useMutation({
    mutationFn: async (meetingId: number) => {
      await apiRequest("DELETE", `/api/meetings/${meetingId}`);
    },
    onSuccess: (_data, meetingId) => {
      toast({
        title: "Meeting deleted",
        description: "The meeting has been cancelled successfully.",
      });
      
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['/api/meetings', meetingId] });
      queryClient.invalidateQueries({ queryKey: ['/api/meetings/upcoming'] });
      
      // If we know the group ID, invalidate that too
      if (groupId) {
        queryClient.invalidateQueries({ queryKey: ['/api/groups', groupId, 'meetings'] });
      }
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to delete meeting",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return {
    // Queries
    meetings,
    isLoadingMeetings,
    isMeetingsError,
    meetingsError,
    
    upcomingMeetings,
    isLoadingUpcoming,
    isUpcomingError,
    upcomingError,
    
    getMeeting,
    
    // Mutations
    createMeeting: createMeetingMutation.mutate,
    isCreatingMeeting: createMeetingMutation.isPending,
    
    updateMeeting: updateMeetingMutation.mutate,
    isUpdatingMeeting: updateMeetingMutation.isPending,
    
    deleteMeeting: deleteMeetingMutation.mutate,
    isDeletingMeeting: deleteMeetingMutation.isPending,
  };
}
```

## File: client/src/hooks/use-mobile.tsx
```typescript
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
```

## File: client/src/hooks/use-notification-preferences.tsx
```typescript
import { useMutation, useQuery } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { NotificationPreference } from "@shared/schema";
import { useToast } from "@/hooks/use-toast";

export function useNotificationPreferences() {
  const { toast } = useToast();
  
  const {
    data: preferences,
    isLoading,
    error,
  } = useQuery<NotificationPreference>({
    queryKey: ["/api/notification-preferences"],
    staleTime: 1000 * 60 * 5, // 5 minutes
  });

  const updatePreferencesMutation = useMutation({
    mutationFn: async (updatedPreferences: Partial<NotificationPreference>) => {
      const res = await apiRequest("PATCH", "/api/notification-preferences", updatedPreferences);
      return await res.json();
    },
    onSuccess: (updatedPreferences: NotificationPreference) => {
      queryClient.setQueryData(["/api/notification-preferences"], updatedPreferences);
      toast({
        title: "Preferences updated",
        description: "Your notification preferences have been updated successfully",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to update preferences",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return {
    preferences,
    isLoading,
    error,
    updatePreferences: updatePreferencesMutation.mutate,
    isPending: updatePreferencesMutation.isPending,
  };
}
```

## File: client/src/hooks/use-organizations.tsx
```typescript
import { createContext, ReactNode, useContext, useState, useEffect } from "react";
import {
  useQuery,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { Organization, InsertOrganization, OrganizationMember } from "@shared/schema";
import { getQueryFn, apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";

type OrganizationContextType = {
  organizations: Organization[];
  currentOrganization: Organization | null;
  isLoading: boolean;
  error: Error | null;
  setCurrentOrganizationId: (id: number) => void;
  createOrganizationMutation: UseMutationResult<Organization, Error, Omit<InsertOrganization, "createdBy">>;
  updateOrganizationMutation: UseMutationResult<Organization, Error, { id: number, data: Partial<InsertOrganization> }>;
  deleteOrganizationMutation: UseMutationResult<void, Error, number>;
  leaveOrganizationMutation: UseMutationResult<void, Error, number>;
  inviteMemberMutation: UseMutationResult<void, Error, { organizationId: number, email: string, role: "admin" | "member" }>;
  removeMemberMutation: UseMutationResult<void, Error, { organizationId: number, userId: number }>;
  organizationMembers: OrganizationMember[];
  isLoadingMembers: boolean;
  errorMembers: Error | null;
};

export const OrganizationContext = createContext<OrganizationContextType | null>(null);

export function OrganizationProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();
  const { user } = useAuth();
  const [currentOrganizationId, setCurrentOrganizationId] = useState<number | null>(null);

  // Load user's organizations
  const {
    data: organizations = [],
    error,
    isLoading,
  } = useQuery<Organization[], Error>({
    queryKey: ["/api/organizations"],
    queryFn: getQueryFn({ on401: "throw" }),
    enabled: !!user,
  });

  // Set default organization if needed
  const currentOrganization = organizations.find(org => org.id === currentOrganizationId) || organizations[0] || null;
  
  // Whenever organizations data changes, update current org if needed
  useEffect(() => {
    if (organizations.length > 0 && !currentOrganizationId && !isLoading) {
      setCurrentOrganizationId(organizations[0].id);
    }
  }, [organizations, currentOrganizationId, isLoading]);

  // Load organization members for current organization
  const {
    data: organizationMembers = [],
    error: errorMembers,
    isLoading: isLoadingMembers,
  } = useQuery<OrganizationMember[], Error>({
    queryKey: ["/api/organizations/members"],
    queryFn: () => {
      if (!currentOrganizationId) return Promise.resolve([]);
      return fetch(`/api/organizations/members?organizationId=${currentOrganizationId}`)
        .then(res => {
          if (!res.ok) throw new Error('Failed to fetch members');
          return res.json();
        });
    },
    enabled: !!currentOrganizationId,
  });

  // Create organization mutation
  const createOrganizationMutation = useMutation({
    mutationFn: async (orgData: Omit<InsertOrganization, "createdBy">) => {
      const res = await apiRequest("POST", "/api/organizations", orgData);
      return await res.json();
    },
    onSuccess: (organization: Organization) => {
      queryClient.invalidateQueries({ queryKey: ["/api/organizations"] });
      toast({
        title: "Organization created",
        description: `${organization.name} has been created successfully.`,
      });
      setCurrentOrganizationId(organization.id);
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to create organization",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Update organization mutation
  const updateOrganizationMutation = useMutation({
    mutationFn: async ({ id, data }: { id: number, data: Partial<InsertOrganization> }) => {
      const res = await apiRequest("PATCH", `/api/organizations/${id}`, data);
      return await res.json();
    },
    onSuccess: (organization: Organization) => {
      queryClient.invalidateQueries({ queryKey: ["/api/organizations"] });
      toast({
        title: "Organization updated",
        description: `${organization.name} has been updated successfully.`,
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to update organization",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Delete organization mutation
  const deleteOrganizationMutation = useMutation({
    mutationFn: async (id: number) => {
      await apiRequest("DELETE", `/api/organizations/${id}`);
    },
    onSuccess: (_, deletedOrgId) => {
      queryClient.invalidateQueries({ queryKey: ["/api/organizations"] });
      toast({
        title: "Organization deleted",
        description: "The organization has been deleted successfully.",
      });
      
      // If we're deleting the current organization, we need to select a new one
      if (currentOrganizationId === deletedOrgId) {
        const remainingOrgs = organizations.filter(org => org.id !== deletedOrgId);
        if (remainingOrgs.length > 0) {
          setCurrentOrganizationId(remainingOrgs[0].id);
        } else {
          setCurrentOrganizationId(null);
          // Redirect to onboarding if no organizations left
          window.location.href = "/onboarding";
        }
      }
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to delete organization",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Invite member mutation
  const inviteMemberMutation = useMutation({
    mutationFn: async ({ organizationId, email, role }: { organizationId: number, email: string, role: "admin" | "member" }) => {
      await apiRequest("POST", `/api/organizations/${organizationId}/invite`, { email, role });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/organizations/members"] });
      toast({
        title: "Invitation sent",
        description: "The user has been invited to the organization.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to invite member",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Remove member mutation
  const removeMemberMutation = useMutation({
    mutationFn: async ({ organizationId, userId }: { organizationId: number, userId: number }) => {
      await apiRequest("DELETE", `/api/organizations/${organizationId}/members/${userId}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/organizations/members"] });
      toast({
        title: "Member removed",
        description: "The member has been removed from the organization.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to remove member",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Leave organization mutation
  const leaveOrganizationMutation = useMutation({
    mutationFn: async (orgId: number) => {
      await apiRequest("POST", `/api/organizations/${orgId}/leave`);
    },
    onSuccess: (_, leftOrgId) => {
      queryClient.invalidateQueries({ queryKey: ["/api/organizations"] });
      toast({
        title: "Organization left",
        description: "You have left the organization successfully.",
      });

      // If we're leaving the current organization, we need to select a new one
      if (currentOrganizationId === leftOrgId) {
        const remainingOrgs = organizations.filter(org => org.id !== leftOrgId);
        if (remainingOrgs.length > 0) {
          setCurrentOrganizationId(remainingOrgs[0].id);
        } else {
          setCurrentOrganizationId(null);
          // Redirect to onboarding if no organizations left
          window.location.href = "/onboarding";
        }
      }
    },
    onError: (error: Error) => {
      toast({
        title: "Failed to leave organization",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return (
    <OrganizationContext.Provider
      value={{
        organizations,
        currentOrganization,
        isLoading,
        error,
        setCurrentOrganizationId,
        createOrganizationMutation,
        updateOrganizationMutation,
        deleteOrganizationMutation,
        leaveOrganizationMutation,
        inviteMemberMutation,
        removeMemberMutation,
        organizationMembers,
        isLoadingMembers,
        errorMembers,
      }}
    >
      {children}
    </OrganizationContext.Provider>
  );
}

export function useOrganizations() {
  const context = useContext(OrganizationContext);
  if (!context) {
    throw new Error("useOrganizations must be used within an OrganizationProvider");
  }
  return context;
}
```

## File: client/src/hooks/use-prayer-reminders.tsx
```typescript
import { useQuery, useMutation } from '@tanstack/react-query';
import { PrayerReminder, InsertPrayerReminder } from '@shared/schema';
import { apiRequest, queryClient } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';

// Interface for the custom days of week
type DayOfWeek = 'sunday' | 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday';

export interface PrayerReminderWithDays extends Omit<PrayerReminder, 'recurringDays'> {
  recurringDays: DayOfWeek[];
}

export interface CreatePrayerReminderData extends Omit<InsertPrayerReminder, 'userId' | 'recurringDays'> {
  recurringDays?: DayOfWeek[];
}

export function usePrayerReminders() {
  const { toast } = useToast();

  const {
    data: reminders = [],
    isLoading,
    isError,
    error,
  } = useQuery<PrayerReminder[]>({
    queryKey: ['/api/prayer-reminders'],
    select: (data) => {
      // Parse the recurringDays JSON string for each reminder
      return data.map((reminder) => {
        try {
          const parsedDays = reminder.recurringDays ? JSON.parse(reminder.recurringDays) : [];
          return {
            ...reminder,
            recurringDays: parsedDays,
          };
        } catch (e) {
          console.error('Error parsing recurring days:', e);
          return {
            ...reminder,
            recurringDays: [],
          };
        }
      }) as PrayerReminderWithDays[];
    },
  });

  const createReminderMutation = useMutation({
    mutationFn: async (data: CreatePrayerReminderData) => {
      const res = await apiRequest('POST', '/api/prayer-reminders', data);
      return await res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/prayer-reminders'] });
      toast({
        title: 'Prayer reminder created',
        description: 'Your prayer reminder has been scheduled.',
      });
    },
    onError: (error: Error) => {
      toast({
        title: 'Failed to create reminder',
        description: error.message,
        variant: 'destructive',
      });
    },
  });

  const updateReminderMutation = useMutation({
    mutationFn: async ({
      id,
      data,
    }: {
      id: number;
      data: Partial<CreatePrayerReminderData>;
    }) => {
      const res = await apiRequest('PUT', `/api/prayer-reminders/${id}`, data);
      return await res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/prayer-reminders'] });
      toast({
        title: 'Prayer reminder updated',
        description: 'Your prayer reminder has been updated.',
      });
    },
    onError: (error: Error) => {
      toast({
        title: 'Failed to update reminder',
        description: error.message,
        variant: 'destructive',
      });
    },
  });

  const deleteReminderMutation = useMutation({
    mutationFn: async (id: number) => {
      await apiRequest('DELETE', `/api/prayer-reminders/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/prayer-reminders'] });
      toast({
        title: 'Prayer reminder deleted',
        description: 'Your prayer reminder has been removed.',
      });
    },
    onError: (error: Error) => {
      toast({
        title: 'Failed to delete reminder',
        description: error.message,
        variant: 'destructive',
      });
    },
  });

  return {
    reminders,
    isLoading,
    isError,
    error,
    createReminder: createReminderMutation.mutate,
    updateReminder: updateReminderMutation.mutate,
    deleteReminder: deleteReminderMutation.mutate,
    isCreating: createReminderMutation.isPending,
    isUpdating: updateReminderMutation.isPending,
    isDeleting: deleteReminderMutation.isPending,
  };
}
```

## File: client/src/hooks/use-push-notifications.tsx
```typescript
import { useState, useEffect, useCallback } from 'react';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/hooks/use-auth';
import {
  isPushNotificationSupported,
  requestNotificationPermission,
  subscribeToPushNotifications,
  unsubscribeFromPushNotifications
} from '@/lib/push-notifications';

export function usePushNotifications() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [permission, setPermission] = useState<NotificationPermission | null>(null);
  const [isSubscribed, setIsSubscribed] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [subscription, setSubscription] = useState<PushSubscription | null>(null);
  const [isSupported, setIsSupported] = useState<boolean>(false);

  // Check if push notifications are supported
  useEffect(() => {
    const supported = isPushNotificationSupported();
    setIsSupported(supported);
    
    if (supported && 'Notification' in window) {
      setPermission(Notification.permission);
      
      // Check if already subscribed
      navigator.serviceWorker.ready.then(registration => {
        registration.pushManager.getSubscription().then(sub => {
          setIsSubscribed(!!sub);
          setSubscription(sub);
          setIsLoading(false);
        });
      }).catch(error => {
        console.error('Error checking subscription status:', error);
        setIsLoading(false);
      });
    } else {
      setIsLoading(false);
    }
  }, [user?.id]);

  // Subscribe to push notifications
  const subscribe = useCallback(async () => {
    if (!user) {
      toast({
        title: "Authentication required",
        description: "Please log in to subscribe to notifications",
        variant: "destructive"
      });
      return false;
    }

    try {
      setIsLoading(true);
      const result = await subscribeToPushNotifications();
      
      if (result) {
        setIsSubscribed(true);
        setSubscription(result);
        setPermission('granted');
        
        toast({
          title: "Notifications enabled",
          description: "You'll now receive prayer updates via notifications",
        });
        return true;
      } else {
        toast({
          title: "Notification setup failed",
          description: "We couldn't set up notifications. Please check your browser settings.",
          variant: "destructive"
        });
        return false;
      }
    } catch (error) {
      console.error('Error subscribing to push notifications:', error);
      toast({
        title: "Notification error",
        description: "There was a problem setting up notifications",
        variant: "destructive"
      });
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [user, toast]);

  // Unsubscribe from push notifications
  const unsubscribe = useCallback(async () => {
    try {
      setIsLoading(true);
      const result = await unsubscribeFromPushNotifications();
      
      if (result) {
        setIsSubscribed(false);
        setSubscription(null);
        
        toast({
          title: "Notifications disabled",
          description: "You won't receive push notifications anymore",
        });
        return true;
      } else {
        toast({
          title: "Error disabling notifications",
          description: "We couldn't disable notifications. Please try again.",
          variant: "destructive"
        });
        return false;
      }
    } catch (error) {
      console.error('Error unsubscribing from push notifications:', error);
      toast({
        title: "Notification error",
        description: "There was a problem disabling notifications",
        variant: "destructive"
      });
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  // Request permission for notifications
  const requestPermission = useCallback(async () => {
    try {
      setIsLoading(true);
      const permission = await requestNotificationPermission();
      setPermission(permission);
      
      if (permission === 'granted') {
        await subscribe();
        return true;
      } else {
        toast({
          title: "Permission required",
          description: "Notification permission is needed to receive updates",
          variant: "destructive"
        });
        return false;
      }
    } catch (error) {
      console.error('Error requesting notification permission:', error);
      toast({
        title: "Permission error",
        description: "There was a problem requesting notification permission",
        variant: "destructive"
      });
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [subscribe, toast]);

  return {
    isSupported,
    isSubscribed,
    permission,
    subscription,
    isLoading,
    subscribe,
    unsubscribe,
    requestPermission
  };
}
```

## File: client/src/hooks/use-query-params.ts
```typescript
import { useCallback, useMemo } from 'react';
import { useLocation } from 'wouter';

interface QueryParams {
  [key: string]: string;
  token?: string;
  setQueryParam: (key: string, value: string) => void;
  removeQueryParam: (key: string) => void;
}

export function useQueryParams(): QueryParams {
  const [location] = useLocation();
  
  const queryParams = useMemo(() => {
    const url = new URL(window.location.href);
    const params: Record<string, string> = {};
    
    url.searchParams.forEach((value, key) => {
      params[key] = value;
    });
    
    return params;
  }, [location]);
  
  const setQueryParam = useCallback((key: string, value: string) => {
    const url = new URL(window.location.href);
    url.searchParams.set(key, value);
    window.history.replaceState({}, '', url.toString());
  }, []);
  
  const removeQueryParam = useCallback((key: string) => {
    const url = new URL(window.location.href);
    url.searchParams.delete(key);
    window.history.replaceState({}, '', url.toString());
  }, []);
  
  return {
    ...queryParams,
    setQueryParam,
    removeQueryParam
  };
}
```

## File: client/src/hooks/use-toast.ts
```typescript
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
```

## File: client/src/lib/organization-protected-route.tsx
```typescript
import { useAuth } from "@/hooks/use-auth";
import { useOrganizations } from "@/hooks/use-organizations";
import { Loader2 } from "lucide-react";
import { Redirect, Route } from "wouter";

export function OrganizationProtectedRoute({
  path,
  component: Component,
}: {
  path: string;
  component: () => React.JSX.Element;
}) {
  const { user, isLoading: isLoadingAuth } = useAuth();
  const { organizations, isLoading: isLoadingOrgs } = useOrganizations();

  // If still loading auth or orgs data, show loading spinner
  if (isLoadingAuth || isLoadingOrgs) {
    return (
      <Route path={path}>
        <div className="flex items-center justify-center min-h-screen">
          <Loader2 className="h-8 w-8 animate-spin text-border" />
        </div>
      </Route>
    );
  }

  // If user is not authenticated, redirect to auth page
  if (!user) {
    return (
      <Route path={path}>
        <Redirect to="/auth" />
      </Route>
    );
  }

  // If user has no organizations, redirect to the onboarding page
  if (organizations.length === 0) {
    return (
      <Route path={path}>
        <Redirect to="/onboarding" />
      </Route>
    );
  }

  // User is authenticated and has at least one organization, render the component
  return <Route path={path} component={Component} />;
}
```

## File: client/src/lib/protected-route.tsx
```typescript
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
import { Redirect, Route } from "wouter";

export function ProtectedRoute({
  path,
  component: Component,
}: {
  path: string;
  component: React.ComponentType<any>;
}) {
  const { user, isLoading } = useAuth();

  return (
    <Route path={path}>
      {() => {
        if (isLoading) {
          return (
            <div className="flex items-center justify-center min-h-screen">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
          );
        }

        if (!user) {
          return <Redirect to="/auth" />;
        }

        return <Component />;
      }}
    </Route>
  );
}
```

## File: client/src/lib/push-notifications.ts
```typescript
// Push Notification Utilities

// Get the server's VAPID public key for web push
export async function getVapidPublicKey(): Promise<string> {
  try {
    const response = await fetch('/api/push/vapid-public-key');
    if (!response.ok) {
      throw new Error('Failed to get VAPID public key');
    }
    const data = await response.json();
    return data.publicKey; // This matches what the server sends in push-notifications.ts getVapidPublicKey()
  } catch (error) {
    console.error('Error getting VAPID public key:', error);
    throw error;
  }
}

// Convert base64 string to Uint8Array for push subscription
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

// Check if push notifications are supported by the browser
export function isPushNotificationSupported(): boolean {
  return 'serviceWorker' in navigator && 
         'PushManager' in window && 
         'Notification' in window;
}

// Request permission for notifications
export async function requestNotificationPermission(): Promise<NotificationPermission> {
  if (!('Notification' in window)) {
    throw new Error('Notifications not supported in this browser');
  }

  if (Notification.permission === 'granted') {
    return 'granted';
  }

  try {
    return await Notification.requestPermission();
  } catch (error) {
    console.error('Error requesting notification permission:', error);
    throw error;
  }
}

// Register the service worker for push notifications
export async function registerServiceWorker(): Promise<ServiceWorkerRegistration> {
  if (!('serviceWorker' in navigator)) {
    throw new Error('Service worker not supported in this browser');
  }

  try {
    return await navigator.serviceWorker.register('/service-worker.js');
  } catch (error) {
    console.error('Error registering service worker:', error);
    throw error;
  }
}

// Subscribe to push notifications
export async function subscribeToPushNotifications(): Promise<PushSubscription | null> {
  if (!isPushNotificationSupported()) {
    console.error('Push notifications not supported');
    return null;
  }

  try {
    // Request notification permission
    const permission = await requestNotificationPermission();
    if (permission !== 'granted') {
      console.warn('Notification permission denied');
      return null;
    }

    // Get the service worker registration
    let swRegistration;
    if (!navigator.serviceWorker.controller) {
      swRegistration = await registerServiceWorker();
    } else {
      swRegistration = await navigator.serviceWorker.ready;
    }

    // Get the VAPID public key
    const vapidPublicKey = await getVapidPublicKey();
    const applicationServerKey = urlBase64ToUint8Array(vapidPublicKey);

    // Subscribe to push
    const subscription = await swRegistration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey,
    });

    // Save the subscription on the server
    await saveSubscription(subscription);

    return subscription;
  } catch (error) {
    console.error('Error subscribing to push notifications:', error);
    throw error;
  }
}

// Save the push subscription on the server
export async function saveSubscription(subscription: PushSubscription): Promise<void> {
  try {
    // Get basic user agent info to help identify the subscription
    const deviceInfo = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
    };

    const response = await fetch('/api/push/subscribe', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        subscription,
        deviceInfo
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to save push subscription');
    }
  } catch (error) {
    console.error('Error saving push subscription:', error);
    throw error;
  }
}

// Unsubscribe from push notifications
export async function unsubscribeFromPushNotifications(): Promise<boolean> {
  if (!isPushNotificationSupported()) {
    console.error('Push notifications not supported');
    return false;
  }

  try {
    const swRegistration = await navigator.serviceWorker.ready;
    const subscription = await swRegistration.pushManager.getSubscription();

    if (!subscription) {
      return true; // Already unsubscribed
    }

    // Unsubscribe from push
    const success = await subscription.unsubscribe();
    if (success) {
      // Remove the subscription from the server by sending just the endpoint
      await fetch('/api/push/unsubscribe', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ endpoint: subscription.endpoint }),
      });
    }

    return success;
  } catch (error) {
    console.error('Error unsubscribing from push notifications:', error);
    throw error;
  }
}
```

## File: client/src/lib/queryClient.ts
```typescript
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
interface QueryFnOptions {
  on401?: UnauthorizedBehavior;
  params?: Record<string, any>;
}

export const getQueryFn: <T>(options?: QueryFnOptions) => QueryFunction<T> =
  (options = {}) =>
  async ({ queryKey }) => {
    const { on401: unauthorizedBehavior = "throw", params = {} } = options;
    
    // Build URL with query parameters
    let url: string;
    
    // Handle array query keys differently based on structure
    if (Array.isArray(queryKey) && queryKey.length > 1) {
      // Special case for paths with IDs embedded in them, like '/api/groups/:groupId/meetings'
      if (queryKey.length >= 3 && queryKey[0] === '/api/groups' && queryKey[2] === 'meetings') {
        url = `/api/groups/${queryKey[1]}/meetings`;
      }
      // Special case for meetings notes
      else if (queryKey.length >= 3 && queryKey[0] === '/api/meetings' && queryKey[2] === 'notes') {
        url = `/api/meetings/${queryKey[1]}/notes`;
      }
      // Special case for specific meeting by ID
      else if (queryKey.length === 2 && queryKey[0] === '/api/meetings') {
        url = `/api/meetings/${queryKey[1]}`;
      }
      // Default case: treat second param as organizationId
      else if (queryKey[1] !== undefined && queryKey[1] !== null) {
        url = `${queryKey[0]}${queryKey[0].includes('?') ? '&' : '?'}organizationId=${queryKey[1]}`;
      } 
      else {
        url = queryKey[0] as string;
      }
    } else {
      // Simple case: just use the first element as the URL
      url = queryKey[0] as string;
    }
    
    // Add additional parameters if provided
    if (params && Object.keys(params).length > 0) {
      const searchParams = new URLSearchParams();
      
      // Add all params to the URL
      for (const [key, value] of Object.entries(params)) {
        if (value !== undefined && value !== null) {
          searchParams.append(key, String(value));
        }
      }
      
      const queryString = searchParams.toString();
      if (queryString) {
        url = `${url}${url.includes('?') ? '&' : '?'}${queryString}`;
      }
    }

    const res = await fetch(url, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});
```

## File: client/src/lib/utils.ts
```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

## File: client/src/pages/auth-page.tsx
```typescript
import { useEffect, useState } from "react";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { loginSchema, registerSchema } from "@shared/schema";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

export default function AuthPage() {
  const [isLogin, setIsLogin] = useState(true);
  const { user, loginMutation, registerMutation } = useAuth();
  const [_, setLocation] = useLocation();
  const { toast } = useToast();

  // Redirect if already logged in
  useEffect(() => {
    if (user) {
      setLocation("/");
    }
  }, [user, setLocation]);

  const loginForm = useForm<z.infer<typeof loginSchema>>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      username: "",
      password: "",
    },
  });

  const registerForm = useForm<z.infer<typeof registerSchema>>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      username: "",
      name: "",
      email: "",
      phone: "",
      password: "",
      confirmPassword: "",
      role: "regular",
      avatar: "",
      bio: "",
    },
    mode: "onChange", // Validate on change for better user feedback
  });

  // Show errors from mutations
  useEffect(() => {
    if (loginMutation.error) {
      toast({
        title: "Login failed",
        description: loginMutation.error.message,
        variant: "destructive",
      });
    }
  }, [loginMutation.error, toast]);

  useEffect(() => {
    if (registerMutation.error) {
      toast({
        title: "Registration failed",
        description: registerMutation.error.message,
        variant: "destructive",
      });
    }
  }, [registerMutation.error, toast]);

  const onLoginSubmit = (values: z.infer<typeof loginSchema>) => {
    loginMutation.mutate(values);
  };

  const onRegisterSubmit = (values: z.infer<typeof registerSchema>) => {
    registerMutation.mutate(values);
  };

  return (
    <div className="min-h-screen flex flex-col md:flex-row bg-neutral-50 overflow-hidden">
      {/* Left side with form */}
      <div className="flex items-center justify-center p-6 md:p-8 md:w-1/2">
        <Card className="w-full max-w-md bg-white rounded-xl shadow-lg border-0">
          <CardContent className="p-6 sm:p-8">
            <div className="text-center mb-8">
              <div className="w-16 h-16 mx-auto text-primary">
                <svg
                  className="w-full h-full"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path
                    fillRule="evenodd"
                    d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 14a6 6 0 100-12 6 6 0 000 12zm0-9a1 1 0 011 1v3a1 1 0 01-1 1H7a1 1 0 110-2h2V8a1 1 0 011-1z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
              <h1 className="mt-4 text-2xl font-bold text-neutral-800 bg-gradient-to-r from-primary to-primary/80 text-transparent bg-clip-text">
                {isLogin ? "Welcome Back" : "Join Prayer Pipeline"}
              </h1>
              <p className="mt-2 text-neutral-600">
                {isLogin
                  ? "Sign in to your account"
                  : "Create your account to get started"}
              </p>
            </div>

            {isLogin ? (
              <Form {...loginForm}>
                <form
                  onSubmit={loginForm.handleSubmit(onLoginSubmit)}
                  className="space-y-4"
                >
                  <FormField
                    control={loginForm.control}
                    name="username"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Username</FormLabel>
                        <FormControl>
                          <Input
                            placeholder="johndoe"
                            className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                            autoComplete="username"
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={loginForm.control}
                    name="password"
                    render={({ field }) => (
                      <FormItem>
                        <div className="flex justify-between items-center">
                          <FormLabel>Password</FormLabel>
                          <Button
                            variant="link"
                            className="text-xs text-primary hover:text-primary/80 pl-0 pr-0"
                            type="button"
                            onClick={() => setLocation("/forgot-password")}
                          >
                            Forgot password?
                          </Button>
                        </div>
                        <FormControl>
                          <Input
                            type="password"
                            placeholder="••••••••"
                            className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                            autoComplete="current-password"
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <Button
                    type="submit"
                    className="w-full bg-primary hover:bg-primary/90 mt-6"
                    disabled={loginMutation.isPending}
                  >
                    {loginMutation.isPending ? (
                      <div className="flex items-center justify-center">
                        <svg
                          className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
                          xmlns="http://www.w3.org/2000/svg"
                          fill="none"
                          viewBox="0 0 24 24"
                        >
                          <circle
                            className="opacity-25"
                            cx="12"
                            cy="12"
                            r="10"
                            stroke="currentColor"
                            strokeWidth="4"
                          ></circle>
                          <path
                            className="opacity-75"
                            fill="currentColor"
                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                          ></path>
                        </svg>
                        Signing In...
                      </div>
                    ) : (
                      "Sign In"
                    )}
                  </Button>
                </form>
              </Form>
            ) : (
              <Form {...registerForm}>
                <form
                  onSubmit={registerForm.handleSubmit(onRegisterSubmit)}
                  className="space-y-4"
                >
                  <div className="grid grid-cols-1 gap-4">
                    <FormField
                      control={registerForm.control}
                      name="name"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Full Name</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="John Doe"
                              className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                              autoComplete="name"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={registerForm.control}
                      name="email"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Email</FormLabel>
                          <FormControl>
                            <Input
                              type="text" // Changed from 'email' to avoid browser validation conflicting with Zod
                              inputMode="email"
                              placeholder="john@example.com"
                              className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                              autoComplete="email"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={registerForm.control}
                      name="phone"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Phone (optional)</FormLabel>
                          <FormControl>
                            <Input
                              type="tel"
                              inputMode="tel"
                              placeholder="(123) 456-7890"
                              className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                              autoComplete="tel"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={registerForm.control}
                      name="username"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Username</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="johndoe"
                              className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                              autoComplete="username"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={registerForm.control}
                      name="password"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Password</FormLabel>
                          <FormControl>
                            <Input
                              type="password"
                              placeholder="••••••••"
                              className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                              autoComplete="new-password"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={registerForm.control}
                      name="confirmPassword"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Confirm Password</FormLabel>
                          <FormControl>
                            <Input
                              type="password"
                              placeholder="••••••••"
                              className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                              autoComplete="new-password"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <Button
                    type="submit"
                    className="w-full bg-primary hover:bg-primary/90 mt-6"
                    disabled={registerMutation.isPending}
                  >
                    {registerMutation.isPending ? (
                      <div className="flex items-center justify-center">
                        <svg
                          className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
                          xmlns="http://www.w3.org/2000/svg"
                          fill="none"
                          viewBox="0 0 24 24"
                        >
                          <circle
                            className="opacity-25"
                            cx="12"
                            cy="12"
                            r="10"
                            stroke="currentColor"
                            strokeWidth="4"
                          ></circle>
                          <path
                            className="opacity-75"
                            fill="currentColor"
                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                          ></path>
                        </svg>
                        Creating Account...
                      </div>
                    ) : (
                      "Create Account"
                    )}
                  </Button>
                </form>
              </Form>
            )}

            <div className="mt-6 text-center">
              <p className="text-sm text-neutral-600">
                <span>
                  {isLogin
                    ? "Don't have an account?"
                    : "Already have an account?"}
                </span>
                <Button
                  variant="link"
                  onClick={() => setIsLogin(!isLogin)}
                  className="text-primary hover:text-primary/80 font-medium ml-1"
                >
                  {isLogin ? "Sign up" : "Sign in"}
                </Button>
              </p>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Right side hero section */}
      <div className="hidden md:flex md:w-1/2 bg-gradient-to-br from-primary to-primary/80 text-white">
        <div className="max-w-lg mx-auto flex flex-col justify-center p-8">
          <h2 className="text-3xl font-bold mb-4">Prayer Pipeline</h2>
          <p className="text-lg opacity-90 mb-6">
            A community platform to share prayer requests, track answers, and
            support one another in prayer.
          </p>
          <div className="space-y-4">
            <div className="flex items-start">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-6 w-6 mr-3 flex-shrink-0"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M5 13l4 4L19 7"
                />
              </svg>
              <p>Create and join prayer groups with friends and family</p>
            </div>
            <div className="flex items-start">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-6 w-6 mr-3 flex-shrink-0"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M5 13l4 4L19 7"
                />
              </svg>
              <p>Share prayer requests securely within your groups</p>
            </div>
            <div className="flex items-start">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-6 w-6 mr-3 flex-shrink-0"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M5 13l4 4L19 7"
                />
              </svg>
              <p>Track answers to prayer and celebrate God's faithfulness</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
```

## File: client/src/pages/explore-groups-page.tsx
```typescript
import Header from "@/components/header";
import MobileNav from "@/components/mobile-nav";
import CategoryGroups from "@/components/category-groups";
import CreateGroupModal from "@/components/create-group-modal";
import { Button } from "@/components/ui/button";
import { PlusIcon } from "lucide-react";
import { useState } from "react";
import { useOrganizations } from "@/hooks/use-organizations";

export default function ExploreGroupsPage() {
  const [createGroupOpen, setCreateGroupOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("explore");
  const { currentOrganization } = useOrganizations();

  const handleTabChange = (tab: string) => {
    setActiveTab(tab);
  };

  return (
    <div>
      <Header />

      <main className="pt-20 pb-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-8">
            <div>
              <h1 className="text-2xl font-bold font-heading text-neutral-800 mb-2">
                {activeTab === "explore" ? "Explore Prayer Groups" : "My Prayer Groups"}
              </h1>
              <p className="text-neutral-600">
                {activeTab === "explore" 
                  ? "Browse and join prayer groups organized by category" 
                  : "Manage your prayer groups and view activity"}
              </p>
            </div>
            <Button 
              className="mt-4 md:mt-0"
              onClick={() => setCreateGroupOpen(true)}
            >
              <PlusIcon className="h-4 w-4 mr-2" />
              Create New Group
            </Button>
          </div>

          <CategoryGroups 
            currentOrganizationId={currentOrganization?.id} 
            activeTab={activeTab}
            onChangeTab={handleTabChange}
          />
        </div>
      </main>

      <MobileNav active="explore" />
      <CreateGroupModal open={createGroupOpen} setOpen={setCreateGroupOpen} />
    </div>
  );
}
```

## File: client/src/pages/forgot-password-page.tsx
```typescript
import { useState } from "react";
import { useLocation } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { forgotPasswordSchema } from "@shared/schema";
import { z } from "zod";
import { useMutation } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

export default function ForgotPasswordPage() {
  const [success, setSuccess] = useState(false);
  const [_, setLocation] = useLocation();
  const { toast } = useToast();

  const forgotForm = useForm<z.infer<typeof forgotPasswordSchema>>({
    resolver: zodResolver(forgotPasswordSchema),
    defaultValues: {
      email: "",
    },
  });

  const forgotPasswordMutation = useMutation({
    mutationFn: async (data: z.infer<typeof forgotPasswordSchema>) => {
      const res = await apiRequest("POST", "/api/forgot-password", data);
      return await res.json();
    },
    onSuccess: (data) => {
      setSuccess(true);
      toast({
        title: "Reset email sent",
        description: "If your email is registered, you will receive a password reset link shortly.",
      });
      
      // For development only - show debug info with token
      if (data.debug && data.debug.token) {
        toast({
          title: "Development Mode",
          description: `Reset token: ${data.debug.token}`,
          variant: "default",
        });
      }
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: z.infer<typeof forgotPasswordSchema>) => {
    forgotPasswordMutation.mutate(data);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-neutral-50 p-4">
      <Card className="w-full max-w-md bg-white rounded-xl shadow-lg border-0">
        <CardContent className="p-6 sm:p-8">
          <div className="text-center mb-8">
            <div className="w-16 h-16 mx-auto text-primary">
              <svg
                className="w-full h-full"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 14a6 6 0 100-12 6 6 0 000 12zm-1-5a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1z"
                  clipRule="evenodd"
                />
              </svg>
            </div>
            <h1 className="mt-4 text-2xl font-bold text-neutral-800 bg-gradient-to-r from-primary to-primary/80 text-transparent bg-clip-text">
              {success ? "Check Your Email" : "Forgot Password"}
            </h1>
            <p className="mt-2 text-neutral-600">
              {success
                ? "We've sent a password reset link to your email address."
                : "Enter your email address to receive a password reset link"}
            </p>
          </div>

          {!success ? (
            <Form {...forgotForm}>
              <form
                onSubmit={forgotForm.handleSubmit(onSubmit)}
                className="space-y-4"
              >
                <FormField
                  control={forgotForm.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Email</FormLabel>
                      <FormControl>
                        <Input
                          type="email"
                          placeholder="your@email.com"
                          className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                          autoComplete="email"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <Button
                  type="submit"
                  className="w-full bg-primary hover:bg-primary/90 mt-6"
                  disabled={forgotPasswordMutation.isPending}
                >
                  {forgotPasswordMutation.isPending ? (
                    <div className="flex items-center justify-center">
                      <svg
                        className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                        ></circle>
                        <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                        ></path>
                      </svg>
                      Sending...
                    </div>
                  ) : (
                    "Send Reset Link"
                  )}
                </Button>
              </form>
            </Form>
          ) : (
            <div className="space-y-4">
              <p className="text-sm text-center text-neutral-600">
                Didn't receive an email? Check your spam folder or try again.
              </p>
              <Button
                className="w-full bg-primary hover:bg-primary/90"
                onClick={() => setSuccess(false)}
              >
                Try Again
              </Button>
            </div>
          )}

          <div className="mt-6 text-center">
            <p className="text-sm text-neutral-600">
              <span>Remember your password?</span>
              <Button
                variant="link"
                onClick={() => setLocation("/auth")}
                className="text-primary hover:text-primary/80 font-medium ml-1"
              >
                Sign in
              </Button>
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

## File: client/src/pages/group-details.tsx
```typescript
import { useState } from "react";
import { useParams, useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import Header from "@/components/header";
import MobileNav from "@/components/mobile-nav";
import PrayerCard from "@/components/prayer-card";
import CreateRequestModal from "@/components/create-request-modal";
import MeetingsTab from "@/components/meetings-tab";
import { useFavoriteGroups, FavoriteButton } from "@/hooks/use-favorite-groups";
import { ArrowLeft, PlusIcon, UserCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Skeleton } from "@/components/ui/skeleton";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Card,
  CardContent,
  CardFooter,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { insertGroupSchema } from "@shared/schema";

export default function GroupDetails() {
  const params = useParams<{ groupId: string }>();
  const groupId = params.groupId ? parseInt(params.groupId) : 0;
  const [_, navigate] = useLocation();
  const { user } = useAuth();
  const { toast } = useToast();
  const [createRequestOpen, setCreateRequestOpen] = useState(false);
  const [tab, setTab] = useState("prayer-requests");
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [leaveConfirmOpen, setLeaveConfirmOpen] = useState(false);

  // Get group details
  const {
    data: group,
    isLoading: isLoadingGroup,
  } = useQuery({
    queryKey: [`/api/groups/${groupId}`],
    enabled: !!groupId,
  });

  // Get prayer requests for this group
  const {
    data: requests,
    isLoading: isLoadingRequests,
  } = useQuery({
    queryKey: [`/api/groups/${groupId}/requests`],
    enabled: !!groupId,
  });

  // Get group members
  const {
    data: members,
    isLoading: isLoadingMembers,
  } = useQuery({
    queryKey: [`/api/groups/${groupId}/members`],
    enabled: !!groupId,
  });

  // Check if current user is leader
  const isLeader = members?.some(
    (member) => member.userId === user?.id && member.role === "leader"
  );

  // Check if current user is admin
  const isAdmin = user?.role === "admin";

  // Leave group mutation
  const leaveGroupMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/groups/${groupId}/leave`, {});
    },
    onSuccess: () => {
      toast({
        title: "Success",
        description: "You have left the group",
      });
      navigate("/");
      queryClient.invalidateQueries({ queryKey: ["/api/groups/user"] });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Delete group mutation
  const deleteGroupMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/groups/${groupId}`, {});
    },
    onSuccess: () => {
      toast({
        title: "Success",
        description: "Group has been deleted",
      });
      navigate("/");
      queryClient.invalidateQueries({ queryKey: ["/api/groups/user"] });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Group update form
  const groupForm = useForm<z.infer<typeof insertGroupSchema>>({
    resolver: zodResolver(insertGroupSchema.omit({ createdBy: true }).partial()),
    defaultValues: {
      name: group?.name || "",
      description: group?.description || "",
      privacy: group?.privacy || "request",
      leaderRotation: group?.leaderRotation || 0,
    },
    values: {
      name: group?.name || "",
      description: group?.description || "",
      privacy: group?.privacy || "request",
      leaderRotation: group?.leaderRotation || 0,
    },
  });

  // Define our update schema type
  const updateGroupSchema = insertGroupSchema.partial();
  type UpdateGroupInput = z.infer<typeof updateGroupSchema>;
  
  // Update group mutation
  const updateGroupMutation = useMutation({
    mutationFn: async (data: UpdateGroupInput): Promise<void> => {
      await apiRequest("PUT", `/api/groups/${groupId}`, data);
    },
    onSuccess: () => {
      toast({
        title: "Success",
        description: "Group settings updated",
      });
      queryClient.invalidateQueries({ queryKey: [`/api/groups/${groupId}`] });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onUpdateGroup = (data: UpdateGroupInput) => {
    updateGroupMutation.mutate(data);
  };

  return (
    <div>
      <Header />

      <main className="pt-20 pb-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="mb-6">
            <div className="flex items-center mb-2">
              <Button
                variant="ghost"
                size="icon"
                className="mr-2 text-neutral-600 hover:text-neutral-800"
                onClick={() => navigate("/")}
              >
                <ArrowLeft className="h-5 w-5" />
              </Button>
              <div className="flex items-center gap-2">
                <h2 className="text-2xl font-bold font-heading text-neutral-800">
                  {isLoadingGroup ? (
                    <Skeleton className="h-8 w-40" />
                  ) : (
                    group?.name
                  )}
                </h2>
                {!isLoadingGroup && group && <FavoriteGroupButton groupId={group.id} />}
              </div>
            </div>
            <p className="text-neutral-600">
              {isLoadingGroup ? (
                <Skeleton className="h-4 w-96" />
              ) : (
                group?.description
              )}
            </p>

            <div className="flex flex-wrap gap-2 mt-3">
              <div className="flex items-center px-3 py-1 bg-neutral-100 rounded-full text-sm text-neutral-700">
                <UserCircle className="h-4 w-4 mr-1" />
                <span>
                  {isLoadingMembers ? (
                    <Skeleton className="h-4 w-16 inline-block" />
                  ) : (
                    `${members?.length || 0} members`
                  )}
                </span>
              </div>
              <div className="flex items-center px-3 py-1 bg-neutral-100 rounded-full text-sm text-neutral-700">
                <svg
                  className="h-4 w-4 mr-1"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
                  />
                </svg>
                <span>
                  {isLoadingGroup ? (
                    <Skeleton className="h-4 w-24 inline-block" />
                  ) : (
                    `Created ${new Date(group?.createdAt).toLocaleDateString()}`
                  )}
                </span>
              </div>
              {!isLoadingMembers && (
                <div className="flex items-center px-3 py-1 bg-primary-100 rounded-full text-sm text-primary-700">
                  <svg
                    className="h-4 w-4 mr-1"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"
                    />
                  </svg>
                  <span>
                    Leader:{" "}
                    {members
                      ?.find((m) => m.role === "leader")
                      ?.user.name.split(" ")[0] || "Unassigned"}
                  </span>
                </div>
              )}
            </div>
          </div>

          <Tabs
            value={tab}
            onValueChange={setTab}
            className="w-full"
          >
            <TabsList className="mb-6 border-b border-neutral-200 w-full justify-start rounded-none bg-transparent p-0">
              <TabsTrigger
                value="prayer-requests"
                className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
              >
                Prayer Requests
              </TabsTrigger>
              <TabsTrigger
                value="meetings"
                className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
              >
                Meetings
              </TabsTrigger>
              <TabsTrigger
                value="members"
                className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
              >
                Members
              </TabsTrigger>
              {(isLeader || isAdmin) && (
                <TabsTrigger
                  value="settings"
                  className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
                >
                  Settings
                </TabsTrigger>
              )}
            </TabsList>

            <TabsContent value="prayer-requests" className="mt-0">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-medium font-heading text-neutral-800">
                  Prayer Requests
                </h3>
                <Button
                  onClick={() => setCreateRequestOpen(true)}
                  className="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition flex items-center text-sm"
                >
                  <PlusIcon className="h-4 w-4 mr-1" />
                  New Request
                </Button>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {isLoadingRequests ? (
                  <>
                    <Skeleton className="h-40 w-full" />
                    <Skeleton className="h-40 w-full" />
                    <Skeleton className="h-40 w-full" />
                    <Skeleton className="h-40 w-full" />
                  </>
                ) : requests?.length > 0 ? (
                  requests.map((request) => (
                    <PrayerCard
                      key={request.id}
                      request={request}
                      onClick={() => navigate(`/requests/${request.id}`)}
                    />
                  ))
                ) : (
                  <div className="col-span-full text-center py-12 bg-neutral-50 rounded-lg border border-neutral-200">
                    <p className="text-neutral-600 mb-4">
                      No prayer requests yet in this group.
                    </p>
                    <Button onClick={() => setCreateRequestOpen(true)}>
                      Create the First Prayer Request
                    </Button>
                  </div>
                )}
              </div>
            </TabsContent>

            <TabsContent value="meetings" className="mt-0">
              {group && <MeetingsTab group={group} isLeader={!!isLeader} />}
            </TabsContent>

            <TabsContent value="members" className="mt-0">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-medium font-heading text-neutral-800">
                  Members ({members?.length || 0})
                </h3>
                {(isLeader || isAdmin) && (
                  <Button className="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition flex items-center text-sm">
                    <PlusIcon className="h-4 w-4 mr-1" />
                    Invite Member
                  </Button>
                )}
              </div>

              <div className="bg-white rounded-lg shadow overflow-hidden">
                {isLoadingMembers ? (
                  <>
                    <div className="p-4 border-b border-neutral-100">
                      <Skeleton className="h-12 w-full" />
                    </div>
                    <div className="p-4 border-b border-neutral-100">
                      <Skeleton className="h-12 w-full" />
                    </div>
                    <div className="p-4 border-b border-neutral-100">
                      <Skeleton className="h-12 w-full" />
                    </div>
                  </>
                ) : (
                  members?.map((member, index) => (
                    <div
                      key={member.id}
                      className="p-4 border-b border-neutral-100 last:border-b-0"
                    >
                      <div className="flex items-center justify-between">
                        <div className="flex items-center">
                          <span className="h-10 w-10 rounded-full bg-primary-100 flex items-center justify-center text-primary-800 font-medium">
                            {member.user.name
                              .split(" ")
                              .map((n) => n[0])
                              .join("")
                              .substring(0, 2)}
                          </span>
                          <div className="ml-3">
                            <h4 className="font-medium text-neutral-800">
                              {member.user.name}
                            </h4>
                            <p className="text-xs text-neutral-500">
                              {new Date(member.joinedAt).toLocaleDateString()}
                            </p>
                          </div>
                        </div>
                        <div className="flex items-center">
                          <span
                            className={`${
                              member.role === "leader"
                                ? "bg-primary-100 text-primary-800"
                                : "bg-neutral-100 text-neutral-800"
                            } text-xs px-2 py-1 rounded`}
                          >
                            {member.role === "leader" ? "Leader" : "Member"}
                          </span>
                        </div>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </TabsContent>

            {(isLeader || isAdmin) && (
              <TabsContent value="settings" className="mt-0">
                <div className="mb-4">
                  <h3 className="text-lg font-medium font-heading text-neutral-800">
                    Group Settings
                  </h3>
                </div>

                <div className="bg-white rounded-lg shadow p-6">
                  <Form {...groupForm}>
                    <form
                      onSubmit={groupForm.handleSubmit(onUpdateGroup)}
                      className="space-y-4"
                    >
                      <FormField
                        control={groupForm.control}
                        name="name"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Group Name</FormLabel>
                            <FormControl>
                              <Input {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={groupForm.control}
                        name="description"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Description</FormLabel>
                            <FormControl>
                              <Textarea rows={3} {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={groupForm.control}
                        name="privacy"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Privacy Settings</FormLabel>
                            <Select
                              onValueChange={field.onChange}
                              defaultValue={field.value}
                              value={field.value}
                            >
                              <FormControl>
                                <SelectTrigger>
                                  <SelectValue placeholder="Select privacy setting" />
                                </SelectTrigger>
                              </FormControl>
                              <SelectContent>
                                <SelectItem value="open">
                                  Open (Anyone can join)
                                </SelectItem>
                                <SelectItem value="request">
                                  Request to Join
                                </SelectItem>
                                <SelectItem value="invite">
                                  Invite Only
                                </SelectItem>
                              </SelectContent>
                            </Select>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={groupForm.control}
                        name="leaderRotation"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Leadership Rotation</FormLabel>
                            <Select
                              onValueChange={(val) =>
                                field.onChange(parseInt(val))
                              }
                              defaultValue={field.value.toString()}
                              value={field.value.toString()}
                            >
                              <FormControl>
                                <SelectTrigger>
                                  <SelectValue placeholder="Select leadership rotation" />
                                </SelectTrigger>
                              </FormControl>
                              <SelectContent>
                                <SelectItem value="0">
                                  No Rotation (Fixed Leader)
                                </SelectItem>
                                <SelectItem value="30">
                                  Rotate Every 30 Days
                                </SelectItem>
                                <SelectItem value="60">
                                  Rotate Every 60 Days
                                </SelectItem>
                                <SelectItem value="90">
                                  Rotate Every 90 Days
                                </SelectItem>
                              </SelectContent>
                            </Select>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <div className="flex justify-end gap-2 mt-6">
                        <Button
                          type="button"
                          variant="outline"
                          onClick={() =>
                            groupForm.reset({
                              name: group?.name,
                              description: group?.description,
                              privacy: group?.privacy,
                              leaderRotation: group?.leaderRotation,
                            })
                          }
                        >
                          Cancel
                        </Button>
                        <Button
                          type="submit"
                          disabled={updateGroupMutation.isPending}
                        >
                          {updateGroupMutation.isPending ? (
                            <div className="flex items-center">
                              <svg
                                className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
                                xmlns="http://www.w3.org/2000/svg"
                                fill="none"
                                viewBox="0 0 24 24"
                              >
                                <circle
                                  className="opacity-25"
                                  cx="12"
                                  cy="12"
                                  r="10"
                                  stroke="currentColor"
                                  strokeWidth="4"
                                ></circle>
                                <path
                                  className="opacity-75"
                                  fill="currentColor"
                                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                                ></path>
                              </svg>
                              Saving...
                            </div>
                          ) : (
                            "Save Changes"
                          )}
                        </Button>
                      </div>
                    </form>
                  </Form>
                </div>

                <div className="mt-8 p-6 bg-red-50 border border-red-200 rounded-lg">
                  <h4 className="text-red-800 font-medium mb-2">Danger Zone</h4>
                  <p className="text-sm text-red-700 mb-4">
                    These actions cannot be undone. Please be certain.
                  </p>
                  <div className="flex gap-4">
                    <Button
                      variant="outline"
                      className="border-red-300 text-red-700 hover:bg-red-100"
                      onClick={() => setLeaveConfirmOpen(true)}
                    >
                      Leave Group
                    </Button>
                    {isAdmin && (
                      <Button
                        className="bg-red-600 text-white hover:bg-red-700"
                        onClick={() => setDeleteConfirmOpen(true)}
                      >
                        Delete Group
                      </Button>
                    )}
                  </div>
                </div>
              </TabsContent>
            )}
          </Tabs>
        </div>
      </main>

      <MobileNav active="groups" />
      <CreateRequestModal 
        open={createRequestOpen} 
        setOpen={setCreateRequestOpen} 
        defaultGroupId={groupId}
      />

      {/* Leave Group Confirmation */}
      <AlertDialog open={leaveConfirmOpen} onOpenChange={setLeaveConfirmOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Leave Group</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to leave this group? You'll need to be invited back to rejoin.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => leaveGroupMutation.mutate()}
              className="bg-red-600 text-white hover:bg-red-700"
            >
              {leaveGroupMutation.isPending ? "Leaving..." : "Leave Group"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Delete Group Confirmation */}
      <AlertDialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Group</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this group? This action cannot be undone and will remove all prayer requests and comments.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => deleteGroupMutation.mutate()}
              className="bg-red-600 text-white hover:bg-red-700"
            >
              {deleteGroupMutation.isPending ? "Deleting..." : "Delete Group"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

// FavoriteGroupButton component to handle favorite status for a group
function FavoriteGroupButton({ groupId }: { groupId: number }) {
  const { isFavorite, toggleFavorite, isPendingAdd, isPendingRemove } = useFavoriteGroups();
  const isGroupFavorite = isFavorite(groupId);
  const isPending = isPendingAdd || isPendingRemove;

  return (
    <FavoriteButton 
      groupId={groupId}
      isFavorite={isGroupFavorite}
      isLoading={isPending}
      onToggle={() => toggleFavorite(groupId, isGroupFavorite)}
      size="default"
    />
  );
}
```

## File: client/src/pages/home-page.tsx
```typescript
import { useQuery } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { useOrganizations } from "@/hooks/use-organizations";
// import { useFavoriteGroups } from "@/hooks/use-favorite-groups";
import Header from "@/components/header";
import PrayerCard from "@/components/prayer-card";
import GroupCard from "@/components/group-card";
import GroupsList from "@/components/groups-list";
import MobileNav from "@/components/mobile-nav";
import CreateGroupModal from "@/components/create-group-modal";
import CreateRequestModal from "@/components/create-request-modal";
import { Skeleton } from "@/components/ui/skeleton";
import { Button } from "@/components/ui/button";
import { useState } from "react";
import { PlusIcon } from "lucide-react";
import { Group, PrayerRequest, Notification } from "@shared/schema";

export default function HomePage() {
  const { user } = useAuth();
  const { currentOrganization } = useOrganizations();
  const [_, navigate] = useLocation();
  const [createGroupOpen, setCreateGroupOpen] = useState(false);
  const [createRequestOpen, setCreateRequestOpen] = useState(false);

  // Fetch recent prayer requests
  const {
    data: recentRequests = [],
    isLoading: isLoadingRequests,
  } = useQuery<PrayerRequest[]>({
    queryKey: ["/api/requests/user/recent", currentOrganization?.id],
    queryFn: () => {
      if (!currentOrganization) return Promise.resolve([]);
      return fetch(`/api/requests/user/recent?organizationId=${currentOrganization.id}`)
        .then(res => {
          if (!res.ok) throw new Error('Failed to fetch recent prayer requests');
          return res.json();
        });
    },
    enabled: !!currentOrganization,
  });

  // Fetch organization groups
  const {
    data: userGroups = [],
    isLoading: isLoadingGroups,
  } = useQuery<Group[]>({
    queryKey: ["/api/groups/user", currentOrganization?.id],
    enabled: !!currentOrganization,
  });

  // Fetch user stats (would be better to have a dedicated endpoint for this)
  const {
    data: notifications = [],
    isLoading: isLoadingNotifications
  } = useQuery<Notification[]>({
    queryKey: ["/api/notifications"],
  });

  return (
    <div>
      <Header />

      <main className="pt-20 pb-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="text-center md:text-left mb-8">
            <h2 className="text-2xl font-bold font-heading text-neutral-800">
              Welcome back, <span>{user?.name?.split(" ")[0]}</span>
            </h2>
            <p className="text-neutral-600 mt-1">
              "For where two or three gather in my name, there am I with them." - Matthew 18:20
            </p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {/* First column - Your Groups */}
            <div>
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium font-heading text-neutral-800">Your Groups</h3>
                <Button 
                  size="sm"
                  variant="ghost"
                  className="text-primary hover:text-primary/90 font-medium"
                  onClick={() => setCreateGroupOpen(true)}
                >
                  <PlusIcon className="h-4 w-4 mr-1" />
                  New Group
                </Button>
              </div>

              <div className="space-y-4">
                {isLoadingGroups ? (
                  <>
                    <Skeleton className="h-32 w-full rounded-lg" />
                    <Skeleton className="h-32 w-full rounded-lg" />
                  </>
                ) : userGroups?.length > 0 ? (
                  <>
                    <GroupsList 
                      groups={userGroups} 
                      onGroupClick={(groupId) => navigate(`/groups/${groupId}`)} 
                      maxShown={5}
                    />
                  </>
                ) : (
                  <div className="text-center py-8 bg-neutral-50 rounded-lg border border-neutral-200">
                    <p className="text-neutral-600 mb-4">You haven't joined any groups yet.</p>
                    <Button onClick={() => setCreateGroupOpen(true)}>
                      Create Your First Group
                    </Button>
                  </div>
                )}
              </div>
            </div>

            {/* Second column - Recent Prayer Requests */}
            <div>
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium font-heading text-neutral-800">Recent Prayer Requests</h3>
                <Button 
                  size="sm"
                  variant="ghost"
                  className="text-primary hover:text-primary/90 font-medium"
                  onClick={() => setCreateRequestOpen(true)}
                >
                  <PlusIcon className="h-4 w-4 mr-1" />
                  New Request
                </Button>
              </div>

              <div className="space-y-4">
                {isLoadingRequests ? (
                  <>
                    <Skeleton className="h-40 w-full rounded-lg" />
                    <Skeleton className="h-40 w-full rounded-lg" />
                  </>
                ) : recentRequests?.length > 0 ? (
                  <>
                    {/* Display all recent prayer requests (already limited to 5 on the server) */}
                    {recentRequests.map((request) => (
                      <PrayerCard 
                        key={request.id} 
                        request={request} 
                        onClick={() => navigate(`/requests/${request.id}`)}
                      />
                    ))}
                  </>
                ) : (
                  <div className="text-center py-8 bg-neutral-50 rounded-lg border border-neutral-200">
                    <p className="text-neutral-600 mb-4">No prayer requests yet.</p>
                    <Button onClick={() => setCreateRequestOpen(true)}>
                      Create Your First Prayer Request
                    </Button>
                  </div>
                )}
              </div>
            </div>

            {/* Third column - My Prayer Journey */}
            <div>
              <div className="mb-4">
                <h3 className="text-lg font-medium font-heading text-neutral-800">My Prayer Journey</h3>
              </div>

              <div className="bg-white rounded-lg shadow p-4">
                <div className="flex justify-between mb-4">
                  <h4 className="font-medium text-neutral-700">Prayer Statistics</h4>
                </div>
                
                <div className="grid grid-cols-3 gap-2 mb-6">
                  <div className="text-center p-2 bg-neutral-50 rounded-lg">
                    <div className="text-2xl font-bold text-primary">
                      {isLoadingRequests ? (
                        <Skeleton className="h-8 w-8 mx-auto rounded" />
                      ) : (
                        recentRequests?.length || 0
                      )}
                    </div>
                    <div className="text-xs text-neutral-600 mt-1">Requests Made</div>
                  </div>
                  <div className="text-center p-2 bg-neutral-50 rounded-lg">
                    <div className="text-2xl font-bold text-green-500">
                      {isLoadingRequests ? (
                        <Skeleton className="h-8 w-8 mx-auto rounded" />
                      ) : (
                        recentRequests?.filter(r => r.status === "answered").length || 0
                      )}
                    </div>
                    <div className="text-xs text-neutral-600 mt-1">Prayers Answered</div>
                  </div>
                  <div className="text-center p-2 bg-neutral-50 rounded-lg">
                    <div className="text-2xl font-bold text-amber-500">
                      {isLoadingNotifications ? (
                        <Skeleton className="h-8 w-8 mx-auto rounded" />
                      ) : (
                        notifications?.length || 0
                      )}
                    </div>
                    <div className="text-xs text-neutral-600 mt-1">Notifications</div>
                  </div>
                </div>

                <div className="mb-4">
                  <h4 className="font-medium text-neutral-700 mb-2">Daily Scripture</h4>
                  <div className="bg-primary-50 rounded-lg p-4">
                    <p className="text-neutral-800 italic text-sm">
                      "Do not be anxious about anything, but in every situation, by prayer and petition, with thanksgiving, present your requests to God."
                    </p>
                    <p className="text-neutral-600 text-xs mt-2 text-right">
                      - Philippians 4:6
                    </p>
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-neutral-700 mb-2">Prayer Reminders</h4>
                  <div className="space-y-2">
                    <div className="flex items-center justify-between p-2 rounded-lg border border-neutral-200">
                      <div className="flex items-center">
                        <span className="h-6 w-6 bg-primary-100 rounded-full text-xs flex items-center justify-center text-primary-800">M</span>
                        <span className="ml-2 text-sm text-neutral-700">Morning Prayer</span>
                      </div>
                      <span className="text-xs text-neutral-500">7:00 AM</span>
                    </div>
                    <div className="flex items-center justify-between p-2 rounded-lg border border-neutral-200">
                      <div className="flex items-center">
                        <span className="h-6 w-6 bg-green-100 rounded-full text-xs flex items-center justify-center text-green-800">E</span>
                        <span className="ml-2 text-sm text-neutral-700">Evening Reflection</span>
                      </div>
                      <span className="text-xs text-neutral-500">9:00 PM</span>
                    </div>
                  </div>
                  <Button 
                    variant="outline"
                    className="mt-3 text-center w-full border border-neutral-200 rounded-lg py-2 text-sm text-neutral-600 hover:bg-neutral-50 transition-colors"
                  >
                    Add Reminder
                  </Button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>

      <MobileNav active="home" />
      <CreateGroupModal open={createGroupOpen} setOpen={setCreateGroupOpen} />
      <CreateRequestModal open={createRequestOpen} setOpen={setCreateRequestOpen} />
    </div>
  );
}
```

## File: client/src/pages/meeting-details.tsx
```typescript
import { useState, useEffect } from "react";
import { useParams, Link } from "wouter";
import { Meeting } from "@shared/schema";
import { useMeetings } from "@/hooks/use-meetings";
import { useMeetingNotes } from "@/hooks/use-meeting-notes";
import { useToast } from "@/hooks/use-toast";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Textarea } from "@/components/ui/textarea";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Loader2, ArrowLeft, Edit, ExternalLink, Trash2, Video, Calendar, Clock, Users, FileEdit } from "lucide-react";
import { format } from "date-fns";
import { useAuth } from "@/hooks/use-auth";
import { useQuery } from "@tanstack/react-query";

// Custom hook for getting a single meeting
function useMeeting(meetingId: number) {
  const { toast } = useToast();
  const { 
    updateMeeting: updateMeetingBase, 
    isUpdatingMeeting,
    deleteMeeting: deleteMeetingBase,
    isDeletingMeeting
  } = useMeetings();

  const {
    data: meeting,
    isLoading: isLoadingMeeting,
    error: meetingError
  } = useQuery<Meeting>({
    queryKey: ['/api/meetings', meetingId],
    enabled: !!meetingId,
  });

  return {
    meeting,
    isLoadingMeeting,
    meetingError,
    updateMeeting: updateMeetingBase,
    isUpdatingMeeting,
    deleteMeeting: deleteMeetingBase,
    isDeletingMeeting
  };
}

export default function MeetingDetails() {
  const { meetingId } = useParams<{ meetingId: string }>();
  const { user } = useAuth();
  const { toast } = useToast();
  const [tabValue, setTabValue] = useState<string>("details");
  const [isAddingNote, setIsAddingNote] = useState(false);
  const [isEditingMeeting, setIsEditingMeeting] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const {
    meeting,
    isLoadingMeeting,
    updateMeeting,
    isUpdatingMeeting,
    deleteMeeting,
    isDeletingMeeting,
  } = useMeeting(Number(meetingId));

  const {
    notes: meetingNotes,
    isLoadingNotes: isLoadingMeetingNotes,
    createNotes: addMeetingNote,
    isCreatingNotes: isAddingMeetingNote,
  } = useMeetingNotes(Number(meetingId));

  // Create schema and form for adding notes
  const noteFormSchema = z.object({
    content: z.string().min(1, "Note content is required"),
    summary: z.string().optional(),
  });
  
  type NoteFormValues = z.infer<typeof noteFormSchema>;
  
  const noteForm = useForm<NoteFormValues>({
    resolver: zodResolver(noteFormSchema),
    defaultValues: {
      content: "",
      summary: "",
    },
  });

  // Create schema and form for editing meeting
  const meetingFormSchema = z.object({
    title: z.string().min(1, "Title is required"),
    description: z.string().optional().nullable(),
    meetingLink: z.string().min(1, "Meeting link is required"),
    startTime: z.date(),
    endTime: z.date().optional().nullable(),
  });
  
  type MeetingFormValues = z.infer<typeof meetingFormSchema>;

  const meetingForm = useForm<MeetingFormValues>({
    resolver: zodResolver(meetingFormSchema),
    defaultValues: {
      title: meeting?.title || "",
      description: meeting?.description || "",
      meetingLink: meeting?.meetingLink || "",
      startTime: meeting ? new Date(meeting.startTime) : new Date(),
      endTime: meeting?.endTime ? new Date(meeting.endTime) : null,
    },
  });

  // Update form values when meeting data loads
  useEffect(() => {
    if (meeting) {
      meetingForm.reset({
        title: meeting.title,
        description: meeting.description,
        meetingLink: meeting.meetingLink,
        startTime: new Date(meeting.startTime),
        endTime: meeting.endTime ? new Date(meeting.endTime) : null,
      });
    }
  }, [meeting, meetingForm]);

  // Handle adding a new note
  const handleAddNote = (data: NoteFormValues) => {
    addMeetingNote({
      meetingId: Number(meetingId),
      content: data.content,
      summary: data.summary || null,
      isAiGenerated: false,
    }, {
      onSuccess: () => {
        setIsAddingNote(false);
        noteForm.reset();
        toast({
          title: "Note added",
          description: "Your note has been added successfully.",
        });
      },
      onError: (error: Error) => {
        toast({
          title: "Error adding note",
          description: error.message,
          variant: "destructive",
        });
      },
    });
  };

  // Handle updating the meeting
  const handleUpdateMeeting = (data: MeetingFormValues) => {
    if (!meeting) return;
    
    updateMeeting({
      meetingId: meeting.id,
      data,
    }, {
      onSuccess: () => {
        setIsEditingMeeting(false);
        toast({
          title: "Meeting updated",
          description: "The meeting has been updated successfully.",
        });
      },
      onError: (error: Error) => {
        toast({
          title: "Error updating meeting",
          description: error.message,
          variant: "destructive",
        });
      },
    });
  };

  // Handle deleting the meeting
  const handleDeleteMeeting = () => {
    if (!meeting) return;
    
    deleteMeeting(meeting.id, {
      onSuccess: () => {
        toast({
          title: "Meeting deleted",
          description: "The meeting has been deleted successfully.",
        });
        // Navigate back to the group page
        window.location.href = `/groups/${meeting.groupId}`;
      },
      onError: (error: Error) => {
        setIsDeleting(false);
        toast({
          title: "Error deleting meeting",
          description: error.message,
          variant: "destructive",
        });
      },
    });
  };

  if (isLoadingMeeting) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[400px]">
        <Loader2 className="h-10 w-10 animate-spin text-primary mb-4" />
        <p className="text-neutral-600">Loading meeting details...</p>
      </div>
    );
  }

  if (!meeting) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[400px]">
        <p className="text-neutral-600 mb-4">Meeting not found</p>
        <Button asChild>
          <Link href="/">Go back home</Link>
        </Button>
      </div>
    );
  }

  // Check if user is a leader of the group
  const isLeader = user?.id === meeting.createdBy;

  // Format meeting date and times
  const meetingDate = format(new Date(meeting.startTime), "EEEE, MMMM d, yyyy");
  const startTime = format(new Date(meeting.startTime), "h:mm a");
  const endTime = meeting.endTime ? format(new Date(meeting.endTime), "h:mm a") : "TBD";

  return (
    <div className="container max-w-5xl py-6">
      {/* Back button and header */}
      <div className="mb-6">
        <Button
          variant="ghost"
          size="sm"
          asChild
          className="mb-2"
        >
          <Link href={`/groups/${meeting.groupId}`}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Group
          </Link>
        </Button>
        <div className="flex justify-between items-start">
          <h1 className="text-2xl md:text-3xl font-bold">{meeting.title}</h1>
          {isLeader && (
            <div className="flex space-x-2">
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => setIsEditingMeeting(true)}
              >
                <Edit className="h-4 w-4 mr-2" />
                Edit
              </Button>
              <AlertDialog open={isDeleting} onOpenChange={setIsDeleting}>
                <AlertDialogTrigger asChild>
                  <Button variant="destructive" size="sm">
                    <Trash2 className="h-4 w-4 mr-2" />
                    Delete
                  </Button>
                </AlertDialogTrigger>
                <AlertDialogContent>
                  <AlertDialogHeader>
                    <AlertDialogTitle>Confirm Deletion</AlertDialogTitle>
                    <AlertDialogDescription>
                      Are you sure you want to delete this meeting? This action cannot be undone.
                    </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                    <AlertDialogCancel disabled={isDeletingMeeting}>Cancel</AlertDialogCancel>
                    <AlertDialogAction
                      onClick={handleDeleteMeeting}
                      disabled={isDeletingMeeting}
                      className="bg-red-500 hover:bg-red-600"
                    >
                      {isDeletingMeeting ? "Deleting..." : "Delete Meeting"}
                    </AlertDialogAction>
                  </AlertDialogFooter>
                </AlertDialogContent>
              </AlertDialog>
            </div>
          )}
        </div>
      </div>

      {/* Meeting Tabs */}
      <Tabs
        value={tabValue}
        onValueChange={setTabValue}
        className="w-full"
      >
        <TabsList className="mb-6 border-b border-neutral-200 w-full justify-start rounded-none bg-transparent p-0">
          <TabsTrigger
            value="details"
            className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
          >
            Details
          </TabsTrigger>
          <TabsTrigger
            value="notes"
            className="rounded-none border-b-2 border-transparent px-4 py-2 data-[state=active]:border-primary data-[state=active]:bg-transparent data-[state=active]:shadow-none data-[state=active]:text-primary"
          >
            Notes
          </TabsTrigger>
        </TabsList>

        {/* Meeting Details Tab */}
        <TabsContent value="details" className="mt-0">
          <Card>
            <CardHeader className="pb-2">
              <CardTitle>Meeting Information</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Meeting Type Badge */}
              <div className="flex items-center">
                <Badge variant="outline" className="flex items-center bg-primary/10 text-primary">
                  <Video className="h-3 w-3 mr-1" />
                  {meeting.meetingType === "zoom" ? "Zoom Meeting" : "Google Meet"}
                </Badge>
              </div>

              {/* Date & Time */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="flex items-start">
                  <Calendar className="h-5 w-5 text-neutral-500 mr-2 mt-0.5" />
                  <div>
                    <p className="text-sm text-neutral-500">Date</p>
                    <p className="font-medium">{meetingDate}</p>
                  </div>
                </div>
                <div className="flex items-start">
                  <Clock className="h-5 w-5 text-neutral-500 mr-2 mt-0.5" />
                  <div>
                    <p className="text-sm text-neutral-500">Time</p>
                    <p className="font-medium">{startTime} - {endTime}</p>
                  </div>
                </div>
              </div>

              {/* Meeting Link */}
              <div>
                <p className="text-sm text-neutral-500 mb-1">Meeting Link</p>
                <a 
                  href={meeting.meetingLink} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="text-primary hover:underline flex items-center"
                >
                  {meeting.meetingLink}
                  <ExternalLink className="h-4 w-4 ml-1" />
                </a>
              </div>

              {/* Description */}
              {meeting.description && (
                <div>
                  <p className="text-sm text-neutral-500 mb-1">Description</p>
                  <p className="whitespace-pre-line">{meeting.description}</p>
                </div>
              )}

              {/* Created by */}
              <div className="pt-2">
                <p className="text-xs text-neutral-500 mb-2">Created by:</p>
                <div className="flex items-center">
                  <Avatar className="h-6 w-6 mr-2">
                    <AvatarImage src={`https://api.dicebear.com/7.x/initials/svg?seed=${meeting.createdBy}`} />
                    <AvatarFallback>U</AvatarFallback>
                  </Avatar>
                  <span className="text-sm">User {meeting.createdBy}</span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Edit Meeting Form */}
          {isEditingMeeting && (
            <div className="mt-6">
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle>Edit Meeting</CardTitle>
                </CardHeader>
                <CardContent>
                  <Form {...meetingForm}>
                    <form onSubmit={meetingForm.handleSubmit(handleUpdateMeeting)} className="space-y-4">
                      <FormField
                        control={meetingForm.control}
                        name="title"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Title</FormLabel>
                            <FormControl>
                              <input
                                className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                                placeholder="Meeting title"
                                {...field}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <FormField
                        control={meetingForm.control}
                        name="description"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Description</FormLabel>
                            <FormControl>
                              <Textarea
                                placeholder="Meeting description"
                                className="resize-none min-h-[100px]"
                                {...field}
                                value={field.value || ""}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <FormField
                        control={meetingForm.control}
                        name="meetingLink"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Meeting Link</FormLabel>
                            <FormControl>
                              <input
                                className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                                placeholder="Meeting link"
                                {...field}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <FormField
                          control={meetingForm.control}
                          name="startTime"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Start Time</FormLabel>
                              <FormControl>
                                <input
                                  type="datetime-local"
                                  className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                                  {...field}
                                  value={field.value ? new Date(field.value.getTime() - field.value.getTimezoneOffset() * 60000).toISOString().slice(0, 16) : ""}
                                  onChange={(e) => {
                                    field.onChange(e.target.value ? new Date(e.target.value) : null);
                                  }}
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={meetingForm.control}
                          name="endTime"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>End Time</FormLabel>
                              <FormControl>
                                <input
                                  type="datetime-local"
                                  className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                                  {...field}
                                  value={field.value ? new Date(field.value.getTime() - field.value.getTimezoneOffset() * 60000).toISOString().slice(0, 16) : ""}
                                  onChange={(e) => {
                                    field.onChange(e.target.value ? new Date(e.target.value) : null);
                                  }}
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>
                      
                      <div className="flex justify-end space-x-2 pt-2">
                        <Button
                          type="button"
                          variant="outline"
                          onClick={() => setIsEditingMeeting(false)}
                          disabled={isUpdatingMeeting}
                        >
                          Cancel
                        </Button>
                        <Button type="submit" disabled={isUpdatingMeeting}>
                          {isUpdatingMeeting ? (
                            <>
                              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                              Updating...
                            </>
                          ) : (
                            <>Save Changes</>
                          )}
                        </Button>
                      </div>
                    </form>
                  </Form>
                </CardContent>
              </Card>
            </div>
          )}
        </TabsContent>

        {/* Meeting Notes Tab */}
        <TabsContent value="notes" className="mt-0">
          <div className="space-y-6">
            {/* Add Note Button */}
            {!isAddingNote && (
              <div className="flex justify-end">
                <Button 
                  onClick={() => setIsAddingNote(true)}
                  className="flex items-center"
                >
                  <FileEdit className="h-4 w-4 mr-2" />
                  Add Note
                </Button>
              </div>
            )}

            {/* Add Note Form */}
            {isAddingNote && (
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle>Add Meeting Note</CardTitle>
                </CardHeader>
                <CardContent>
                  <Form {...noteForm}>
                    <form onSubmit={noteForm.handleSubmit(handleAddNote)} className="space-y-4">
                      <FormField
                        control={noteForm.control}
                        name="content"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Note Content</FormLabel>
                            <FormControl>
                              <Textarea
                                placeholder="Enter your meeting notes here..."
                                className="resize-none min-h-[150px]"
                                {...field}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <FormField
                        control={noteForm.control}
                        name="summary"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Summary (Optional)</FormLabel>
                            <FormControl>
                              <Textarea
                                placeholder="Provide a brief summary of the notes..."
                                className="resize-none"
                                {...field}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <div className="flex justify-end space-x-2 pt-2">
                        <Button
                          type="button"
                          variant="outline"
                          onClick={() => setIsAddingNote(false)}
                          disabled={isAddingMeetingNote}
                        >
                          Cancel
                        </Button>
                        <Button type="submit" disabled={isAddingMeetingNote}>
                          {isAddingMeetingNote ? (
                            <>
                              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                              Adding...
                            </>
                          ) : (
                            <>Add Note</>
                          )}
                        </Button>
                      </div>
                    </form>
                  </Form>
                </CardContent>
              </Card>
            )}

            {/* Meeting Notes List */}
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Meeting Notes</h3>
              
              {isLoadingMeetingNotes ? (
                <div className="flex items-center justify-center py-10">
                  <Loader2 className="h-6 w-6 animate-spin text-primary" />
                </div>
              ) : meetingNotes.length > 0 ? (
                meetingNotes.map((note) => (
                  <Card key={note.id} className={note.isAiGenerated ? "border-primary/20 bg-primary/5" : ""}>
                    <CardContent className="pt-6">
                      {note.isAiGenerated && (
                        <Badge className="mb-2 bg-primary/20 text-primary border-primary/20">
                          AI Generated
                        </Badge>
                      )}
                      
                      {note.summary && (
                        <>
                          <div className="font-medium mb-2">{note.summary}</div>
                          <Separator className="my-3" />
                        </>
                      )}
                      
                      <div className="whitespace-pre-line text-sm">{note.content}</div>
                      
                      <div className="mt-4 text-xs text-neutral-500">
                        Added on {format(new Date(note.createdAt), "MMM d, yyyy 'at' h:mm a")}
                      </div>
                    </CardContent>
                  </Card>
                ))
              ) : (
                <div className="text-center py-12 bg-neutral-50 rounded-lg border border-neutral-200">
                  <FileEdit className="h-10 w-10 mx-auto text-neutral-400 mb-2" />
                  <p className="text-neutral-600">
                    No notes have been added for this meeting yet.
                  </p>
                </div>
              )}
            </div>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

## File: client/src/pages/not-found.tsx
```typescript
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
```

## File: client/src/pages/organization-details-page.tsx
```typescript
import { useState, useEffect } from "react";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { useOrganizations } from "@/hooks/use-organizations";
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, getQueryFn, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Organization, OrganizationMember, Group } from "@shared/schema";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import { Textarea } from "@/components/ui/textarea";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Building,
  Users,
  Settings,
  Pencil,
  UserPlus,
  Shield,
  User,
  XCircle,
  ChevronLeft,
  Loader2,
} from "lucide-react";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { formatDistanceToNow } from "date-fns";

const inviteFormSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
  role: z.enum(["member", "admin"]),
});

type InviteFormValues = z.infer<typeof inviteFormSchema>;

export default function OrganizationDetailsPage() {
  const [_, navigate] = useLocation();
  const { toast } = useToast();
  const { user } = useAuth();
  const orgIdParam = window.location.pathname.split("/").pop();
  const organizationId = orgIdParam ? parseInt(orgIdParam) : 0;
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [inviteDialogOpen, setInviteDialogOpen] = useState(false);
  
  const { 
    organizations,
    organizationMembers,
    isLoadingMembers,
    updateOrganizationMutation,
    inviteMemberMutation,
    removeMemberMutation
  } = useOrganizations();

  // Get the current organization
  const organization = organizations.find(org => org.id === organizationId);

  // Fetch groups for the organization
  const {
    data: groups = [],
    isLoading: isLoadingGroups,
  } = useQuery<Group[], Error>({
    queryKey: ["/api/organizations/groups", organizationId],
    queryFn: getQueryFn({ on401: "throw" }),
    enabled: !!organizationId,
  });

  // Form for organization editing
  const editForm = useForm({
    defaultValues: {
      name: organization?.name || "",
      description: organization?.description || "",
    },
  });

  // Form for inviting members
  const inviteForm = useForm<InviteFormValues>({
    resolver: zodResolver(inviteFormSchema),
    defaultValues: {
      email: "",
      role: "member",
    },
  });

  // Update form when organization data changes
  useEffect(() => {
    if (organization) {
      editForm.reset({
        name: organization.name,
        description: organization.description || "",
      });
    }
  }, [organization, editForm]);

  // Handle organization update
  const handleUpdateOrganization = async (data: { name: string; description: string }) => {
    if (!organization) return;
    
    await updateOrganizationMutation.mutateAsync({
      id: organization.id,
      data,
    });
    
    setEditDialogOpen(false);
  };

  // Handle member invitation
  const handleInviteMember = async (data: InviteFormValues) => {
    if (!organizationId) return;
    
    await inviteMemberMutation.mutateAsync({
      organizationId,
      email: data.email,
      role: data.role,
    });
    
    inviteForm.reset();
    setInviteDialogOpen(false);
  };

  // Handle member removal
  const handleRemoveMember = async (userId: number) => {
    if (!organizationId) return;
    
    await removeMemberMutation.mutateAsync({
      organizationId,
      userId,
    });
  };

  // Check if the current user is an admin
  const currentMember = organizationMembers.find(m => m.userId === user?.id);
  const isAdmin = currentMember?.role === "admin";

  if (!organization) {
    return (
      <div className="container max-w-7xl py-10 pt-16 md:pt-24">
        <div className="flex items-center mb-8">
          <Button variant="ghost" className="mr-2" onClick={() => navigate("/organizations")}>
            <ChevronLeft className="h-4 w-4 mr-1" />
            Back
          </Button>
          <h1 className="text-3xl font-bold tracking-tight">Organization not found</h1>
        </div>
        <p>The organization you are looking for does not exist or you don't have access.</p>
      </div>
    );
  }

  return (
    <div className="container max-w-7xl py-10 pt-16 md:pt-24">
      <div className="flex items-center mb-8">
        <Button variant="ghost" className="mr-2" onClick={() => navigate("/organizations")}>
          <ChevronLeft className="h-4 w-4 mr-1" />
          Back
        </Button>
        <div>
          <h1 className="text-3xl font-bold tracking-tight flex items-center">
            {organization.name}
            {isAdmin && (
              <Button 
                variant="ghost" 
                size="sm" 
                className="ml-2" 
                onClick={() => setEditDialogOpen(true)}
              >
                <Pencil className="h-4 w-4" />
              </Button>
            )}
          </h1>
          <p className="text-muted-foreground mt-1">
            {organization.description || "No description provided"}
          </p>
        </div>
      </div>

      <Tabs defaultValue="members" className="space-y-6">
        <TabsList>
          <TabsTrigger value="members">
            <Users className="h-4 w-4 mr-2" />
            Members
          </TabsTrigger>
          <TabsTrigger value="groups">
            <Building className="h-4 w-4 mr-2" />
            Groups
          </TabsTrigger>
          {isAdmin && (
            <TabsTrigger value="settings">
              <Settings className="h-4 w-4 mr-2" />
              Settings
            </TabsTrigger>
          )}
        </TabsList>

        <TabsContent value="members" className="space-y-4">
          <div className="flex justify-between items-center">
            <h2 className="text-xl font-semibold">Organization Members</h2>
            {isAdmin && (
              <Button onClick={() => setInviteDialogOpen(true)}>
                <UserPlus className="h-4 w-4 mr-2" />
                Invite Member
              </Button>
            )}
          </div>
          {isLoadingMembers ? (
            <div className="flex justify-center items-center h-32">
              <Loader2 className="h-6 w-6 animate-spin text-primary" />
            </div>
          ) : organizationMembers.length === 0 ? (
            <div className="text-center p-12 border rounded-lg bg-muted/50">
              <Users className="h-12 w-12 mx-auto text-muted-foreground" />
              <h3 className="mt-4 text-lg font-medium">No members yet</h3>
              <p className="mt-2 text-muted-foreground max-w-md mx-auto">
                Invite members to join your organization and collaborate on prayer groups.
              </p>
              {isAdmin && (
                <Button className="mt-4" onClick={() => setInviteDialogOpen(true)}>
                  <UserPlus className="h-4 w-4 mr-2" />
                  Invite Member
                </Button>
              )}
            </div>
          ) : (
            <Card>
              <CardContent className="p-0">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Name</TableHead>
                      <TableHead>Role</TableHead>
                      <TableHead>Joined</TableHead>
                      {isAdmin && <TableHead className="text-right">Actions</TableHead>}
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {organizationMembers.map((member) => (
                      <TableRow key={member.id}>
                        <TableCell className="font-medium">
                          <div className="flex items-center">
                            <div className="h-8 w-8 rounded-full bg-primary-100 flex items-center justify-center text-primary-800 font-medium mr-2">
                              {member.userId === user?.id ? (
                                <User className="h-4 w-4" />
                              ) : (
                                <User className="h-4 w-4" />
                              )}
                            </div>
                            {member.userId === user?.id ? "You" : `User ${member.userId}`}
                          </div>
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center">
                            {member.role === "admin" ? (
                              <>
                                <Shield className="h-4 w-4 mr-1 text-primary" />
                                Admin
                              </>
                            ) : (
                              <>
                                <User className="h-4 w-4 mr-1" />
                                Member
                              </>
                            )}
                          </div>
                        </TableCell>
                        <TableCell>
                          {formatDistanceToNow(new Date(member.joinedAt), { addSuffix: true })}
                        </TableCell>
                        {isAdmin && (
                          <TableCell className="text-right">
                            {member.userId !== user?.id && (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() => handleRemoveMember(member.userId)}
                                disabled={removeMemberMutation.isPending}
                                className="text-destructive hover:text-destructive hover:bg-destructive/10"
                              >
                                <XCircle className="h-4 w-4 mr-1" />
                                Remove
                              </Button>
                            )}
                          </TableCell>
                        )}
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </CardContent>
            </Card>
          )}
        </TabsContent>

        <TabsContent value="groups" className="space-y-4">
          <div className="flex justify-between items-center">
            <h2 className="text-xl font-semibold">Organization Groups</h2>
            <Button onClick={() => navigate("/groups/new")}>
              Create Group
            </Button>
          </div>
          {isLoadingGroups ? (
            <div className="flex justify-center items-center h-32">
              <Loader2 className="h-6 w-6 animate-spin text-primary" />
            </div>
          ) : groups.length === 0 ? (
            <div className="text-center p-12 border rounded-lg bg-muted/50">
              <Building className="h-12 w-12 mx-auto text-muted-foreground" />
              <h3 className="mt-4 text-lg font-medium">No groups yet</h3>
              <p className="mt-2 text-muted-foreground max-w-md mx-auto">
                Create prayer groups to organize prayer requests and members within this organization.
              </p>
              <Button className="mt-4" onClick={() => navigate("/groups/new")}>
                Create Group
              </Button>
            </div>
          ) : (
            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
              {groups.map((group) => (
                <Card key={group.id} className="overflow-hidden">
                  <CardHeader className="pb-3">
                    <CardTitle>{group.name}</CardTitle>
                    <CardDescription className="line-clamp-2">
                      {group.description || "No description provided"}
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="flex items-center text-sm text-muted-foreground">
                      <Users className="mr-1 h-4 w-4" />
                      <span>Category: {group.category}</span>
                    </div>
                  </CardContent>
                  <CardFooter className="border-t bg-muted/50 px-6 py-3">
                    <Button
                      variant="outline"
                      size="sm"
                      className="w-full"
                      onClick={() => navigate(`/groups/${group.id}`)}
                    >
                      View Group
                    </Button>
                  </CardFooter>
                </Card>
              ))}
            </div>
          )}
        </TabsContent>

        {isAdmin && (
          <TabsContent value="settings" className="space-y-4">
            <h2 className="text-xl font-semibold">Organization Settings</h2>
            <Card>
              <CardHeader>
                <CardTitle>General Settings</CardTitle>
                <CardDescription>
                  Update your organization information
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-1">
                  <Label>Organization Name</Label>
                  <div className="flex justify-between items-center">
                    <span>{organization.name}</span>
                    <Button variant="outline" size="sm" onClick={() => setEditDialogOpen(true)}>
                      <Pencil className="h-4 w-4 mr-2" />
                      Edit
                    </Button>
                  </div>
                </div>
                <Separator />
                <div className="space-y-1">
                  <Label>Description</Label>
                  <p className="text-sm text-muted-foreground">
                    {organization.description || "No description provided"}
                  </p>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        )}
      </Tabs>

      {/* Edit Organization Dialog */}
      <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Edit Organization</DialogTitle>
            <DialogDescription>
              Update your organization's information
            </DialogDescription>
          </DialogHeader>
          <form onSubmit={editForm.handleSubmit(handleUpdateOrganization)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                {...editForm.register("name", { required: true })}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="description">Description (optional)</Label>
              <Textarea
                id="description"
                className="resize-none h-20"
                {...editForm.register("description")}
              />
            </div>
            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setEditDialogOpen(false)}
                disabled={updateOrganizationMutation.isPending}
              >
                Cancel
              </Button>
              <Button
                type="submit"
                disabled={updateOrganizationMutation.isPending}
              >
                {updateOrganizationMutation.isPending ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Saving...
                  </>
                ) : (
                  "Save Changes"
                )}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      {/* Invite Member Dialog */}
      <Dialog open={inviteDialogOpen} onOpenChange={setInviteDialogOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Invite a Member</DialogTitle>
            <DialogDescription>
              Invite someone to join your organization
            </DialogDescription>
          </DialogHeader>
          <Form {...inviteForm}>
            <form onSubmit={inviteForm.handleSubmit(handleInviteMember)} className="space-y-4">
              <FormField
                control={inviteForm.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email Address</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter email address" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={inviteForm.control}
                name="role"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Role</FormLabel>
                    <Select
                      value={field.value}
                      onValueChange={field.onChange}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select a role" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="member">Member</SelectItem>
                        <SelectItem value="admin">Admin</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <DialogFooter>
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setInviteDialogOpen(false)}
                  disabled={inviteMemberMutation.isPending}
                >
                  Cancel
                </Button>
                <Button
                  type="submit"
                  disabled={inviteMemberMutation.isPending}
                >
                  {inviteMemberMutation.isPending ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Sending Invite...
                    </>
                  ) : (
                    "Send Invitation"
                  )}
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```

## File: client/src/pages/organization-onboarding.tsx
```typescript
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { useOrganizations } from "@/hooks/use-organizations";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { insertOrganizationSchema } from "@shared/schema";
import { z } from "zod";
import { useEffect } from "react";
import { useLocation } from "wouter";

// Extend the insert schema for form validation
const formSchema = insertOrganizationSchema.omit({ createdBy: true }).extend({
  name: z.string().min(3, "Name must be at least 3 characters"),
  description: z.string().min(10, "Description must be at least 10 characters"),
});

export default function OrganizationOnboarding() {
  const { user } = useAuth();
  const { organizations, createOrganizationMutation } = useOrganizations();
  const { toast } = useToast();
  const [, setLocation] = useLocation();

  // Redirect if user already has an organization
  useEffect(() => {
    if (organizations.length > 0) {
      setLocation('/');
    }
  }, [organizations, setLocation]);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: "",
      description: "",
    },
  });

  const onSubmit = async (values: z.infer<typeof formSchema>) => {
    createOrganizationMutation.mutate(values);
  };

  return (
    <div className="container flex items-center justify-center min-h-screen p-4">
      <Card className="w-full max-w-3xl">
        <CardHeader className="text-center">
          <CardTitle className="text-3xl font-bold">Welcome to Prayer Pipeline</CardTitle>
          <CardDescription className="text-lg mt-2">
            To get started, create your first organization
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-6">
            <div className="text-center p-4 bg-muted/50 rounded-lg">
              <p className="text-sm text-muted-foreground">
                Organizations are the central hub for your prayer groups. You'll be able to invite members,
                create prayer groups, and manage prayer requests within your organization.
              </p>
            </div>

            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
                <FormField
                  control={form.control}
                  name="name"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Organization Name</FormLabel>
                      <FormControl>
                        <Input placeholder="e.g., My Church, Prayer Ministry, etc." {...field} />
                      </FormControl>
                      <FormDescription>
                        This will be the main identifier for your organization.
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Description</FormLabel>
                      <FormControl>
                        <Textarea
                          placeholder="Describe the purpose of your organization..."
                          className="min-h-[100px]"
                          {...field}
                        />
                      </FormControl>
                      <FormDescription>
                        Tell members what this organization is about.
                      </FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <Button 
                  type="submit" 
                  className="w-full"
                  disabled={createOrganizationMutation.isPending}
                >
                  {createOrganizationMutation.isPending ? "Creating..." : "Create Organization"}
                </Button>
              </form>
            </Form>
          </div>
        </CardContent>
        <CardFooter className="flex flex-col space-y-4">
          <div className="text-center text-sm text-muted-foreground">
            <p>Need to join an existing organization instead?</p>
            <p>Ask an administrator to invite you using your email: {user?.username}</p>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}
```

## File: client/src/pages/organizations-page.tsx
```typescript
import { useState } from "react";
import { useLocation } from "wouter";
import { useOrganizations } from "@/hooks/use-organizations";
import Header from "@/components/header";
import MobileNav from "@/components/mobile-nav";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { 
  Building,
  Plus, 
  Users, 
  Settings,
  Trash2,
  Loader2,
} from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { insertOrganizationSchema } from "@shared/schema";
import { z } from "zod";

const createOrgSchema = insertOrganizationSchema.omit({ createdBy: true });
type CreateOrgData = z.infer<typeof createOrgSchema>;

export default function OrganizationsPage() {
  const [location, navigate] = useLocation();
  const [dialogOpen, setDialogOpen] = useState(false);
  const [deleteOrgId, setDeleteOrgId] = useState<number | null>(null);
  const { 
    organizations,
    isLoading,
    createOrganizationMutation,
    deleteOrganizationMutation
  } = useOrganizations();

  const form = useForm<CreateOrgData>({
    resolver: zodResolver(createOrgSchema),
    defaultValues: {
      name: "",
      description: "",
    },
  });

  const handleCreateOrganization = async (data: CreateOrgData) => {
    await createOrganizationMutation.mutateAsync(data);
    form.reset();
    setDialogOpen(false);
  };

  const handleDeleteOrganization = async () => {
    if (deleteOrgId) {
      await deleteOrganizationMutation.mutateAsync(deleteOrgId);
      setDeleteOrgId(null);
    }
  };

  return (
    <div>
      <Header />
      
      <main className="pt-20 pb-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="flex justify-between items-center mb-8">
            <div>
              <h1 className="text-3xl font-bold tracking-tight">Your Organizations</h1>
              <p className="text-muted-foreground mt-1">
                Create and manage your prayer community organizations
              </p>
            </div>
            <Button onClick={() => setDialogOpen(true)}>
              <Plus className="mr-2 h-4 w-4" /> Create Organization
            </Button>
          </div>

          {isLoading ? (
            <div className="flex justify-center items-center h-64">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
          ) : organizations.length === 0 ? (
            <div className="text-center p-12 border rounded-lg bg-muted/50">
              <Building className="h-12 w-12 mx-auto text-muted-foreground" />
              <h3 className="mt-4 text-lg font-medium">No organizations yet</h3>
              <p className="mt-2 text-muted-foreground max-w-md mx-auto">
                Create your first organization to start managing prayer groups and invite members to join
                your prayer community.
              </p>
              <Button className="mt-4" onClick={() => setDialogOpen(true)}>
                <Plus className="mr-2 h-4 w-4" /> Create Organization
              </Button>
            </div>
          ) : (
            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
              {organizations.map((org) => (
                <Card key={org.id} className="overflow-hidden">
                  <CardHeader className="pb-3">
                    <CardTitle className="text-xl">{org.name}</CardTitle>
                    <CardDescription className="line-clamp-2">
                      {org.description || "No description provided"}
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="flex items-center text-sm text-muted-foreground">
                      <Users className="mr-1 h-4 w-4" />
                      <span>Members</span>
                    </div>
                  </CardContent>
                  <CardFooter className="border-t bg-muted/50 px-6 py-3 flex justify-between">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => navigate(`/organizations/${org.id}`)}
                    >
                      <Settings className="h-4 w-4 mr-2" />
                      Manage
                    </Button>
                    <AlertDialog open={deleteOrgId === org.id} onOpenChange={(open) => !open && setDeleteOrgId(null)}>
                      <AlertDialogTrigger asChild>
                        <Button variant="ghost" size="sm" className="text-destructive hover:text-destructive hover:bg-destructive/10" onClick={() => setDeleteOrgId(org.id)}>
                          <Trash2 className="h-4 w-4 mr-2" />
                          Delete
                        </Button>
                      </AlertDialogTrigger>
                      <AlertDialogContent>
                        <AlertDialogHeader>
                          <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                          <AlertDialogDescription>
                            This action cannot be undone. This will permanently delete the organization
                            and all of its data including prayer groups and prayer requests.
                          </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                          <AlertDialogCancel disabled={deleteOrganizationMutation.isPending}>Cancel</AlertDialogCancel>
                          <AlertDialogAction 
                            onClick={handleDeleteOrganization}
                            disabled={deleteOrganizationMutation.isPending}
                            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                          >
                            {deleteOrganizationMutation.isPending ? (
                              <>
                                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                Deleting...
                              </>
                            ) : "Delete Organization"}
                          </AlertDialogAction>
                        </AlertDialogFooter>
                      </AlertDialogContent>
                    </AlertDialog>
                  </CardFooter>
                </Card>
              ))}
            </div>
          )}

          <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
            <DialogContent className="sm:max-w-[425px]">
              <DialogHeader>
                <DialogTitle>Create New Organization</DialogTitle>
                <DialogDescription>
                  Create a new organization to manage prayer groups and members.
                </DialogDescription>
              </DialogHeader>
              <Form {...form}>
                <form onSubmit={form.handleSubmit(handleCreateOrganization)} className="space-y-4">
                  <FormField
                    control={form.control}
                    name="name"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Name</FormLabel>
                        <FormControl>
                          <Input placeholder="Enter organization name" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="description"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Description (optional)</FormLabel>
                        <FormControl>
                          <Textarea
                            placeholder="Describe your organization"
                            className="resize-none h-20"
                            {...field}
                            value={field.value || ""}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <DialogFooter>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => setDialogOpen(false)}
                      disabled={createOrganizationMutation.isPending}
                    >
                      Cancel
                    </Button>
                    <Button
                      type="submit"
                      disabled={createOrganizationMutation.isPending}
                    >
                      {createOrganizationMutation.isPending ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Creating...
                        </>
                      ) : (
                        "Create Organization"
                      )}
                    </Button>
                  </DialogFooter>
                </form>
              </Form>
            </DialogContent>
          </Dialog>
        </div>
      </main>
      
      <MobileNav active="organizations" />
    </div>
  );
}
```

## File: client/src/pages/prayer-requests-page.tsx
```typescript
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { useLocation } from "wouter";
import { useOrganizations } from "@/hooks/use-organizations";
import Header from "@/components/header";
import MobileNav from "@/components/mobile-nav";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { ChevronLeft, Filter, Search } from "lucide-react";
import PrayerCard from "@/components/prayer-card";
import { Skeleton } from "@/components/ui/skeleton";
import { getQueryFn } from "@/lib/queryClient";

export default function PrayerRequestsPage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [, navigate] = useLocation();
  const { currentOrganization } = useOrganizations();
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState("all");

  // Redirect if no current organization
  useEffect(() => {
    if (!currentOrganization) {
      navigate("/");
    }
  }, [currentOrganization, navigate]);

  // Fetch all user's prayer requests for the current organization
  const { data: prayerRequests = [], isLoading: isLoadingRequests } = useQuery<any[]>({
    queryKey: ["/api/requests/user/all", currentOrganization?.id],
    queryFn: getQueryFn({ 
      params: { organizationId: currentOrganization?.id },
    }),
    enabled: !!currentOrganization?.id,
  });

  // Filter prayer requests based on search term and status filter
  const filteredRequests = prayerRequests.filter(request => {
    const matchesSearch = searchTerm === "" || 
      request.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
      request.content.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesStatus = statusFilter === "all" || request.status === statusFilter;
    
    return matchesSearch && matchesStatus;
  });

  return (
    <div>
      <Header />
      
      <main className="pt-20 pb-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="flex items-center mb-6">
            <Button 
              variant="ghost" 
              size="sm"
              onClick={() => navigate("/profile")}
              className="mr-2"
            >
              <ChevronLeft className="h-4 w-4 mr-1" />
              Back
            </Button>
            <h1 className="text-2xl font-bold">My Prayer Requests</h1>
          </div>
          
          {/* Filters */}
          <Card className="mb-6">
            <CardContent className="p-4">
              <div className="flex flex-col md:flex-row gap-4">
                <div className="relative flex-1">
                  <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                  <Input
                    type="search"
                    placeholder="Search prayer requests..."
                    className="pl-8"
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                </div>
                <div className="w-full md:w-48">
                  <Select 
                    value={statusFilter} 
                    onValueChange={setStatusFilter}
                  >
                    <SelectTrigger>
                      <Filter className="h-4 w-4 mr-2" />
                      <SelectValue placeholder="Filter by status" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All Statuses</SelectItem>
                      <SelectItem value="active">Active</SelectItem>
                      <SelectItem value="answered">Answered</SelectItem>
                      <SelectItem value="in-progress">In Progress</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </CardContent>
          </Card>
          
          {/* Prayer Requests List */}
          <div className="space-y-4">
            {isLoadingRequests ? (
              <>
                <Skeleton className="h-40 w-full" />
                <Skeleton className="h-40 w-full" />
                <Skeleton className="h-40 w-full" />
              </>
            ) : filteredRequests.length > 0 ? (
              filteredRequests.map((request) => (
                <PrayerCard
                  key={request.id}
                  request={request}
                  onClick={() => navigate(`/requests/${request.id}`)}
                />
              ))
            ) : (
              <div className="text-center py-12 bg-muted rounded-lg">
                <p className="text-muted-foreground mb-4">
                  {searchTerm || statusFilter !== "all" 
                    ? "No prayer requests match your search."
                    : "You haven't created any prayer requests yet."}
                </p>
                <Button onClick={() => navigate("/")}>
                  Create a Prayer Request
                </Button>
              </div>
            )}
          </div>
        </div>
      </main>
      
      <MobileNav active="profile" />
    </div>
  );
}
```

## File: client/src/pages/profile-page.tsx
```typescript
import { useState, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { apiRequest, queryClient } from "@/lib/queryClient";
import Header from "@/components/header";
import MobileNav from "@/components/mobile-nav";
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Bell, User, Settings as SettingsIcon, Camera, ChevronRight } from "lucide-react";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import PrayerCard from "@/components/prayer-card";
import { Skeleton } from "@/components/ui/skeleton";
import { useMutation } from "@tanstack/react-query";
import { useLocation } from "wouter";

export default function ProfilePage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [, navigate] = useLocation();
  const [activeTab, setActiveTab] = useState("overview");
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [avatarPreview, setAvatarPreview] = useState<string | null>(null);

  // Fetch user's recent prayer requests
  const { data: recentRequests = [], isLoading: isLoadingRequests } = useQuery<any[]>({
    queryKey: ["/api/requests/user/recent"],
  });

  // Profile update form schema
  const profileSchema = z.object({
    name: z.string().min(1, "Name is required"),
    email: z.string().email("Please enter a valid email address"),
    phone: z.string().optional(),
    bio: z.string().optional(),
    avatar: z.string().optional(),
  });

  type ProfileFormValues = z.infer<typeof profileSchema>;

  const profileForm = useForm<ProfileFormValues>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      name: user?.name || "",
      email: user?.email || "",
      phone: user?.phone || "",
      bio: user?.bio || "",
      avatar: user?.avatar || "",
    },
  });

  // Update profile mutation
  const updateProfileMutation = useMutation({
    mutationFn: async (data: ProfileFormValues): Promise<void> => {
      await apiRequest("PUT", "/api/user/profile", data);
    },
    onSuccess: () => {
      toast({
        title: "Profile updated",
        description: "Your profile has been updated successfully",
      });
      queryClient.invalidateQueries({ queryKey: ["/api/user"] });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Handle avatar file change
  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const result = e.target?.result as string;
      setAvatarPreview(result);
      profileForm.setValue("avatar", result);
    };
    reader.readAsDataURL(file);
  };

  // Trigger file input click
  const handleAvatarClick = () => {
    fileInputRef.current?.click();
  };

  const onSubmitProfile = (data: ProfileFormValues) => {
    if (avatarPreview) {
      data.avatar = avatarPreview;
    }
    updateProfileMutation.mutate(data);
  };

  // Get initials for the avatar
  const getInitials = () => {
    if (!user?.name) return user?.username.substring(0, 2).toUpperCase() || "?";
    return user.name
      .split(" ")
      .map((n) => n[0])
      .join("")
      .toUpperCase()
      .substring(0, 2);
  };

  return (
    <div>
      <Header />
      
      <main className="pt-20 pb-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="flex flex-col md:flex-row gap-8">
            {/* Profile Sidebar */}
            <div className="w-full md:w-1/3 lg:w-1/4">
              <Card>
                <CardHeader className="pb-2 flex flex-col items-center">
                  <Avatar className="h-24 w-24 mb-2">
                    {user?.avatar ? (
                      <img src={user.avatar} alt={user.name} className="h-full w-full object-cover" />
                    ) : (
                      <AvatarFallback className="text-xl bg-primary text-primary-foreground">
                        {getInitials()}
                      </AvatarFallback>
                    )}
                  </Avatar>
                  <CardTitle className="text-xl mt-2">{user?.name || user?.username}</CardTitle>
                  <CardDescription>{user?.email}</CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-1">
                    <div className="flex flex-col w-full bg-transparent items-stretch gap-1">
                      <Button
                        variant={activeTab === "overview" ? "secondary" : "ghost"}
                        onClick={() => setActiveTab("overview")}
                        className="justify-start px-3 py-2 h-auto font-normal"
                      >
                        <User className="h-4 w-4 mr-2" />
                        Profile Overview
                      </Button>
                      <Button
                        variant={activeTab === "notifications" ? "secondary" : "ghost"}
                        onClick={() => setActiveTab("notifications")}
                        className="justify-start px-3 py-2 h-auto font-normal"
                      >
                        <Bell className="h-4 w-4 mr-2" />
                        Notification Settings
                      </Button>
                      <Button
                        variant={activeTab === "settings" ? "secondary" : "ghost"}
                        onClick={() => setActiveTab("settings")}
                        className="justify-start px-3 py-2 h-auto font-normal"
                      >
                        <SettingsIcon className="h-4 w-4 mr-2" />
                        Account Settings
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </div>
            
            {/* Content Area */}
            <div className="w-full md:w-2/3 lg:w-3/4">
              {activeTab === "overview" && (
                <>
                  {/* Profile Information Card */}
                  <Card className="mb-6">
                    <CardHeader>
                      <CardTitle>Profile Information</CardTitle>
                      <CardDescription>
                        Update your personal information
                      </CardDescription>
                    </CardHeader>
                    <CardContent>
                      <Form {...profileForm}>
                        <form onSubmit={profileForm.handleSubmit(onSubmitProfile)} className="space-y-6">
                          <div className="flex flex-col items-center mb-6">
                            <FormLabel className="mb-2">Profile Picture</FormLabel>
                            <div 
                              className="relative cursor-pointer group"
                              onClick={handleAvatarClick}
                            >
                              <Avatar className="h-32 w-32 border-2 border-border">
                                {avatarPreview ? (
                                  <img src={avatarPreview} alt="Avatar preview" className="h-full w-full object-cover" />
                                ) : user?.avatar ? (
                                  <img src={user.avatar} alt={user.name} className="h-full w-full object-cover" />
                                ) : (
                                  <AvatarFallback className="text-2xl bg-primary text-primary-foreground">
                                    {getInitials()}
                                  </AvatarFallback>
                                )}
                              </Avatar>
                              <div className="absolute inset-0 bg-black/50 flex items-center justify-center rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                                <Camera className="h-8 w-8 text-white" />
                              </div>
                            </div>
                            <FormDescription className="mt-2 text-center">
                              Click to upload or change your profile picture
                            </FormDescription>
                            <input
                              type="file"
                              ref={fileInputRef}
                              className="hidden"
                              accept="image/*"
                              onChange={handleFileChange}
                            />
                          </div>

                          <FormField
                            control={profileForm.control}
                            name="name"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Full Name</FormLabel>
                                <FormControl>
                                  <Input placeholder="Your name" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                          
                          <FormField
                            control={profileForm.control}
                            name="email"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Email</FormLabel>
                                <FormControl>
                                  <Input placeholder="Your email" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                          
                          <FormField
                            control={profileForm.control}
                            name="phone"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Phone (optional)</FormLabel>
                                <FormControl>
                                  <Input 
                                    type="tel"
                                    inputMode="tel"
                                    placeholder="(123) 456-7890" 
                                    {...field} 
                                  />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                          
                          <FormField
                            control={profileForm.control}
                            name="bio"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Bio</FormLabel>
                                <FormControl>
                                  <Textarea 
                                    placeholder="Tell us a little about yourself" 
                                    rows={4}
                                    {...field} 
                                  />
                                </FormControl>
                                <FormDescription>
                                  This will be visible to other members of your prayer groups
                                </FormDescription>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                          
                          <div className="flex justify-end">
                            <Button 
                              type="submit"
                              disabled={updateProfileMutation.isPending}
                            >
                              {updateProfileMutation.isPending ? "Saving..." : "Save Changes"}
                            </Button>
                          </div>
                        </form>
                      </Form>
                    </CardContent>
                  </Card>

                  {/* My Prayer Journey Card */}
                  <Card>
                    <CardHeader>
                      <CardTitle>My Prayer Journey</CardTitle>
                      <CardDescription>
                        Track your prayer requests and their progress
                      </CardDescription>
                    </CardHeader>
                    <CardContent>
                      <div className="space-y-4">
                        {isLoadingRequests ? (
                          <>
                            <Skeleton className="h-40 w-full" />
                            <Skeleton className="h-40 w-full" />
                            <Skeleton className="h-40 w-full" />
                          </>
                        ) : recentRequests.length > 0 ? (
                          <>
                            {recentRequests.slice(0, 3).map((request) => (
                              <PrayerCard
                                key={request.id}
                                request={request}
                                onClick={() => navigate(`/requests/${request.id}`)}
                              />
                            ))}
                          </>
                        ) : (
                          <div className="text-center py-12 bg-muted rounded-lg">
                            <p className="text-muted-foreground mb-4">
                              You haven't created any prayer requests yet.
                            </p>
                            <Button onClick={() => navigate("/")}>
                              Create a Prayer Request
                            </Button>
                          </div>
                        )}
                      </div>
                    </CardContent>
                    {recentRequests.length > 3 && (
                      <CardFooter className="flex justify-center pt-0">
                        <Button 
                          variant="outline" 
                          className="w-full"
                          onClick={() => navigate("/prayer-requests")}
                        >
                          View All Prayer Requests
                          <ChevronRight className="h-4 w-4 ml-2" />
                        </Button>
                      </CardFooter>
                    )}
                  </Card>
                </>
              )}
              
              {activeTab === "notifications" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Notification Settings</CardTitle>
                    <CardDescription>
                      Manage how you receive notifications
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-6">
                      <div className="border rounded-md p-4">
                        <h3 className="font-medium mb-2">Email Notifications</h3>
                        <p className="text-sm text-muted-foreground mb-4">
                          Configure when you receive email notifications
                        </p>
                        <div className="space-y-2">
                          {/* Placeholder for notification settings - to be implemented */}
                          <p className="text-sm text-muted-foreground">
                            Email notification settings will be available in a future update.
                          </p>
                        </div>
                      </div>
                      
                      <div className="border rounded-md p-4">
                        <h3 className="font-medium mb-2">Push Notifications</h3>
                        <p className="text-sm text-muted-foreground mb-4">
                          Configure your in-app notifications
                        </p>
                        <div className="space-y-2">
                          {/* Placeholder for notification settings - to be implemented */}
                          <p className="text-sm text-muted-foreground">
                            Push notification settings will be available in a future update.
                          </p>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              )}
              
              {activeTab === "settings" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Account Settings</CardTitle>
                    <CardDescription>
                      Manage your account settings and preferences
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-6">
                      <div className="border rounded-md p-4">
                        <h3 className="font-medium mb-2">Change Password</h3>
                        <p className="text-sm text-muted-foreground mb-4">
                          Update your password to keep your account secure
                        </p>
                        <div className="space-y-4">
                          {/* Placeholder for password change form - to be implemented */}
                          <p className="text-sm text-muted-foreground">
                            Password changing functionality will be available in a future update.
                          </p>
                        </div>
                      </div>
                      
                      <div className="border rounded-md p-4">
                        <h3 className="font-medium mb-2">Account Privacy</h3>
                        <p className="text-sm text-muted-foreground mb-4">
                          Control your account privacy settings
                        </p>
                        <div className="space-y-2">
                          {/* Placeholder for privacy settings - to be implemented */}
                          <p className="text-sm text-muted-foreground">
                            Privacy settings will be available in a future update.
                          </p>
                        </div>
                      </div>
                      
                      <div className="border rounded-md p-4">
                        <h3 className="font-medium text-red-500 mb-2">Danger Zone</h3>
                        <p className="text-sm text-muted-foreground mb-4">
                          Permanently delete your account and all associated data
                        </p>
                        <Button variant="destructive">
                          Delete Account
                        </Button>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              )}
            </div>
          </div>
        </div>
      </main>
      
      <MobileNav active="profile" />
    </div>
  );
}
```

## File: client/src/pages/request-details.tsx
```typescript
import { useState } from "react";
import { useParams, useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import Header from "@/components/header";
import MobileNav from "@/components/mobile-nav";
import CommentCard from "@/components/comment-card";
import UpdateStatusModal from "@/components/update-status-modal";
import { ArrowLeft, Heart, Share2, MoreVertical } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Skeleton } from "@/components/ui/skeleton";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

export default function RequestDetails() {
  const params = useParams<{ requestId: string }>();
  const requestId = params.requestId ? parseInt(params.requestId) : 0;
  const [_, navigate] = useLocation();
  const { user } = useAuth();
  const { toast } = useToast();
  const [newComment, setNewComment] = useState("");
  const [isPrivate, setIsPrivate] = useState(false);
  const [statusModalOpen, setStatusModalOpen] = useState(false);
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);

  // Get prayer request details
  const {
    data: request,
    isLoading: isLoadingRequest,
  } = useQuery({
    queryKey: [`/api/requests/${requestId}`],
    enabled: !!requestId,
  });

  // Get comments for this prayer request
  const {
    data: comments,
    isLoading: isLoadingComments,
  } = useQuery({
    queryKey: [`/api/requests/${requestId}/comments`],
    enabled: !!requestId,
  });

  // Add comment mutation
  const addCommentMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("POST", `/api/requests/${requestId}/comments`, {
        text: newComment,
        isPrivate,
      });
    },
    onSuccess: () => {
      toast({
        title: "Comment added",
        description: "Your comment has been posted successfully",
      });
      setNewComment("");
      setIsPrivate(false);
      queryClient.invalidateQueries({
        queryKey: [`/api/requests/${requestId}/comments`],
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Delete prayer request mutation
  const deleteRequestMutation = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/requests/${requestId}`, {});
    },
    onSuccess: () => {
      toast({
        title: "Prayer request deleted",
        description: "The prayer request has been removed",
      });
      navigate("/"); // Navigate back to home page
      // Invalidate relevant queries
      queryClient.invalidateQueries({
        queryKey: [`/api/groups/${request?.groupId}/requests`],
      });
      queryClient.invalidateQueries({
        queryKey: ["/api/requests/user/recent"],
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Toggle praying for mutation
  const togglePrayingMutation = useMutation({
    mutationFn: async () => {
      if (request?.isPraying) {
        await apiRequest("DELETE", `/api/requests/${requestId}/pray`, {});
      } else {
        await apiRequest("POST", `/api/requests/${requestId}/pray`, {});
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: [`/api/requests/${requestId}`],
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const getStatusBadgeClass = (status) => {
    switch (status) {
      case "waiting":
        return "bg-amber-50 text-amber-500";
      case "answered":
        return "bg-green-50 text-green-600";
      case "declined":
        return "bg-neutral-50 text-neutral-500";
      default:
        return "bg-neutral-50 text-neutral-500";
    }
  };

  const getStatusText = (status) => {
    switch (status) {
      case "waiting":
        return "Still Waiting";
      case "answered":
        return "Answered!";
      case "declined":
        return "God Said No";
      default:
        return "Unknown";
    }
  };

  return (
    <div>
      <Header />

      <main className="pt-20 pb-20">
        <div className="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <div className="mb-6">
            <Button
              variant="ghost"
              className="flex items-center text-primary hover:text-primary/90 mb-4"
              onClick={() => navigate(`/groups/${request?.groupId}`)}
            >
              <ArrowLeft className="h-5 w-5 mr-1" />
              Back to Group
            </Button>

            <div className="bg-white rounded-lg shadow p-6">
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h2 className="text-xl font-bold font-heading text-neutral-800">
                    {isLoadingRequest ? (
                      <Skeleton className="h-7 w-64" />
                    ) : (
                      request?.title
                    )}
                  </h2>
                  <p className="text-sm text-neutral-600 mt-1">
                    {isLoadingRequest ? (
                      <Skeleton className="h-4 w-96" />
                    ) : (
                      <>
                        In {request?.group?.name} • Posted by{" "}
                        {request?.isAnonymous ? "Anonymous" : request?.author?.name} •{" "}
                        {new Date(request?.createdAt).toLocaleDateString()}
                      </>
                    )}
                  </p>
                </div>
                <div className="flex items-center">
                  {!isLoadingRequest && (
                    <>
                      <span
                        className={`inline-flex items-center px-3 py-1 rounded-full text-xs font-medium mr-2 ${getStatusBadgeClass(
                          request?.status
                        )}`}
                      >
                        {getStatusText(request?.status)}
                      </span>
                      {(request?.isOwn || user?.role === "admin") && (
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button
                              variant="ghost"
                              size="icon"
                              className="p-1 rounded-full text-neutral-400 hover:text-neutral-600"
                            >
                              <MoreVertical className="h-5 w-5" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            {request?.isOwn && (
                              <>
                                <DropdownMenuItem
                                  onClick={() => setStatusModalOpen(true)}
                                >
                                  Update Status
                                </DropdownMenuItem>
                                <DropdownMenuItem
                                  onClick={() => setDeleteConfirmOpen(true)}
                                  className="text-red-600"
                                >
                                  Delete Request
                                </DropdownMenuItem>
                              </>
                            )}
                            {user?.role === "admin" && !request?.isOwn && (
                              <DropdownMenuItem
                                onClick={() => setDeleteConfirmOpen(true)}
                                className="text-red-600"
                              >
                                Delete Request (Admin)
                              </DropdownMenuItem>
                            )}
                          </DropdownMenuContent>
                        </DropdownMenu>
                      )}
                    </>
                  )}
                </div>
              </div>

              <p className="text-neutral-700 mb-6">
                {isLoadingRequest ? (
                  <>
                    <Skeleton className="h-4 w-full mb-2" />
                    <Skeleton className="h-4 w-full mb-2" />
                    <Skeleton className="h-4 w-4/5" />
                  </>
                ) : (
                  request?.description
                )}
              </p>

              <div className="flex items-center justify-between py-3 border-t border-neutral-200">
                <Button
                  variant="ghost"
                  className={`flex items-center ${
                    request?.isPraying
                      ? "text-primary"
                      : "text-neutral-600 hover:text-primary"
                  }`}
                  onClick={() => togglePrayingMutation.mutate()}
                  disabled={togglePrayingMutation.isPending}
                >
                  <Heart
                    className={`h-5 w-5 mr-1 ${
                      request?.isPraying ? "fill-primary" : ""
                    }`}
                  />
                  <span className="text-sm">
                    {togglePrayingMutation.isPending
                      ? "..."
                      : `Praying for this (${request?.prayingCount || 0})`}
                  </span>
                </Button>
                <Button
                  variant="ghost"
                  className="flex items-center text-neutral-600 hover:text-primary"
                >
                  <Share2 className="h-5 w-5 mr-1" />
                  <span className="text-sm">Share</span>
                </Button>
              </div>
            </div>
          </div>

          {/* Comments Section */}
          <div>
            <h3 className="text-lg font-medium font-heading text-neutral-800 mb-4">
              Comments ({comments?.length || 0})
            </h3>

            {/* New Comment Form */}
            <div className="bg-white rounded-lg shadow p-4 mb-6">
              <Textarea
                id="newComment"
                placeholder="Share your thoughts, encouragement, or let them know you're praying..."
                rows={3}
                value={newComment}
                onChange={(e) => setNewComment(e.target.value)}
                className="w-full px-4 py-2 border border-neutral-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none transition"
              />
              <div className="flex items-center justify-between mt-3">
                <div className="flex items-center space-x-2">
                  <Checkbox
                    id="isPrivate"
                    checked={isPrivate}
                    onCheckedChange={(checked) => setIsPrivate(!!checked)}
                  />
                  <label
                    htmlFor="isPrivate"
                    className="text-sm text-neutral-600 cursor-pointer"
                  >
                    Private (only visible to request owner)
                  </label>
                </div>
                <Button
                  onClick={() => addCommentMutation.mutate()}
                  disabled={!newComment.trim() || addCommentMutation.isPending}
                  className="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition text-sm"
                >
                  {addCommentMutation.isPending ? "Posting..." : "Post Comment"}
                </Button>
              </div>
            </div>

            {/* Comments List */}
            <div className="space-y-4">
              {isLoadingComments ? (
                <>
                  <Skeleton className="h-32 w-full" />
                  <Skeleton className="h-32 w-full" />
                  <Skeleton className="h-32 w-full" />
                </>
              ) : comments?.length > 0 ? (
                comments.map((comment) => (
                  <CommentCard
                    key={comment.id}
                    comment={comment}
                    requestId={requestId}
                  />
                ))
              ) : (
                <div className="text-center py-8 bg-neutral-50 rounded-lg border border-neutral-200">
                  <p className="text-neutral-600">
                    No comments yet. Be the first to encourage!
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      </main>

      <MobileNav active="prayers" />

      <UpdateStatusModal
        open={statusModalOpen}
        setOpen={setStatusModalOpen}
        requestId={requestId}
        currentStatus={request?.status}
      />

      {/* Delete Prayer Request Confirmation */}
      <AlertDialog
        open={deleteConfirmOpen}
        onOpenChange={setDeleteConfirmOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Prayer Request</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this prayer request? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => deleteRequestMutation.mutate()}
              className="bg-red-600 text-white hover:bg-red-700"
            >
              {deleteRequestMutation.isPending ? "Deleting..." : "Delete Request"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```

## File: client/src/pages/reset-password-page.tsx
```typescript
import { useState } from "react";
import { useLocation } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { resetPasswordSchema } from "@shared/schema";
import { z } from "zod";
import { useQueryParams } from "@/hooks/use-query-params";
import { apiRequest } from "@/lib/queryClient";
import { useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

export default function ResetPasswordPage() {
  const { token } = useQueryParams();
  const [success, setSuccess] = useState(false);
  const [_, setLocation] = useLocation();
  const { toast } = useToast();

  const resetForm = useForm<z.infer<typeof resetPasswordSchema>>({
    resolver: zodResolver(resetPasswordSchema),
    defaultValues: {
      token: token || "",
      password: "",
      confirmPassword: "",
    },
  });

  const resetPasswordMutation = useMutation({
    mutationFn: async (data: z.infer<typeof resetPasswordSchema>) => {
      const res = await apiRequest("POST", "/api/reset-password", data);
      return await res.json();
    },
    onSuccess: () => {
      setSuccess(true);
      toast({
        title: "Password reset successful",
        description: "Your password has been reset. You can now log in with your new password.",
      });
      // Redirect to login page after 3 seconds
      setTimeout(() => {
        setLocation("/auth");
      }, 3000);
    },
    onError: (error: Error) => {
      toast({
        title: "Password reset failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: z.infer<typeof resetPasswordSchema>) => {
    resetPasswordMutation.mutate(data);
  };

  if (!token) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-neutral-50 p-4">
        <Card className="w-full max-w-md bg-white rounded-xl shadow-lg border-0">
          <CardContent className="p-6 sm:p-8">
            <div className="text-center mb-8">
              <div className="w-16 h-16 mx-auto text-primary">
                <svg
                  className="w-full h-full"
                  fill="currentColor"
                  viewBox="0 0 20 20"
                >
                  <path
                    fillRule="evenodd"
                    d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
              <h1 className="mt-4 text-2xl font-bold text-neutral-800 bg-gradient-to-r from-primary to-primary/80 text-transparent bg-clip-text">
                Invalid Reset Link
              </h1>
              <p className="mt-2 text-neutral-600">
                The password reset link is invalid or has expired.
              </p>
            </div>
            <Button
              className="w-full bg-primary hover:bg-primary/90"
              onClick={() => setLocation("/auth")}
            >
              Return to Login
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-neutral-50 p-4">
      <Card className="w-full max-w-md bg-white rounded-xl shadow-lg border-0">
        <CardContent className="p-6 sm:p-8">
          <div className="text-center mb-8">
            <div className="w-16 h-16 mx-auto text-primary">
              <svg
                className="w-full h-full"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path
                  fillRule="evenodd"
                  d="M10 2a8 8 0 100 16 8 8 0 000-16zm0 14a6 6 0 100-12 6 6 0 000 12zm-1-5a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1z"
                  clipRule="evenodd"
                />
              </svg>
            </div>
            <h1 className="mt-4 text-2xl font-bold text-neutral-800 bg-gradient-to-r from-primary to-primary/80 text-transparent bg-clip-text">
              {success ? "Password Reset Successful" : "Reset Your Password"}
            </h1>
            <p className="mt-2 text-neutral-600">
              {success
                ? "Your password has been reset successfully. Redirecting to login..."
                : "Create a new password for your account"}
            </p>
          </div>

          {!success && (
            <Form {...resetForm}>
              <form
                onSubmit={resetForm.handleSubmit(onSubmit)}
                className="space-y-4"
              >
                <FormField
                  control={resetForm.control}
                  name="password"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>New Password</FormLabel>
                      <FormControl>
                        <Input
                          type="password"
                          placeholder="••••••••"
                          className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                          autoComplete="new-password"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={resetForm.control}
                  name="confirmPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Confirm Password</FormLabel>
                      <FormControl>
                        <Input
                          type="password"
                          placeholder="••••••••"
                          className="w-full px-4 py-2 border-neutral-300 focus:border-primary"
                          autoComplete="new-password"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <Button
                  type="submit"
                  className="w-full bg-primary hover:bg-primary/90 mt-6"
                  disabled={resetPasswordMutation.isPending}
                >
                  {resetPasswordMutation.isPending ? (
                    <div className="flex items-center justify-center">
                      <svg
                        className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                        ></circle>
                        <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                        ></path>
                      </svg>
                      Resetting Password...
                    </div>
                  ) : (
                    "Reset Password"
                  )}
                </Button>
              </form>
            </Form>
          )}

          {success && (
            <Button
              className="w-full bg-primary hover:bg-primary/90"
              onClick={() => setLocation("/auth")}
            >
              Return to Login
            </Button>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

## File: client/src/pages/settings-page.tsx
```typescript
import { useState, useEffect, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { usePushNotifications } from "@/hooks/use-push-notifications";
import { useNotificationPreferences } from "@/hooks/use-notification-preferences";
import { PrayerRemindersCard } from "@/components/prayer-reminders-card";
import Header from "@/components/header";
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Textarea } from "@/components/ui/textarea";
import PrayerCard from "@/components/prayer-card";
import { Skeleton } from "@/components/ui/skeleton";
import { useLocation } from "wouter";
import {
  Bell,
  Lock,
  User,
  Shield,
  ToggleLeft,
  Moon,
  Sun,
  Palette,
  BellRing,
  BellOff,
  AlertCircle,
  Loader2,
  Clock,
  Camera,
  ChevronRight,
  Home,
}  from "lucide-react";

import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useMutation } from "@tanstack/react-query";

export default function SettingsPage() {
  const { user } = useAuth();
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState("overview");
  const [_, navigate] = useLocation();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [avatarPreview, setAvatarPreview] = useState<string | null>(null);
  
  // Fetch user's recent prayer requests
  const { data: recentRequests = [], isLoading: isLoadingRequests } = useQuery<any[]>({
    queryKey: ["/api/requests/user/recent"],
  });
  const {
    isSupported,
    isSubscribed,
    permission,
    isLoading: notificationsLoading,
    subscribe,
    unsubscribe,
    requestPermission
  } = usePushNotifications();
  const {
    preferences: notificationPreferences,
    isLoading: preferencesLoading,
    updatePreferences,
    isPending: updatePending
  } = useNotificationPreferences();

  // Password change form schema
  const passwordSchema = z
    .object({
      currentPassword: z.string().min(1, "Current password is required"),
      newPassword: z.string().min(8, "Password must be at least 8 characters"),
      confirmPassword: z.string().min(8, "Password must be at least 8 characters"),
    })
    .refine((data) => data.newPassword === data.confirmPassword, {
      message: "Passwords don't match",
      path: ["confirmPassword"],
    });

  type PasswordFormValues = z.infer<typeof passwordSchema>;

  const passwordForm = useForm<PasswordFormValues>({
    resolver: zodResolver(passwordSchema),
    defaultValues: {
      currentPassword: "",
      newPassword: "",
      confirmPassword: "",
    },
  });
  
  // Change password mutation
  const changePasswordMutation = useMutation({
    mutationFn: async (data: PasswordFormValues): Promise<void> => {
      await apiRequest("POST", "/api/user/change-password", {
        currentPassword: data.currentPassword,
        newPassword: data.newPassword,
      });
    },
    onSuccess: () => {
      toast({
        title: "Password updated",
        description: "Your password has been changed successfully.",
      });
      passwordForm.reset();
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmitPassword = (data: PasswordFormValues) => {
    changePasswordMutation.mutate(data);
  };

  // Profile form schema
  const profileSchema = z.object({
    username: z.string().min(3, "Username must be at least 3 characters"),
    name: z.string().optional(),
    email: z.string().email("Please enter a valid email address"),
    phone: z.string().optional(),
    bio: z.string().optional(),
    avatar: z.string().optional(),
  });

  type ProfileFormValues = z.infer<typeof profileSchema>;

  const profileForm = useForm<ProfileFormValues>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      username: user?.username || "",
      name: user?.name || "",
      email: user?.email || "",
      phone: user?.phone || "",
      bio: user?.bio || "",
      avatar: user?.avatar || "",
    },
  });

  // Update profile mutation
  const updateProfileMutation = useMutation({
    mutationFn: async (data: ProfileFormValues): Promise<void> => {
      await apiRequest("PUT", "/api/user/profile", data);
    },
    onSuccess: () => {
      toast({
        title: "Profile updated",
        description: "Your profile has been updated successfully.",
      });
      queryClient.invalidateQueries({ queryKey: ["/api/user"] });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Handle avatar file change
  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const result = e.target?.result as string;
      setAvatarPreview(result);
      profileForm.setValue("avatar", result);
    };
    reader.readAsDataURL(file);
  };

  // Trigger file input click
  const handleAvatarClick = () => {
    fileInputRef.current?.click();
  };

  const onSubmitProfile = (data: ProfileFormValues) => {
    if (avatarPreview) {
      data.avatar = avatarPreview;
    }
    updateProfileMutation.mutate(data);
  };
  
  // Get initials for the avatar
  const getInitials = () => {
    if (!user?.name) return user?.username?.substring(0, 2).toUpperCase() || "?";
    return user.name
      .split(" ")
      .map((n) => n[0])
      .join("")
      .toUpperCase()
      .substring(0, 2);
  };

  return (
    <div>
      <Header />
      
      <main className="pt-20 pb-20">
        <div className="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <h1 className="text-3xl font-bold mb-6">Settings</h1>
          
          <div className="flex flex-col md:flex-row gap-8">
            <div className="w-full md:w-1/4">
              <Card>
                <CardContent className="p-4">
                  <div className="flex flex-col w-full h-auto items-stretch gap-1">
                    <Button
                      variant={activeTab === "overview" ? "secondary" : "ghost"}
                      onClick={() => setActiveTab("overview")}
                      className="justify-start px-3 py-2 h-auto font-normal"
                    >
                      <Home className="h-4 w-4 mr-2" />
                      Overview
                    </Button>
                    <Button
                      variant={activeTab === "profile" ? "secondary" : "ghost"}
                      onClick={() => setActiveTab("profile")}
                      className="justify-start px-3 py-2 h-auto font-normal"
                    >
                      <User className="h-4 w-4 mr-2" />
                      Profile
                    </Button>
                    <Button
                      variant={activeTab === "account" ? "secondary" : "ghost"}
                      onClick={() => setActiveTab("account")}
                      className="justify-start px-3 py-2 h-auto font-normal"
                    >
                      <Lock className="h-4 w-4 mr-2" />
                      Account
                    </Button>
                    <Button
                      variant={activeTab === "appearance" ? "secondary" : "ghost"}
                      onClick={() => setActiveTab("appearance")}
                      className="justify-start px-3 py-2 h-auto font-normal"
                    >
                      <Palette className="h-4 w-4 mr-2" />
                      Appearance
                    </Button>
                    <Button
                      variant={activeTab === "notifications" ? "secondary" : "ghost"}
                      onClick={() => setActiveTab("notifications")}
                      className="justify-start px-3 py-2 h-auto font-normal"
                    >
                      <Bell className="h-4 w-4 mr-2" />
                      Notifications
                    </Button>
                    <Button
                      variant={activeTab === "privacy" ? "secondary" : "ghost"}
                      onClick={() => setActiveTab("privacy")}
                      className="justify-start px-3 py-2 h-auto font-normal"
                    >
                      <Shield className="h-4 w-4 mr-2" />
                      Privacy
                    </Button>
                    <Button
                      variant={activeTab === "reminders" ? "secondary" : "ghost"}
                      onClick={() => setActiveTab("reminders")}
                      className="justify-start px-3 py-2 h-auto font-normal"
                    >
                      <Clock className="h-4 w-4 mr-2" />
                      Prayer Reminders
                    </Button>
                  </div>
                </CardContent>
              </Card>
            </div>
            
            <div className="w-full md:w-3/4">
              {activeTab === "overview" && (
                <>
                  {/* Profile Information Card */}
                  <Card className="mb-6">
                    <CardHeader className="pb-2 flex flex-col items-center">
                      <div className="relative cursor-pointer group mb-2" onClick={handleAvatarClick}>
                        <Avatar className="h-24 w-24 border-2 border-border">
                          {avatarPreview ? (
                            <img src={avatarPreview} alt="Avatar preview" className="h-full w-full object-cover" />
                          ) : user?.avatar ? (
                            <img src={user.avatar} alt={user.name} className="h-full w-full object-cover" />
                          ) : (
                            <AvatarFallback className="text-2xl bg-primary text-primary-foreground">
                              {getInitials()}
                            </AvatarFallback>
                          )}
                        </Avatar>
                        <div className="absolute inset-0 bg-black/50 flex items-center justify-center rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                          <Camera className="h-8 w-8 text-white" />
                        </div>
                      </div>
                      <input
                        type="file"
                        ref={fileInputRef}
                        className="hidden"
                        accept="image/*"
                        onChange={handleFileChange}
                      />
                      <CardTitle className="text-xl mt-2">{user?.name || user?.username}</CardTitle>
                      <CardDescription>{user?.email}</CardDescription>
                    </CardHeader>
                    <CardContent className="text-center">
                      <div className="flex flex-wrap justify-center gap-4 mt-4">
                        <Button variant="outline" size="sm" onClick={() => setActiveTab("profile")}>
                          <User className="h-4 w-4 mr-2" />
                          Edit Profile
                        </Button>
                        <Button variant="outline" size="sm" onClick={() => navigate("/organizations")}>
                          <User className="h-4 w-4 mr-2" />
                          Organizations
                        </Button>
                      </div>
                    </CardContent>
                  </Card>

                  {/* My Prayer Journey Card */}
                  <Card>
                    <CardHeader>
                      <CardTitle>My Prayer Journey</CardTitle>
                      <CardDescription>
                        Track your prayer requests and their progress
                      </CardDescription>
                    </CardHeader>
                    <CardContent>
                      <div className="space-y-4">
                        {isLoadingRequests ? (
                          <>
                            <Skeleton className="h-40 w-full" />
                            <Skeleton className="h-40 w-full" />
                            <Skeleton className="h-40 w-full" />
                          </>
                        ) : recentRequests.length > 0 ? (
                          <>
                            {recentRequests.slice(0, 3).map((request) => (
                              <PrayerCard
                                key={request.id}
                                request={request}
                                onClick={() => navigate(`/requests/${request.id}`)}
                              />
                            ))}
                          </>
                        ) : (
                          <div className="text-center py-12 bg-muted rounded-lg">
                            <p className="text-muted-foreground mb-4">
                              You haven't created any prayer requests yet.
                            </p>
                            <Button onClick={() => navigate("/")}>
                              Create a Prayer Request
                            </Button>
                          </div>
                        )}
                      </div>
                    </CardContent>
                    {recentRequests.length > 3 && (
                      <CardFooter className="flex justify-center pt-0">
                        <Button 
                          variant="outline" 
                          className="w-full"
                          onClick={() => navigate("/prayer-requests")}
                        >
                          View All Prayer Requests
                          <ChevronRight className="h-4 w-4 ml-2" />
                        </Button>
                      </CardFooter>
                    )}
                  </Card>
                </>
              )}
              
              {activeTab === "profile" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Profile Settings</CardTitle>
                    <CardDescription>
                      Manage your personal information
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <Form {...profileForm}>
                      <form onSubmit={profileForm.handleSubmit(onSubmitProfile)} className="space-y-6">
                        <FormField
                          control={profileForm.control}
                          name="username"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Username</FormLabel>
                              <FormControl>
                                <Input {...field} />
                              </FormControl>
                              <FormDescription>
                                This is your public display name
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={profileForm.control}
                          name="name"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Full Name</FormLabel>
                              <FormControl>
                                <Input {...field} />
                              </FormControl>
                              <FormDescription>
                                This is your real name, for personalization
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={profileForm.control}
                          name="email"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Email</FormLabel>
                              <FormControl>
                                <Input {...field} />
                              </FormControl>
                              <FormDescription>
                                Used for notifications and account recovery
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={profileForm.control}
                          name="phone"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Phone (optional)</FormLabel>
                              <FormControl>
                                <Input 
                                  type="tel"
                                  inputMode="tel"
                                  placeholder="(123) 456-7890" 
                                  {...field} 
                                />
                              </FormControl>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <FormField
                          control={profileForm.control}
                          name="bio"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Bio</FormLabel>
                              <FormControl>
                                <Textarea 
                                  placeholder="Tell us a little about yourself" 
                                  rows={4}
                                  {...field} 
                                />
                              </FormControl>
                              <FormDescription>
                                This will be visible to other members of your prayer groups
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                        
                        <div className="flex flex-col items-center mb-6">
                          <FormLabel className="mb-2">Profile Picture</FormLabel>
                          <div 
                            className="relative cursor-pointer group"
                            onClick={handleAvatarClick}
                          >
                            <Avatar className="h-32 w-32 border-2 border-border">
                              {avatarPreview ? (
                                <img src={avatarPreview} alt="Avatar preview" className="h-full w-full object-cover" />
                              ) : user?.avatar ? (
                                <img src={user.avatar} alt={user.name} className="h-full w-full object-cover" />
                              ) : (
                                <AvatarFallback className="text-2xl bg-primary text-primary-foreground">
                                  {getInitials()}
                                </AvatarFallback>
                              )}
                            </Avatar>
                            <div className="absolute inset-0 bg-black/50 flex items-center justify-center rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                              <Camera className="h-8 w-8 text-white" />
                            </div>
                          </div>
                          <FormDescription className="mt-2 text-center">
                            Click to upload or change your profile picture
                          </FormDescription>
                          <input
                            type="file"
                            ref={fileInputRef}
                            className="hidden"
                            accept="image/*"
                            onChange={handleFileChange}
                          />
                        </div>
                        
                        <div className="flex justify-end">
                          <Button
                            type="submit"
                            disabled={updateProfileMutation.isPending}
                          >
                            {updateProfileMutation.isPending ? "Saving..." : "Save Changes"}
                          </Button>
                        </div>
                      </form>
                    </Form>
                  </CardContent>
                </Card>
              )}
              
              {activeTab === "account" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Account Security</CardTitle>
                    <CardDescription>
                      Manage your account security settings
                    </CardDescription>
                  </CardHeader>
                  <CardContent className="space-y-6">
                    <div>
                      <h3 className="font-medium text-lg mb-4">Change Password</h3>
                      <Form {...passwordForm}>
                        <form onSubmit={passwordForm.handleSubmit(onSubmitPassword)} className="space-y-4">
                          <FormField
                            control={passwordForm.control}
                            name="currentPassword"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Current Password</FormLabel>
                                <FormControl>
                                  <Input type="password" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                          
                          <FormField
                            control={passwordForm.control}
                            name="newPassword"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>New Password</FormLabel>
                                <FormControl>
                                  <Input type="password" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                          
                          <FormField
                            control={passwordForm.control}
                            name="confirmPassword"
                            render={({ field }) => (
                              <FormItem>
                                <FormLabel>Confirm New Password</FormLabel>
                                <FormControl>
                                  <Input type="password" {...field} />
                                </FormControl>
                                <FormMessage />
                              </FormItem>
                            )}
                          />
                          
                          <div className="flex justify-end">
                            <Button
                              type="submit"
                              disabled={changePasswordMutation.isPending}
                            >
                              {changePasswordMutation.isPending ? "Updating..." : "Update Password"}
                            </Button>
                          </div>
                        </form>
                      </Form>
                    </div>
                    
                    <Separator />
                    
                    <div>
                      <h3 className="font-medium text-lg mb-4">Account Status</h3>
                      <div className="space-y-2">
                        <div className="flex items-center justify-between">
                          <div>
                            <p className="font-medium">Member Since</p>
                            <p className="text-sm text-muted-foreground">
                              Not available
                            </p>
                          </div>
                        </div>
                        
                        <div className="flex items-center justify-between">
                          <div>
                            <p className="font-medium">Account Role</p>
                            <p className="text-sm text-muted-foreground">
                              {user?.role || "Member"}
                            </p>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <Separator />
                    
                    <div>
                      <h3 className="font-medium text-lg text-red-500 mb-4">Danger Zone</h3>
                      <p className="text-sm text-muted-foreground mb-4">
                        Once you delete your account, there is no going back. Please be certain.
                      </p>
                      <Button variant="destructive">
                        Delete Account
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              )}
              
              {activeTab === "appearance" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Appearance</CardTitle>
                    <CardDescription>
                      Customize how Prayer Pipeline looks for you
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-6">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <Sun className="h-5 w-5" />
                          <div>
                            <p className="font-medium">Light Mode</p>
                            <p className="text-sm text-muted-foreground">
                              Use light theme
                            </p>
                          </div>
                        </div>
                        <Switch defaultChecked />
                      </div>
                      
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <Moon className="h-5 w-5" />
                          <div>
                            <p className="font-medium">Dark Mode</p>
                            <p className="text-sm text-muted-foreground">
                              Use dark theme
                            </p>
                          </div>
                        </div>
                        <Switch />
                      </div>
                      
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <ToggleLeft className="h-5 w-5" />
                          <div>
                            <p className="font-medium">System Preference</p>
                            <p className="text-sm text-muted-foreground">
                              Match your system theme
                            </p>
                          </div>
                        </div>
                        <Switch />
                      </div>
                      
                      <div className="mt-6">
                        <Button className="mr-2" variant="default">Save Preferences</Button>
                        <Button variant="outline">Reset to Default</Button>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              )}
              
              {activeTab === "notifications" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Notification Preferences</CardTitle>
                    <CardDescription>
                      Control when and how you get notified
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-8">
                      {/* Push notifications section */}
                      <div>
                        <div className="flex items-center gap-2 mb-4">
                          <h3 className="font-medium text-lg">Push Notifications</h3>
                          {isSupported ? (
                            <Badge variant="outline" className="bg-green-50 text-green-700 hover:bg-green-50">
                              Supported
                            </Badge>
                          ) : (
                            <Badge variant="outline" className="bg-red-50 text-red-700 hover:bg-red-50">
                              Not Supported
                            </Badge>
                          )}
                        </div>
                        
                        {!isSupported && (
                          <div className="bg-amber-50 border border-amber-200 rounded-md p-4 mb-4 flex items-start gap-3">
                            <AlertCircle className="h-5 w-5 text-amber-500 mt-0.5 flex-shrink-0" />
                            <div>
                              <p className="font-medium text-amber-800">Browser not supported</p>
                              <p className="text-sm text-amber-700 mt-1">
                                Your browser doesn't support push notifications. Try using a modern browser like Chrome, Firefox, or Edge.
                              </p>
                            </div>
                          </div>
                        )}
                        
                        {isSupported && (
                          <div className="space-y-4">
                            <div className="flex items-center justify-between">
                              <div className="flex items-center gap-2">
                                {isSubscribed ? (
                                  <BellRing className="h-5 w-5 text-primary" />
                                ) : (
                                  <BellOff className="h-5 w-5 text-muted-foreground" />
                                )}
                                <div>
                                  <p className="font-medium">Enable Push Notifications</p>
                                  <p className="text-sm text-muted-foreground">
                                    Receive notifications even when the app is closed
                                  </p>
                                </div>
                              </div>
                              {
                                notificationsLoading ? (
                                  <div className="h-5 w-10 flex items-center justify-center">
                                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-primary"></div>
                                  </div>
                                ) : (
                                  <Switch 
                                    checked={isSubscribed} 
                                    onCheckedChange={(checked) => {
                                      if (checked) {
                                        if (permission === 'granted') {
                                          subscribe();
                                        } else {
                                          requestPermission();
                                        }
                                      } else {
                                        unsubscribe();
                                      }
                                    }}
                                  />
                                )
                              }
                            </div>
                            
                            {permission === 'denied' && (
                              <div className="bg-red-50 border border-red-200 rounded-md p-4 flex items-start gap-3">
                                <AlertCircle className="h-5 w-5 text-red-500 mt-0.5 flex-shrink-0" />
                                <div>
                                  <p className="font-medium text-red-800">Permission denied</p>
                                  <p className="text-sm text-red-700 mt-1">
                                    You've blocked notifications from this site. Please update your browser settings to allow notifications.
                                  </p>
                                </div>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                      
                      <Separator />
                      
                      {/* Email notifications section */}
                      <div>
                        <h3 className="font-medium text-lg mb-3">Email Notifications</h3>
                        {preferencesLoading ? (
                          <div className="flex justify-center py-4">
                            <Loader2 className="h-6 w-6 animate-spin text-primary" />
                          </div>
                        ) : (
                          <div className="space-y-3">
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">Email Notifications</p>
                                <p className="text-sm text-muted-foreground">
                                  Enable or disable all email notifications
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.emailNotifications} 
                                onCheckedChange={(checked) => {
                                  updatePreferences({ emailNotifications: checked });
                                }}
                              />
                            </div>
                            
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">Prayer Requests</p>
                                <p className="text-sm text-muted-foreground">
                                  Get notified about new prayer requests in your groups
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.prayerRequests} 
                                disabled={!notificationPreferences?.emailNotifications}
                                onCheckedChange={(checked) => {
                                  updatePreferences({ prayerRequests: checked });
                                }}
                              />
                            </div>
                            
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">Group Invitations</p>
                                <p className="text-sm text-muted-foreground">
                                  Get notified when you're invited to a new group
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.groupInvitations} 
                                disabled={!notificationPreferences?.emailNotifications}
                                onCheckedChange={(checked) => {
                                  updatePreferences({ groupInvitations: checked });
                                }}
                              />
                            </div>
                            
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">Comments</p>
                                <p className="text-sm text-muted-foreground">
                                  Get notified when someone comments on your prayer request
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.comments} 
                                disabled={!notificationPreferences?.emailNotifications}
                                onCheckedChange={(checked) => {
                                  updatePreferences({ comments: checked });
                                }}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                      
                      <Separator />
                      
                      {/* In-app notifications section */}
                      <div>
                        <h3 className="font-medium text-lg mb-3">In-App Notifications</h3>
                        {preferencesLoading ? (
                          <div className="flex justify-center py-4">
                            <Loader2 className="h-6 w-6 animate-spin text-primary" />
                          </div>
                        ) : (
                          <div className="space-y-3">
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">In-App Notifications</p>
                                <p className="text-sm text-muted-foreground">
                                  Enable or disable all in-app notifications
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.inAppNotifications} 
                                onCheckedChange={(checked) => {
                                  updatePreferences({ inAppNotifications: checked });
                                }}
                              />
                            </div>
                            
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">Status Updates</p>
                                <p className="text-sm text-muted-foreground">
                                  Get notified when prayer request statuses are updated
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.statusUpdates} 
                                disabled={!notificationPreferences?.inAppNotifications}
                                onCheckedChange={(checked) => {
                                  updatePreferences({ statusUpdates: checked });
                                }}
                              />
                            </div>
                            
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">Group Updates</p>
                                <p className="text-sm text-muted-foreground">
                                  Get notified about changes to groups you're in
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.groupUpdates} 
                                disabled={!notificationPreferences?.inAppNotifications}
                                onCheckedChange={(checked) => {
                                  updatePreferences({ groupUpdates: checked });
                                }}
                              />
                            </div>
                            
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-medium">Stale Prayer Reminders</p>
                                <p className="text-sm text-muted-foreground">
                                  Get reminders about prayer requests that need updates
                                </p>
                              </div>
                              <Switch 
                                checked={notificationPreferences?.stalePrayerReminders} 
                                disabled={!notificationPreferences?.inAppNotifications}
                                onCheckedChange={(checked) => {
                                  updatePreferences({ stalePrayerReminders: checked });
                                }}
                              />
                            </div>
                            
                            {notificationPreferences?.stalePrayerReminders && (
                              <div className="pl-4 border-l-2 border-muted-foreground/20 mt-2">
                                <div className="mb-2">
                                  <p className="font-medium text-sm">Reminder Interval (days)</p>
                                  <p className="text-xs text-muted-foreground">
                                    How often to remind you about prayers needing updates
                                  </p>
                                </div>
                                <div className="flex gap-2 items-center">
                                  <Button 
                                    variant="outline" 
                                    size="sm"
                                    onClick={() => {
                                      if (notificationPreferences?.reminderInterval && notificationPreferences.reminderInterval > 1) {
                                        updatePreferences({ reminderInterval: notificationPreferences.reminderInterval - 1 });
                                      }
                                    }}
                                    disabled={!notificationPreferences?.reminderInterval || notificationPreferences.reminderInterval <= 1}
                                  >-</Button>
                                  <span className="font-medium w-8 text-center">{notificationPreferences?.reminderInterval || 7}</span>
                                  <Button 
                                    variant="outline" 
                                    size="sm"
                                    onClick={() => {
                                      if (notificationPreferences?.reminderInterval) {
                                        updatePreferences({ reminderInterval: notificationPreferences.reminderInterval + 1 });
                                      }
                                    }}
                                  >+</Button>
                                </div>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
                  </CardContent>
                </Card>
              )}
              
              {activeTab === "privacy" && (
                <Card>
                  <CardHeader>
                    <CardTitle>Privacy Settings</CardTitle>
                    <CardDescription>
                      Control your privacy preferences
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-6">
                      <div>
                        <h3 className="font-medium text-lg mb-3">Profile Visibility</h3>
                        <div className="space-y-3">
                          <div className="flex items-center justify-between">
                            <div>
                              <p className="font-medium">Show Email Address</p>
                              <p className="text-sm text-muted-foreground">
                                Allow others to see your email address
                              </p>
                            </div>
                            <Switch />
                          </div>
                          
                          <div className="flex items-center justify-between">
                            <div>
                              <p className="font-medium">Show Profile to Non-Group Members</p>
                              <p className="text-sm text-muted-foreground">
                                Allow non-group members to view your profile
                              </p>
                            </div>
                            <Switch defaultChecked />
                          </div>
                        </div>
                      </div>
                      
                      <Separator />
                      
                      <div>
                        <h3 className="font-medium text-lg mb-3">Prayer Request Privacy</h3>
                        <div className="space-y-3">
                          <div className="flex items-center justify-between">
                            <div>
                              <p className="font-medium">Default to Anonymous</p>
                              <p className="text-sm text-muted-foreground">
                                Make all your prayer requests anonymous by default
                              </p>
                            </div>
                            <Switch />
                          </div>
                          
                          <div className="flex items-center justify-between">
                            <div>
                              <p className="font-medium">Allow Sharing</p>
                              <p className="text-sm text-muted-foreground">
                                Allow your prayer requests to be shared outside your groups
                              </p>
                            </div>
                            <Switch defaultChecked />
                          </div>
                        </div>
                      </div>
                      
                      <div className="mt-6">
                        <Button>Save Privacy Settings</Button>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              )}
              
              {activeTab === "reminders" && (
                <PrayerRemindersCard />
              )}
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}
```

## File: client/src/App.tsx
```typescript
import { Switch, Route, Redirect } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import NotFound from "@/pages/not-found";
import HomePage from "@/pages/home-page";
import AuthPage from "@/pages/auth-page";
import GroupDetails from "@/pages/group-details";
import RequestDetails from "@/pages/request-details";
import MeetingDetails from "@/pages/meeting-details";
import ProfilePage from "@/pages/profile-page";
import PrayerRequestsPage from "@/pages/prayer-requests-page";
import SettingsPage from "@/pages/settings-page";
import ExploreGroupsPage from "@/pages/explore-groups-page";
import ForgotPasswordPage from "@/pages/forgot-password-page";
import ResetPasswordPage from "@/pages/reset-password-page";
import OrganizationsPage from "@/pages/organizations-page";
import OrganizationDetailsPage from "@/pages/organization-details-page";
import OrganizationOnboarding from "@/pages/organization-onboarding";
import { ProtectedRoute } from "./lib/protected-route";
import { OrganizationProtectedRoute } from "./lib/organization-protected-route";
import { AuthProvider } from "./hooks/use-auth";
import { OrganizationProvider } from "./hooks/use-organizations";

function Router() {
  return (
    <Switch>
      {/* Routes that require both auth and organization */}
      <OrganizationProtectedRoute path="/" component={HomePage} />
      <OrganizationProtectedRoute path="/groups/:groupId" component={GroupDetails} />
      <OrganizationProtectedRoute path="/requests/:requestId" component={RequestDetails} />
      <OrganizationProtectedRoute path="/meetings/:meetingId" component={MeetingDetails} />
      <Route path="/profile">
        {() => <Redirect to="/settings" />}
      </Route>
      <OrganizationProtectedRoute path="/prayer-requests" component={PrayerRequestsPage} />
      <OrganizationProtectedRoute path="/settings" component={SettingsPage} />
      <OrganizationProtectedRoute path="/explore" component={ExploreGroupsPage} />
      <OrganizationProtectedRoute path="/organizations" component={OrganizationsPage} />
      <OrganizationProtectedRoute path="/organizations/:organizationId" component={OrganizationDetailsPage} />
      
      {/* Routes that require just auth */}
      <ProtectedRoute path="/onboarding" component={OrganizationOnboarding} />
      
      {/* Public routes */}
      <Route path="/auth" component={AuthPage} />
      <Route path="/forgot-password" component={ForgotPasswordPage} />
      <Route path="/reset-password" component={ResetPasswordPage} />
      <Route path="/:rest*" component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <OrganizationProvider>
          <Router />
          <Toaster />
        </OrganizationProvider>
      </AuthProvider>
    </QueryClientProvider>
  );
}

export default App;
```

## File: client/src/index.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
  }
}
```

## File: client/src/main.tsx
```typescript
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);
```

## File: client/index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

## File: mobile/src/api/queryClient.ts
```typescript
import { QueryClient } from '@tanstack/react-query';
import Constants from 'expo-constants';

// API base URL - get from environment or use default
const API_BASE_URL = Constants.expoConfig?.extra?.apiUrl || 'http://localhost:3000';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
});

/**
 * Make an API request with automatic token handling
 */
export async function apiRequest(
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE',
  path: string,
  body?: any,
  customHeaders?: Record<string, string>
): Promise<Response> {
  const url = `${API_BASE_URL}${path}`;
  
  const headers: HeadersInit = {
    'Content-Type': 'application/json',
    ...customHeaders,
  };
  
  const options: RequestInit = {
    method,
    headers,
    credentials: 'include',
  };
  
  if (body && method !== 'GET') {
    options.body = JSON.stringify(body);
  }
  
  try {
    const response = await fetch(url, options);
    
    // Handle 401 Unauthorized globally
    if (response.status === 401) {
      // Could trigger auth flow here or let the component handle it
      console.warn('Unauthorized request:', path);
    }
    
    return response;
  } catch (error) {
    console.error(`API Request Error for ${path}:`, error);
    throw error;
  }
}

/**
 * Default query function used by react-query
 */
export function getQueryFn(options?: { on401?: 'throwError' | 'returnNull' }) {
  return async ({ queryKey }: { queryKey: string[] }) => {
    const [path, ...rest] = queryKey;
    
    // If queryKey has parameters, append them to the URL
    let url = path;
    if (rest.length > 0 && typeof rest[0] === 'object') {
      const params = new URLSearchParams();
      Object.entries(rest[0]).forEach(([key, value]) => {
        if (value !== undefined) {
          params.append(key, String(value));
        }
      });
      
      const paramsString = params.toString();
      if (paramsString) {
        url += `?${paramsString}`;
      }
    }
    
    const response = await apiRequest('GET', url);
    
    // Handle unauthorized based on options
    if (response.status === 401) {
      if (options?.on401 === 'returnNull') {
        return null;
      }
      throw new Error('Unauthorized');
    }
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      throw new Error(
        errorData?.message || `Request failed with status ${response.status}`
      );
    }
    
    return response.json();
  };
}
```

## File: mobile/src/context/AuthContext.tsx
```typescript
import React, { createContext, ReactNode, useEffect, useState } from 'react';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { User, insertUserSchema } from '@shared/schema';
import { z } from 'zod';
import * as SecureStore from 'expo-secure-store';
import { Alert } from 'react-native';
import { apiRequest, getQueryFn, queryClient } from '@/api/queryClient';

type LoginData = {
  username: string;
  password: string;
};

type RegisterData = {
  username: string;
  name: string;
  email: string;
  password: string;
};

type AuthContextType = {
  user: User | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: ReturnType<typeof useLoginMutation>;
  registerMutation: ReturnType<typeof useRegisterMutation>;
  logoutMutation: ReturnType<typeof useLogoutMutation>;
};

export const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  // Use query to fetch the current user if already authenticated
  const {
    data: user,
    error,
    isLoading,
  } = useQuery<User | null>({
    queryKey: ['/api/user'],
    queryFn: getQueryFn({ on401: 'returnNull' }),
  });

  const loginMutation = useLoginMutation();
  const registerMutation = useRegisterMutation();
  const logoutMutation = useLogoutMutation();

  return (
    <AuthContext.Provider
      value={{
        user: user || null,
        isLoading,
        error: error || null,
        loginMutation,
        registerMutation,
        logoutMutation,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

// Login mutation
function useLoginMutation() {
  return useMutation({
    mutationFn: async (credentials: LoginData) => {
      const response = await apiRequest('POST', '/api/login', credentials);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || 'Login failed');
      }
      
      return response.json();
    },
    onSuccess: (user: User) => {
      queryClient.setQueryData(['/api/user'], user);
    },
    onError: (error: Error) => {
      Alert.alert('Login Failed', error.message);
    },
  });
}

// Register mutation
function useRegisterMutation() {
  const registerSchema = insertUserSchema.extend({
    password: z.string().min(8, 'Password must be at least 8 characters'),
  });
  
  return useMutation({
    mutationFn: async (credentials: RegisterData) => {
      // Validate with Zod schema
      registerSchema.parse(credentials);
      
      const response = await apiRequest('POST', '/api/register', credentials);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || 'Registration failed');
      }
      
      return response.json();
    },
    onSuccess: (user: User) => {
      queryClient.setQueryData(['/api/user'], user);
    },
    onError: (error: Error) => {
      Alert.alert('Registration Failed', error.message);
    },
  });
}

// Logout mutation
function useLogoutMutation() {
  return useMutation({
    mutationFn: async () => {
      const response = await apiRequest('POST', '/api/logout');
      if (!response.ok) {
        throw new Error('Logout failed');
      }
    },
    onSuccess: () => {
      queryClient.setQueryData(['/api/user'], null);
      // Invalidate all queries to refresh data
      queryClient.invalidateQueries();
    },
    onError: (error: Error) => {
      Alert.alert('Logout Failed', error.message);
    },
  });
}
```

## File: mobile/src/context/NotificationContext.tsx
```typescript
import React, { createContext, ReactNode, useContext, useEffect, useState } from 'react';
import * as Notifications from 'expo-notifications';
import { useRef } from 'react';
import { Platform } from 'react-native';
import {
  registerForPushNotifications,
  setupNotificationListeners,
  unregisterFromPushNotifications,
} from '@/services/notificationService';
import { useAuth } from '@/hooks/useAuth';

type NotificationContextType = {
  pushToken: string | null;
  expoPushToken: string | null;
  notification: Notifications.Notification | null;
  setNotification: React.Dispatch<React.SetStateAction<Notifications.Notification | null>>;
  isNotificationsEnabled: boolean;
  enableNotifications: () => Promise<boolean>;
  disableNotifications: () => Promise<boolean>;
};

const NotificationContext = createContext<NotificationContextType | null>(null);

export function NotificationProvider({ children }: { children: ReactNode }) {
  const [expoPushToken, setExpoPushToken] = useState<string | null>(null);
  const [notification, setNotification] = useState<Notifications.Notification | null>(null);
  const [isNotificationsEnabled, setIsNotificationsEnabled] = useState<boolean>(false);
  
  // Get the auth context to check if user is logged in
  const { user } = useAuth();
  
  // Reference to notification listener cleanup function
  const notificationListenerCleanup = useRef<(() => void) | null>(null);
  
  // Register for push notifications when the user logs in
  useEffect(() => {
    let isMounted = true;
    
    const registerForNotifications = async () => {
      if (user) {
        // Register device for push notifications
        const token = await registerForPushNotifications();
        if (isMounted && token) {
          setExpoPushToken(token);
          setIsNotificationsEnabled(true);
        }
      } else {
        // Clear token when user logs out
        if (expoPushToken) {
          await unregisterFromPushNotifications(expoPushToken);
        }
        if (isMounted) {
          setExpoPushToken(null);
          setIsNotificationsEnabled(false);
        }
      }
    };
    
    registerForNotifications();
    
    return () => {
      isMounted = false;
    };
  }, [user]);
  
  // Setup notification listeners
  useEffect(() => {
    // Set up notification listeners when component mounts
    notificationListenerCleanup.current = setupNotificationListeners(
      (notification) => {
        setNotification(notification);
      }
    );
    
    // Clean up listeners when component unmounts
    return () => {
      if (notificationListenerCleanup.current) {
        notificationListenerCleanup.current();
      }
    };
  }, []);
  
  // Enable notifications
  const enableNotifications = async (): Promise<boolean> => {
    if (!user) return false;
    
    try {
      const token = await registerForPushNotifications();
      if (token) {
        setExpoPushToken(token);
        setIsNotificationsEnabled(true);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Failed to enable notifications:', error);
      return false;
    }
  };
  
  // Disable notifications
  const disableNotifications = async (): Promise<boolean> => {
    if (!expoPushToken) return true;
    
    try {
      const success = await unregisterFromPushNotifications(expoPushToken);
      if (success) {
        setExpoPushToken(null);
        setIsNotificationsEnabled(false);
      }
      return success;
    } catch (error) {
      console.error('Failed to disable notifications:', error);
      return false;
    }
  };
  
  return (
    <NotificationContext.Provider
      value={{
        pushToken: expoPushToken,
        expoPushToken,
        notification,
        setNotification,
        isNotificationsEnabled,
        enableNotifications,
        disableNotifications,
      }}
    >
      {children}
    </NotificationContext.Provider>
  );
}

// Custom hook to use the notification context
export function useNotifications() {
  const context = useContext(NotificationContext);
  
  if (!context) {
    throw new Error('useNotifications must be used within a NotificationProvider');
  }
  
  return context;
}
```

## File: mobile/src/hooks/useAuth.ts
```typescript
import { useContext } from 'react';
import { AuthContext } from '@/context/AuthContext';

export function useAuth() {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
}
```

## File: mobile/src/hooks/useNotifications.ts
```typescript
import { useNotifications as useNotificationsFromContext } from '@/context/NotificationContext';

// Re-export the hook from the context
export const useNotifications = useNotificationsFromContext;
```

## File: mobile/src/navigation/AppNavigator.tsx
```typescript
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAuth } from '@hooks/useAuth';
import AuthScreen from '@screens/AuthScreen';
import ForgotPasswordScreen from '@screens/ForgotPasswordScreen';
import ResetPasswordScreen from '@screens/ResetPasswordScreen';
import MainNavigator from './MainNavigator';
import OrganizationOnboardingScreen from '@screens/OrganizationOnboardingScreen';

// Type definitions for our route parameters
export type RootStackParamList = {
  Auth: undefined;
  ForgotPassword: undefined;
  ResetPassword: { token: string };
  OrganizationOnboarding: undefined;
  Main: undefined;
};

const Stack = createNativeStackNavigator<RootStackParamList>();

/**
 * Root navigator that handles authentication flow
 */
export default function AppNavigator() {
  const { user, isLoading } = useAuth();
  
  // Show loading state while checking auth
  if (isLoading) {
    return (
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        <Stack.Screen name="Loading" component={() => null} />
      </Stack.Navigator>
    );
  }
  
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      {!user ? (
        // Auth screens
        <>
          <Stack.Screen name="Auth" component={AuthScreen} />
          <Stack.Screen name="ForgotPassword" component={ForgotPasswordScreen} />
          <Stack.Screen name="ResetPassword" component={ResetPasswordScreen} />
        </>
      ) : (
        // Main app screens
        <>
          {/* Onboarding screen for users without an organization */}
          {!user.organizationId && (
            <Stack.Screen
              name="OrganizationOnboarding"
              component={OrganizationOnboardingScreen}
            />
          )}
          <Stack.Screen name="Main" component={MainNavigator} />
        </>
      )}
    </Stack.Navigator>
  );
}
```

## File: mobile/src/navigation/MainNavigator.tsx
```typescript
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useTheme } from 'react-native-paper';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import { View, Text } from 'react-native';

// Import screens
import HomeScreen from '@screens/HomeScreen';
import PrayerRequestsScreen from '@screens/PrayerRequestsScreen';
import ExploreGroupsScreen from '@screens/ExploreGroupsScreen';
import SettingsScreen from '@screens/SettingsScreen';
import GroupDetailsScreen from '@screens/GroupDetailsScreen';
import RequestDetailsScreen from '@screens/RequestDetailsScreen';
import MeetingDetailsScreen from '@screens/MeetingDetailsScreen';
import OrganizationsScreen from '@screens/OrganizationsScreen';
import OrganizationDetailsScreen from '@screens/OrganizationDetailsScreen';

// Type definitions for our route parameters
export type HomeStackParamList = {
  Home: undefined;
  GroupDetails: { groupId: number };
  RequestDetails: { requestId: number };
  MeetingDetails: { meetingId: number };
};

export type PrayerRequestsStackParamList = {
  PrayerRequests: undefined;
  RequestDetails: { requestId: number };
  CreateRequest: undefined;
  EditRequest: { requestId: number };
};

export type ExploreStackParamList = {
  Explore: undefined;
  GroupDetails: { groupId: number };
  CreateGroup: undefined;
};

export type SettingsStackParamList = {
  Settings: undefined;
  Organizations: undefined;
  OrganizationDetails: { organizationId: number };
  EditProfile: undefined;
  ChangePassword: undefined;
};

// Create stack navigators for each tab
const HomeStack = createNativeStackNavigator<HomeStackParamList>();
const PrayerRequestsStack = createNativeStackNavigator<PrayerRequestsStackParamList>();
const ExploreStack = createNativeStackNavigator<ExploreStackParamList>();
const SettingsStack = createNativeStackNavigator<SettingsStackParamList>();
const Tab = createBottomTabNavigator();

// Stack screens for Home tab
function HomeStackNavigator() {
  return (
    <HomeStack.Navigator>
      <HomeStack.Screen
        name="Home"
        component={HomeScreen}
        options={{ title: 'Dashboard' }}
      />
      <HomeStack.Screen
        name="GroupDetails"
        component={GroupDetailsScreen}
        options={({ route }) => ({ title: 'Group Details' })}
      />
      <HomeStack.Screen
        name="RequestDetails"
        component={RequestDetailsScreen}
        options={({ route }) => ({ title: 'Prayer Request' })}
      />
      <HomeStack.Screen
        name="MeetingDetails"
        component={MeetingDetailsScreen}
        options={({ route }) => ({ title: 'Meeting Details' })}
      />
    </HomeStack.Navigator>
  );
}

// Stack screens for Prayer Requests tab
function PrayerRequestsStackNavigator() {
  return (
    <PrayerRequestsStack.Navigator>
      <PrayerRequestsStack.Screen
        name="PrayerRequests"
        component={PrayerRequestsScreen}
        options={{ title: 'Prayer Requests' }}
      />
      <PrayerRequestsStack.Screen
        name="RequestDetails"
        component={RequestDetailsScreen}
        options={({ route }) => ({ title: 'Prayer Request' })}
      />
    </PrayerRequestsStack.Navigator>
  );
}

// Stack screens for Explore tab
function ExploreStackNavigator() {
  return (
    <ExploreStack.Navigator>
      <ExploreStack.Screen
        name="Explore"
        component={ExploreGroupsScreen}
        options={{ title: 'Explore Groups' }}
      />
      <ExploreStack.Screen
        name="GroupDetails"
        component={GroupDetailsScreen}
        options={({ route }) => ({ title: 'Group Details' })}
      />
    </ExploreStack.Navigator>
  );
}

// Stack screens for Settings tab
function SettingsStackNavigator() {
  return (
    <SettingsStack.Navigator>
      <SettingsStack.Screen
        name="Settings"
        component={SettingsScreen}
        options={{ title: 'Settings' }}
      />
      <SettingsStack.Screen
        name="Organizations"
        component={OrganizationsScreen}
        options={{ title: 'Organizations' }}
      />
      <SettingsStack.Screen
        name="OrganizationDetails"
        component={OrganizationDetailsScreen}
        options={({ route }) => ({ title: 'Organization Details' })}
      />
    </SettingsStack.Navigator>
  );
}

// Main tab navigator
export default function MainNavigator() {
  const theme = useTheme();
  
  return (
    <Tab.Navigator
      screenOptions={{
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: 'gray',
        headerShown: false,
      }}
    >
      <Tab.Screen
        name="HomeTab"
        component={HomeStackNavigator}
        options={{
          tabBarLabel: 'Home',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="home" color={color} size={size} />
          ),
        }}
      />
      <Tab.Screen
        name="PrayerRequestsTab"
        component={PrayerRequestsStackNavigator}
        options={{
          tabBarLabel: 'Prayers',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="prayer" color={color} size={size} />
          ),
        }}
      />
      <Tab.Screen
        name="ExploreTab"
        component={ExploreStackNavigator}
        options={{
          tabBarLabel: 'Groups',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="account-group" color={color} size={size} />
          ),
        }}
      />
      <Tab.Screen
        name="SettingsTab"
        component={SettingsStackNavigator}
        options={{
          tabBarLabel: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="cog" color={color} size={size} />
          ),
        }}
      />
    </Tab.Navigator>
  );
}
```

## File: mobile/src/screens/AuthScreen.tsx
```typescript
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView, Image, KeyboardAvoidingView, Platform } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RootStackParamList } from '@navigation/AppNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  SegmentedButtons,
  HelperText,
  ActivityIndicator,
} from 'react-native-paper';
import { useAuth } from '@hooks/useAuth';

export default function AuthScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<RootStackParamList>>();
  const theme = useTheme();
  const { user, isLoading, loginMutation, registerMutation } = useAuth();
  
  const [activeTab, setActiveTab] = useState<'login' | 'register'>('login');
  
  // Login form state
  const [loginUsername, setLoginUsername] = useState('');
  const [loginPassword, setLoginPassword] = useState('');
  const [loginPasswordVisible, setLoginPasswordVisible] = useState(false);
  
  // Register form state
  const [registerName, setRegisterName] = useState('');
  const [registerUsername, setRegisterUsername] = useState('');
  const [registerEmail, setRegisterEmail] = useState('');
  const [registerPassword, setRegisterPassword] = useState('');
  const [registerConfirmPassword, setRegisterConfirmPassword] = useState('');
  const [registerPasswordVisible, setRegisterPasswordVisible] = useState(false);
  const [registerConfirmPasswordVisible, setRegisterConfirmPasswordVisible] = useState(false);
  
  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Redirect if already logged in
  useEffect(() => {
    if (user) {
      navigation.navigate('Main');
    }
  }, [user, navigation]);

  // Validate registration form
  const validateRegisterPassword = () => {
    if (registerPassword.length < 8) {
      return 'Password must be at least 8 characters';
    }
    return '';
  };

  const validateConfirmPassword = () => {
    if (registerConfirmPassword && registerPassword !== registerConfirmPassword) {
      return 'Passwords do not match';
    }
    return '';
  };

  const isLoginFormValid = loginUsername.trim() && loginPassword.trim();
  
  const isRegisterFormValid = 
    registerName.trim() && 
    registerUsername.trim() && 
    registerEmail.trim() && 
    registerPassword.length >= 8 && 
    registerPassword === registerConfirmPassword;

  const handleLogin = () => {
    if (isLoginFormValid) {
      loginMutation.mutate(
        { username: loginUsername, password: loginPassword },
        {
          onError: (error) => {
            setErrorMessage(error.message || 'Login failed. Please check your credentials.');
            setErrorDialogVisible(true);
          }
        }
      );
    }
  };

  const handleRegister = () => {
    if (isRegisterFormValid) {
      registerMutation.mutate(
        {
          name: registerName,
          username: registerUsername,
          email: registerEmail,
          password: registerPassword,
        },
        {
          onError: (error) => {
            setErrorMessage(error.message || 'Registration failed. Please try again.');
            setErrorDialogVisible(true);
          }
        }
      );
    }
  };

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          {/* App Logo and Title */}
          <View style={styles.logoContainer}>
            <Image
              source={require('@/assets/app-logo.png')}
              style={styles.logo}
              resizeMode="contain"
            />
            <Text variant="headlineLarge" style={styles.appTitle}>
              Prayer Pipeline
            </Text>
            <Text variant="bodyLarge" style={styles.appSubtitle}>
              Connect, Share, and Pray Together
            </Text>
          </View>
          
          {/* Auth Card */}
          <Card style={styles.authCard}>
            <Card.Content>
              <SegmentedButtons
                value={activeTab}
                onValueChange={(value) => setActiveTab(value as 'login' | 'register')}
                buttons={[
                  { value: 'login', label: 'Login' },
                  { value: 'register', label: 'Register' },
                ]}
                style={styles.tabButtons}
              />
              
              {/* Login Form */}
              {activeTab === 'login' && (
                <View style={styles.formContainer}>
                  <TextInput
                    label="Username"
                    value={loginUsername}
                    onChangeText={setLoginUsername}
                    mode="outlined"
                    style={styles.input}
                    autoCapitalize="none"
                  />
                  
                  <TextInput
                    label="Password"
                    value={loginPassword}
                    onChangeText={setLoginPassword}
                    secureTextEntry={!loginPasswordVisible}
                    right={
                      <TextInput.Icon
                        icon={loginPasswordVisible ? 'eye-off' : 'eye'}
                        onPress={() => setLoginPasswordVisible(!loginPasswordVisible)}
                      />
                    }
                    mode="outlined"
                    style={styles.input}
                  />
                  
                  <Button
                    mode="text"
                    onPress={() => navigation.navigate('ForgotPassword')}
                    style={styles.forgotPasswordButton}
                  >
                    Forgot Password?
                  </Button>
                  
                  <Button
                    mode="contained"
                    onPress={handleLogin}
                    style={styles.submitButton}
                    loading={loginMutation.isPending}
                    disabled={!isLoginFormValid || loginMutation.isPending}
                  >
                    Login
                  </Button>
                </View>
              )}
              
              {/* Register Form */}
              {activeTab === 'register' && (
                <View style={styles.formContainer}>
                  <TextInput
                    label="Full Name"
                    value={registerName}
                    onChangeText={setRegisterName}
                    mode="outlined"
                    style={styles.input}
                  />
                  
                  <TextInput
                    label="Username"
                    value={registerUsername}
                    onChangeText={setRegisterUsername}
                    mode="outlined"
                    style={styles.input}
                    autoCapitalize="none"
                  />
                  
                  <TextInput
                    label="Email Address"
                    value={registerEmail}
                    onChangeText={setRegisterEmail}
                    mode="outlined"
                    style={styles.input}
                    keyboardType="email-address"
                    autoCapitalize="none"
                  />
                  
                  <TextInput
                    label="Password"
                    value={registerPassword}
                    onChangeText={setRegisterPassword}
                    secureTextEntry={!registerPasswordVisible}
                    right={
                      <TextInput.Icon
                        icon={registerPasswordVisible ? 'eye-off' : 'eye'}
                        onPress={() => setRegisterPasswordVisible(!registerPasswordVisible)}
                      />
                    }
                    mode="outlined"
                    style={styles.input}
                  />
                  {registerPassword ? (
                    <HelperText type={validateRegisterPassword() ? 'error' : 'info'} visible={!!registerPassword}>
                      {validateRegisterPassword() || 'Password strength: ' + (registerPassword.length >= 12 ? 'Strong' : registerPassword.length >= 8 ? 'Medium' : 'Weak')}
                    </HelperText>
                  ) : null}
                  
                  <TextInput
                    label="Confirm Password"
                    value={registerConfirmPassword}
                    onChangeText={setRegisterConfirmPassword}
                    secureTextEntry={!registerConfirmPasswordVisible}
                    right={
                      <TextInput.Icon
                        icon={registerConfirmPasswordVisible ? 'eye-off' : 'eye'}
                        onPress={() => setRegisterConfirmPasswordVisible(!registerConfirmPasswordVisible)}
                      />
                    }
                    mode="outlined"
                    style={styles.input}
                  />
                  {registerConfirmPassword ? (
                    <HelperText type={validateConfirmPassword() ? 'error' : 'info'} visible={!!registerConfirmPassword}>
                      {validateConfirmPassword() || 'Passwords match'}
                    </HelperText>
                  ) : null}
                  
                  <Button
                    mode="contained"
                    onPress={handleRegister}
                    style={styles.submitButton}
                    loading={registerMutation.isPending}
                    disabled={!isRegisterFormValid || registerMutation.isPending}
                  >
                    Register
                  </Button>
                </View>
              )}
            </Card.Content>
          </Card>
        </View>
      </ScrollView>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 24,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 32,
    marginTop: 32,
  },
  logo: {
    width: 100,
    height: 100,
    marginBottom: 16,
  },
  appTitle: {
    textAlign: 'center',
    fontWeight: 'bold',
    marginBottom: 8,
  },
  appSubtitle: {
    textAlign: 'center',
    opacity: 0.7,
  },
  authCard: {
    marginBottom: 32,
  },
  tabButtons: {
    marginBottom: 16,
  },
  formContainer: {
    paddingVertical: 8,
  },
  input: {
    marginBottom: 16,
  },
  forgotPasswordButton: {
    alignSelf: 'flex-end',
    marginTop: -8,
    marginBottom: 16,
  },
  submitButton: {
    marginTop: 8,
  },
});
```

## File: mobile/src/screens/ChangePasswordScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, KeyboardAvoidingView, Platform } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { SettingsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  HelperText,
  ActivityIndicator,
  Divider,
} from 'react-native-paper';
import { useMutation } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';
import { useAuth } from '@hooks/useAuth';

type NavigationProps = NativeStackNavigationProp<SettingsStackParamList, 'ChangePassword'>;

export default function ChangePasswordScreen() {
  const navigation = useNavigation<NavigationProps>();
  const theme = useTheme();
  const { user } = useAuth();
  
  // Form state
  const [currentPassword, setCurrentPassword] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [currentPasswordVisible, setCurrentPasswordVisible] = useState(false);
  const [newPasswordVisible, setNewPasswordVisible] = useState(false);
  const [confirmPasswordVisible, setConfirmPasswordVisible] = useState(false);
  
  // Success state
  const [successDialogVisible, setSuccessDialogVisible] = useState(false);
  
  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Validate password
  const validateNewPassword = () => {
    if (newPassword.length < 8) {
      return 'Password must be at least 8 characters';
    }
    return '';
  };

  const validateConfirmPassword = () => {
    if (confirmPassword && newPassword !== confirmPassword) {
      return 'Passwords do not match';
    }
    return '';
  };

  // Update password mutation
  const changePasswordMutation = useMutation({
    mutationFn: async (data: {
      currentPassword: string;
      newPassword: string;
    }) => {
      const res = await apiRequest('POST', '/api/user/change-password', data);
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to change password' }));
        throw new Error(error.message || 'Failed to change password');
      }
      return res.json();
    },
    onSuccess: () => {
      // Show success dialog
      setSuccessDialogVisible(true);
      
      // Reset form
      setCurrentPassword('');
      setNewPassword('');
      setConfirmPassword('');
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const handleChangePassword = () => {
    if (!currentPassword) {
      setErrorMessage('Please enter your current password');
      setErrorDialogVisible(true);
      return;
    }

    const passwordError = validateNewPassword();
    if (passwordError) {
      setErrorMessage(passwordError);
      setErrorDialogVisible(true);
      return;
    }

    const confirmError = validateConfirmPassword();
    if (confirmError) {
      setErrorMessage(confirmError);
      setErrorDialogVisible(true);
      return;
    }

    changePasswordMutation.mutate({
      currentPassword,
      newPassword,
    });
  };

  const handleSuccessDialogClose = () => {
    setSuccessDialogVisible(false);
    navigation.goBack();
  };

  const passwordError = validateNewPassword();
  const confirmPasswordError = validateConfirmPassword();
  const isFormValid = 
    currentPassword.trim() && 
    newPassword.length >= 8 && 
    newPassword === confirmPassword;

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <Card style={styles.card}>
            <Card.Content>
              <Text variant="titleLarge" style={styles.title}>Change Password</Text>
              
              <View style={styles.formSection}>
                <Text variant="bodyMedium" style={styles.sectionDescription}>
                  For security reasons, please enter your current password before setting a new one
                </Text>
                
                <TextInput
                  label="Current Password"
                  value={currentPassword}
                  onChangeText={setCurrentPassword}
                  secureTextEntry={!currentPasswordVisible}
                  right={
                    <TextInput.Icon
                      icon={currentPasswordVisible ? 'eye-off' : 'eye'}
                      onPress={() => setCurrentPasswordVisible(!currentPasswordVisible)}
                    />
                  }
                  mode="outlined"
                  style={styles.input}
                />
                
                <Divider style={styles.divider} />
                
                <TextInput
                  label="New Password"
                  value={newPassword}
                  onChangeText={setNewPassword}
                  secureTextEntry={!newPasswordVisible}
                  right={
                    <TextInput.Icon
                      icon={newPasswordVisible ? 'eye-off' : 'eye'}
                      onPress={() => setNewPasswordVisible(!newPasswordVisible)}
                    />
                  }
                  mode="outlined"
                  style={styles.input}
                />
                {newPassword ? (
                  <HelperText type={passwordError ? 'error' : 'info'} visible={!!newPassword}>
                    {passwordError || 'Password strength: ' + (newPassword.length >= 12 ? 'Strong' : newPassword.length >= 8 ? 'Medium' : 'Weak')}
                  </HelperText>
                ) : null}
                
                <TextInput
                  label="Confirm New Password"
                  value={confirmPassword}
                  onChangeText={setConfirmPassword}
                  secureTextEntry={!confirmPasswordVisible}
                  right={
                    <TextInput.Icon
                      icon={confirmPasswordVisible ? 'eye-off' : 'eye'}
                      onPress={() => setConfirmPasswordVisible(!confirmPasswordVisible)}
                    />
                  }
                  mode="outlined"
                  style={styles.input}
                />
                {confirmPassword ? (
                  <HelperText type={confirmPasswordError ? 'error' : 'info'} visible={!!confirmPassword}>
                    {confirmPasswordError || 'Passwords match'}
                  </HelperText>
                ) : null}
              </View>
              
              <View style={styles.actions}>
                <Button
                  mode="outlined"
                  onPress={() => navigation.goBack()}
                  style={styles.cancelButton}
                >
                  Cancel
                </Button>
                <Button
                  mode="contained"
                  onPress={handleChangePassword}
                  style={styles.submitButton}
                  loading={changePasswordMutation.isPending}
                  disabled={!isFormValid || changePasswordMutation.isPending}
                >
                  Update Password
                </Button>
              </View>
            </Card.Content>
          </Card>
        </View>
      </ScrollView>
      
      {/* Success Dialog */}
      <Portal>
        <Dialog visible={successDialogVisible} onDismiss={handleSuccessDialogClose}>
          <Dialog.Title>Password Updated</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              Your password has been successfully updated. You'll need to use your new password the next time you log in.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={handleSuccessDialogClose}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
  },
  title: {
    marginBottom: 16,
    fontWeight: 'bold',
  },
  formSection: {
    marginBottom: 16,
  },
  sectionDescription: {
    marginBottom: 16,
    opacity: 0.7,
  },
  divider: {
    marginVertical: 16,
  },
  input: {
    marginBottom: 16,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  cancelButton: {
    flex: 1,
    marginRight: 8,
  },
  submitButton: {
    flex: 2,
  },
});
```

## File: mobile/src/screens/CreateGroupScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, KeyboardAvoidingView, Platform } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { ExploreStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  Chip,
  HelperText,
  SegmentedButtons,
  Divider,
  ActivityIndicator,
  List,
} from 'react-native-paper';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';
import { useAuth } from '@hooks/useAuth';

type NavigationProps = NativeStackNavigationProp<ExploreStackParamList, 'CreateGroup'>;

export default function CreateGroupScreen() {
  const navigation = useNavigation<NavigationProps>();
  const theme = useTheme();
  const queryClient = useQueryClient();
  const { user } = useAuth();
  
  // Form state
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [category, setCategory] = useState<'prayer' | 'bible_study' | 'discipleship' | 'worship' | 'fellowship' | 'outreach'>('prayer');
  const [visibility, setVisibility] = useState<'public' | 'private' | 'hidden'>('public');
  const [meetingDay, setMeetingDay] = useState<string>('');
  const [meetingTime, setMeetingTime] = useState<string>('');
  const [meetingLocation, setMeetingLocation] = useState<string>('');
  
  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Create group mutation
  const createGroupMutation = useMutation({
    mutationFn: async (data: {
      name: string;
      description: string;
      category: string;
      visibility: string;
      meetingDetails?: {
        day: string;
        time: string;
        location: string;
      };
      organizationId: number;
    }) => {
      const res = await apiRequest('POST', '/api/groups', data);
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to create group' }));
        throw new Error(error.message || 'Failed to create group');
      }
      return res.json();
    },
    onSuccess: (data) => {
      // Invalidate and refetch relevant queries
      queryClient.invalidateQueries({ queryKey: ['/api/groups/user'] });
      queryClient.invalidateQueries({ queryKey: ['/api/groups/organization', user?.organizationId] });
      
      // Navigate to the new group details
      navigation.replace('GroupDetails', { groupId: data.id });
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const handleCreateGroup = () => {
    if (!name.trim()) {
      setErrorMessage('Please provide a name for your group');
      setErrorDialogVisible(true);
      return;
    }

    if (!description.trim()) {
      setErrorMessage('Please provide a description for your group');
      setErrorDialogVisible(true);
      return;
    }

    if (!user?.organizationId) {
      setErrorMessage('You must be part of an organization to create a group');
      setErrorDialogVisible(true);
      return;
    }

    const groupData: any = {
      name,
      description,
      category,
      visibility,
      organizationId: user.organizationId,
    };

    // Add meeting details if all fields are filled
    if (meetingDay.trim() && meetingTime.trim() && meetingLocation.trim()) {
      groupData.meetingDetails = {
        day: meetingDay,
        time: meetingTime,
        location: meetingLocation,
      };
    }

    createGroupMutation.mutate(groupData);
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <Card style={styles.card}>
            <Card.Content>
              <Text variant="titleLarge" style={styles.title}>Create New Group</Text>
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Group Details</Text>
                
                <TextInput
                  label="Group Name"
                  value={name}
                  onChangeText={setName}
                  mode="outlined"
                  style={styles.input}
                  maxLength={50}
                />
                
                <TextInput
                  label="Description"
                  value={description}
                  onChangeText={setDescription}
                  mode="outlined"
                  multiline
                  numberOfLines={4}
                  style={styles.textArea}
                  maxLength={300}
                />
                <HelperText type="info" visible>
                  {300 - description.length} characters remaining
                </HelperText>
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Category</Text>
                <Text variant="bodyMedium" style={styles.sectionDescription}>
                  Select the primary focus of your group
                </Text>
                
                <ScrollView
                  horizontal
                  showsHorizontalScrollIndicator={false}
                  contentContainerStyle={styles.categoriesList}
                >
                  <Chip
                    selected={category === 'prayer'}
                    onPress={() => setCategory('prayer')}
                    style={styles.categoryChip}
                    showSelectedCheck
                  >
                    Prayer
                  </Chip>
                  <Chip
                    selected={category === 'bible_study'}
                    onPress={() => setCategory('bible_study')}
                    style={styles.categoryChip}
                    showSelectedCheck
                  >
                    Bible Study
                  </Chip>
                  <Chip
                    selected={category === 'discipleship'}
                    onPress={() => setCategory('discipleship')}
                    style={styles.categoryChip}
                    showSelectedCheck
                  >
                    Discipleship
                  </Chip>
                  <Chip
                    selected={category === 'worship'}
                    onPress={() => setCategory('worship')}
                    style={styles.categoryChip}
                    showSelectedCheck
                  >
                    Worship
                  </Chip>
                  <Chip
                    selected={category === 'fellowship'}
                    onPress={() => setCategory('fellowship')}
                    style={styles.categoryChip}
                    showSelectedCheck
                  >
                    Fellowship
                  </Chip>
                  <Chip
                    selected={category === 'outreach'}
                    onPress={() => setCategory('outreach')}
                    style={styles.categoryChip}
                    showSelectedCheck
                  >
                    Outreach
                  </Chip>
                </ScrollView>
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Visibility</Text>
                <SegmentedButtons
                  value={visibility}
                  onValueChange={(value) => setVisibility(value as 'public' | 'private' | 'hidden')}
                  buttons={[
                    { value: 'public', label: 'Public' },
                    { value: 'private', label: 'Private' },
                    { value: 'hidden', label: 'Hidden' },
                  ]}
                  style={styles.segmentedButtons}
                />
                <Text variant="bodySmall" style={styles.visibilityHint}>
                  {visibility === 'public' && 'Anyone in your organization can see and join this group'}
                  {visibility === 'private' && 'Anyone can see this group, but they must request to join'}
                  {visibility === 'hidden' && 'Only members can see this group, users must be invited'}
                </Text>
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Meeting Details (Optional)</Text>
                <Text variant="bodyMedium" style={styles.sectionDescription}>
                  Add information about when and where your group meets
                </Text>
                
                <TextInput
                  label="Meeting Day"
                  value={meetingDay}
                  onChangeText={setMeetingDay}
                  mode="outlined"
                  style={styles.input}
                  placeholder="e.g. Every Tuesday"
                />
                
                <TextInput
                  label="Meeting Time"
                  value={meetingTime}
                  onChangeText={setMeetingTime}
                  mode="outlined"
                  style={styles.input}
                  placeholder="e.g. 7:00 PM"
                />
                
                <TextInput
                  label="Meeting Location"
                  value={meetingLocation}
                  onChangeText={setMeetingLocation}
                  mode="outlined"
                  style={styles.input}
                  placeholder="e.g. Church Fellowship Hall"
                />
              </View>
              
              <View style={styles.actions}>
                <Button
                  mode="outlined"
                  onPress={() => navigation.goBack()}
                  style={styles.cancelButton}
                >
                  Cancel
                </Button>
                <Button
                  mode="contained"
                  onPress={handleCreateGroup}
                  style={styles.submitButton}
                  loading={createGroupMutation.isPending}
                  disabled={!name.trim() || !description.trim() || createGroupMutation.isPending}
                >
                  Create Group
                </Button>
              </View>
            </Card.Content>
          </Card>
        </View>
      </ScrollView>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
  },
  title: {
    marginBottom: 16,
    fontWeight: 'bold',
  },
  formSection: {
    marginBottom: 16,
  },
  sectionTitle: {
    marginBottom: 8,
  },
  sectionDescription: {
    marginBottom: 16,
    opacity: 0.7,
  },
  divider: {
    marginVertical: 16,
  },
  input: {
    marginBottom: 16,
  },
  textArea: {
    marginBottom: 8,
  },
  categoriesList: {
    paddingVertical: 8,
    flexWrap: 'wrap',
    flexDirection: 'row',
  },
  categoryChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  segmentedButtons: {
    marginVertical: 8,
  },
  visibilityHint: {
    marginTop: 8,
    fontStyle: 'italic',
    opacity: 0.7,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  cancelButton: {
    flex: 1,
    marginRight: 8,
  },
  submitButton: {
    flex: 2,
  },
});
```

## File: mobile/src/screens/CreateRequestScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, KeyboardAvoidingView, Platform } from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { PrayerRequestsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  Chip,
  HelperText,
  SegmentedButtons,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';
import { useAuth } from '@hooks/useAuth';

type NavigationProps = NativeStackNavigationProp<PrayerRequestsStackParamList, 'CreateRequest'>;

export default function CreateRequestScreen() {
  const navigation = useNavigation<NavigationProps>();
  const theme = useTheme();
  const queryClient = useQueryClient();
  const { user } = useAuth();
  
  // Form state
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [urgency, setUrgency] = useState<'low' | 'medium' | 'high'>('medium');
  const [selectedGroupId, setSelectedGroupId] = useState<number | null>(null);
  const [isPublic, setIsPublic] = useState(true);
  
  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Fetch user's groups
  const { data: userGroups, isLoading: isLoadingGroups } = useQuery({
    queryKey: ['/api/groups/user'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/groups/user');
      if (!res.ok) throw new Error('Failed to fetch groups');
      return res.json();
    },
  });

  // Create request mutation
  const createRequestMutation = useMutation({
    mutationFn: async (data: {
      title: string;
      content: string;
      groupId: number;
      urgency: string;
      isPublic: boolean;
    }) => {
      const { groupId, ...requestData } = data;
      const res = await apiRequest('POST', `/api/groups/${groupId}/requests`, {
        ...requestData,
        description: requestData.content,
        isAnonymous: !requestData.isPublic,
      });
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to create prayer request' }));
        throw new Error(error.message || 'Failed to create prayer request');
      }
      return res.json();
    },
    onSuccess: (data) => {
      // Invalidate and refetch relevant queries
      queryClient.invalidateQueries({ queryKey: ['/api/requests/user/recent'] });
      queryClient.invalidateQueries({ queryKey: ['/api/groups', selectedGroupId, 'requests'] });
      
      // Navigate to the new request details
      navigation.replace('RequestDetails', { requestId: data.id });
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const handleCreateRequest = () => {
    if (!selectedGroupId) {
      setErrorMessage('Please select a group for this prayer request');
      setErrorDialogVisible(true);
      return;
    }

    if (!title.trim()) {
      setErrorMessage('Please provide a title for your prayer request');
      setErrorDialogVisible(true);
      return;
    }

    if (!content.trim()) {
      setErrorMessage('Please provide details for your prayer request');
      setErrorDialogVisible(true);
      return;
    }

    createRequestMutation.mutate({
      title,
      content,
      groupId: selectedGroupId,
      urgency,
      isPublic,
    });
  };

  if (isLoadingGroups) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (!userGroups || userGroups.length === 0) {
    return (
      <View style={styles.emptyContainer}>
        <Text variant="headlineSmall" style={styles.emptyText}>
          You need to join a group before creating a prayer request.
        </Text>
        <Button
          mode="contained"
          onPress={() => navigation.navigate('ExploreTab' as any)}
          style={styles.exploreButton}
        >
          Find Groups
        </Button>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <Card style={styles.card}>
            <Card.Content>
              <Text variant="titleLarge" style={styles.title}>Create New Prayer Request</Text>
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Select Group</Text>
                <Text variant="bodyMedium" style={styles.sectionDescription}>
                  Choose which group you want to share this prayer request with
                </Text>
                <ScrollView
                  horizontal
                  showsHorizontalScrollIndicator={false}
                  contentContainerStyle={styles.groupsList}
                >
                  {userGroups.map((group: any) => (
                    <Chip
                      key={group.id}
                      selected={selectedGroupId === group.id}
                      onPress={() => setSelectedGroupId(group.id)}
                      style={styles.groupChip}
                      showSelectedCheck
                    >
                      {group.name}
                    </Chip>
                  ))}
                </ScrollView>
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Request Details</Text>
                
                <TextInput
                  label="Title"
                  value={title}
                  onChangeText={setTitle}
                  mode="outlined"
                  style={styles.input}
                  maxLength={100}
                />
                
                <TextInput
                  label="Details"
                  value={content}
                  onChangeText={setContent}
                  mode="outlined"
                  multiline
                  numberOfLines={5}
                  style={styles.textArea}
                  maxLength={500}
                />
                <HelperText type="info" visible>
                  {500 - content.length} characters remaining
                </HelperText>
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Urgency Level</Text>
                <SegmentedButtons
                  value={urgency}
                  onValueChange={(value) => setUrgency(value as 'low' | 'medium' | 'high')}
                  buttons={[
                    { value: 'low', label: 'Low' },
                    { value: 'medium', label: 'Medium' },
                    { value: 'high', label: 'High' },
                  ]}
                  style={styles.segmentedButtons}
                />
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Privacy Setting</Text>
                <SegmentedButtons
                  value={isPublic ? 'public' : 'private'}
                  onValueChange={(value) => setIsPublic(value === 'public')}
                  buttons={[
                    { value: 'public', label: 'Visible to Group' },
                    { value: 'private', label: 'Only Leaders' },
                  ]}
                  style={styles.segmentedButtons}
                />
                <Text variant="bodySmall" style={styles.privacyHint}>
                  {isPublic
                    ? 'All members of the group can see this request'
                    : 'Only group leaders can see this request'}
                </Text>
              </View>
              
              <View style={styles.actions}>
                <Button
                  mode="outlined"
                  onPress={() => navigation.goBack()}
                  style={styles.cancelButton}
                >
                  Cancel
                </Button>
                <Button
                  mode="contained"
                  onPress={handleCreateRequest}
                  style={styles.submitButton}
                  loading={createRequestMutation.isPending}
                  disabled={!title.trim() || !content.trim() || !selectedGroupId || createRequestMutation.isPending}
                >
                  Create Request
                </Button>
              </View>
            </Card.Content>
          </Card>
        </View>
      </ScrollView>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  emptyText: {
    textAlign: 'center',
    marginBottom: 24,
  },
  exploreButton: {
    marginTop: 16,
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
  },
  title: {
    marginBottom: 16,
    fontWeight: 'bold',
  },
  formSection: {
    marginBottom: 16,
  },
  sectionTitle: {
    marginBottom: 8,
  },
  sectionDescription: {
    marginBottom: 16,
    opacity: 0.7,
  },
  groupsList: {
    paddingVertical: 8,
  },
  groupChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  divider: {
    marginVertical: 16,
  },
  input: {
    marginBottom: 16,
  },
  textArea: {
    marginBottom: 8,
  },
  segmentedButtons: {
    marginVertical: 8,
  },
  privacyHint: {
    marginTop: 8,
    fontStyle: 'italic',
    opacity: 0.7,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  cancelButton: {
    flex: 1,
    marginRight: 8,
  },
  submitButton: {
    flex: 2,
  },
});
```

## File: mobile/src/screens/EditProfileScreen.tsx
```typescript
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView, KeyboardAvoidingView, Platform, Image } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { SettingsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  Avatar,
  HelperText,
  ActivityIndicator,
  Divider,
} from 'react-native-paper';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';
import { useAuth } from '@hooks/useAuth';

type NavigationProps = NativeStackNavigationProp<SettingsStackParamList, 'EditProfile'>;

export default function EditProfileScreen() {
  const navigation = useNavigation<NavigationProps>();
  const theme = useTheme();
  const queryClient = useQueryClient();
  const { user, refreshUser } = useAuth();
  
  // Form state
  const [name, setName] = useState('');
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [bio, setBio] = useState('');
  
  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Initialize form with user data
  useEffect(() => {
    if (user) {
      setName(user.name || '');
      setUsername(user.username || '');
      setEmail(user.email || '');
      setBio(user.bio || '');
    }
  }, [user]);

  // Update profile mutation
  const updateProfileMutation = useMutation({
    mutationFn: async (data: {
      name: string;
      username: string;
      email: string;
      bio: string;
    }) => {
      const res = await apiRequest('PUT', '/api/user/profile', data);
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to update profile' }));
        throw new Error(error.message || 'Failed to update profile');
      }
      return res.json();
    },
    onSuccess: () => {
      // Refresh user data
      if (refreshUser) {
        refreshUser();
      }
      
      // Navigate back to settings
      navigation.goBack();
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const handleUpdateProfile = () => {
    if (!name.trim()) {
      setErrorMessage('Please provide your name');
      setErrorDialogVisible(true);
      return;
    }

    if (!username.trim()) {
      setErrorMessage('Please provide a username');
      setErrorDialogVisible(true);
      return;
    }

    if (!email.trim()) {
      setErrorMessage('Please provide an email address');
      setErrorDialogVisible(true);
      return;
    }

    updateProfileMutation.mutate({
      name,
      username,
      email,
      bio,
    });
  };

  if (!user) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <Card style={styles.card}>
            <Card.Content>
              <Text variant="titleLarge" style={styles.title}>Edit Profile</Text>
              
              <View style={styles.profileImageContainer}>
                <Avatar.Text 
                  size={80} 
                  label={name.split(' ').map(n => n[0]).join('').toUpperCase()}
                  style={styles.profileImage}
                />
                <Button 
                  mode="text" 
                  compact 
                  onPress={() => {
                    // We would implement image upload functionality here
                    // For now, just show an error message
                    setErrorMessage('Image upload functionality coming soon');
                    setErrorDialogVisible(true);
                  }}
                >
                  Change Photo
                </Button>
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Account Information</Text>
                
                <TextInput
                  label="Full Name"
                  value={name}
                  onChangeText={setName}
                  mode="outlined"
                  style={styles.input}
                />
                
                <TextInput
                  label="Username"
                  value={username}
                  onChangeText={setUsername}
                  mode="outlined"
                  style={styles.input}
                  autoCapitalize="none"
                />
                
                <TextInput
                  label="Email"
                  value={email}
                  onChangeText={setEmail}
                  mode="outlined"
                  style={styles.input}
                  keyboardType="email-address"
                  autoCapitalize="none"
                />
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>About You</Text>
                
                <TextInput
                  label="Bio"
                  value={bio}
                  onChangeText={setBio}
                  mode="outlined"
                  multiline
                  numberOfLines={4}
                  style={styles.textArea}
                  maxLength={200}
                />
                <HelperText type="info" visible>
                  {200 - bio.length} characters remaining
                </HelperText>
              </View>
              
              <View style={styles.actions}>
                <Button
                  mode="outlined"
                  onPress={() => navigation.goBack()}
                  style={styles.cancelButton}
                >
                  Cancel
                </Button>
                <Button
                  mode="contained"
                  onPress={handleUpdateProfile}
                  style={styles.submitButton}
                  loading={updateProfileMutation.isPending}
                  disabled={!name.trim() || !username.trim() || !email.trim() || updateProfileMutation.isPending}
                >
                  Save Changes
                </Button>
              </View>
            </Card.Content>
          </Card>
        </View>
      </ScrollView>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
  },
  title: {
    marginBottom: 16,
    fontWeight: 'bold',
  },
  profileImageContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  profileImage: {
    marginBottom: 8,
  },
  formSection: {
    marginBottom: 16,
  },
  sectionTitle: {
    marginBottom: 12,
  },
  divider: {
    marginVertical: 16,
  },
  input: {
    marginBottom: 16,
  },
  textArea: {
    marginBottom: 8,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  cancelButton: {
    flex: 1,
    marginRight: 8,
  },
  submitButton: {
    flex: 2,
  },
});
```

## File: mobile/src/screens/EditRequestScreen.tsx
```typescript
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView, KeyboardAvoidingView, Platform } from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { PrayerRequestsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  SegmentedButtons,
  Divider,
  ActivityIndicator,
  HelperText,
} from 'react-native-paper';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';
import { useAuth } from '@hooks/useAuth';

type RouteProps = RouteProp<PrayerRequestsStackParamList, 'EditRequest'>;
type NavigationProps = NativeStackNavigationProp<PrayerRequestsStackParamList, 'EditRequest'>;

export default function EditRequestScreen() {
  const route = useRoute<RouteProps>();
  const navigation = useNavigation<NavigationProps>();
  const theme = useTheme();
  const queryClient = useQueryClient();
  const { user } = useAuth();
  const { requestId } = route.params;
  
  // Form state
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [urgency, setUrgency] = useState<'low' | 'medium' | 'high'>('medium');
  const [status, setStatus] = useState<'new' | 'in_progress' | 'answered' | 'closed'>('new');
  const [isPublic, setIsPublic] = useState(true);
  
  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Fetch prayer request details
  const { data: request, isLoading: isLoadingRequest } = useQuery({
    queryKey: ['/api/requests', requestId],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/requests/${requestId}`);
      if (!res.ok) throw new Error('Failed to fetch prayer request');
      return res.json();
    },
  });

  // Update form fields when request data is loaded
  useEffect(() => {
    if (request) {
      setTitle(request.title);
      setContent(request.content);
      setUrgency(request.urgency);
      setStatus(request.status);
      setIsPublic(request.isPublic);
    }
  }, [request]);

  // Update request mutation
  const updateRequestMutation = useMutation({
    mutationFn: async (data: {
      title: string;
      content: string;
      urgency: string;
      status: string;
      isPublic: boolean;
    }) => {
      const res = await apiRequest('PUT', `/api/requests/${requestId}`, {
        title: data.title,
        description: data.content, // Map content to description for server
        urgency: data.urgency,
        status: data.status,
        isAnonymous: !data.isPublic, // Map isPublic to isAnonymous for server
      });
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to update prayer request' }));
        throw new Error(error.message || 'Failed to update prayer request');
      }
      return res.json();
    },
    onSuccess: (data) => {
      // Invalidate and refetch relevant queries
      queryClient.invalidateQueries({ queryKey: ['/api/requests', requestId] });
      queryClient.invalidateQueries({ queryKey: ['/api/requests/user/recent'] });
      queryClient.invalidateQueries({ queryKey: ['/api/groups', request.groupId, 'requests'] });
      
      // Navigate back to the request details
      navigation.navigate('RequestDetails', { requestId });
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const handleUpdateRequest = () => {
    if (!title.trim()) {
      setErrorMessage('Please provide a title for your prayer request');
      setErrorDialogVisible(true);
      return;
    }

    if (!content.trim()) {
      setErrorMessage('Please provide details for your prayer request');
      setErrorDialogVisible(true);
      return;
    }

    updateRequestMutation.mutate({
      title,
      content,
      urgency,
      status,
      isPublic,
    });
  };

  if (isLoadingRequest) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <Card style={styles.card}>
            <Card.Content>
              <Text variant="titleLarge" style={styles.title}>Edit Prayer Request</Text>
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Request Details</Text>
                
                <TextInput
                  label="Title"
                  value={title}
                  onChangeText={setTitle}
                  mode="outlined"
                  style={styles.input}
                  maxLength={100}
                />
                
                <TextInput
                  label="Details"
                  value={content}
                  onChangeText={setContent}
                  mode="outlined"
                  multiline
                  numberOfLines={5}
                  style={styles.textArea}
                  maxLength={500}
                />
                <HelperText type="info" visible>
                  {500 - content.length} characters remaining
                </HelperText>
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Status</Text>
                <SegmentedButtons
                  value={status}
                  onValueChange={(value) => setStatus(value as 'new' | 'in_progress' | 'answered' | 'closed')}
                  buttons={[
                    { value: 'new', label: 'New' },
                    { value: 'in_progress', label: 'In Progress' },
                    { value: 'answered', label: 'Answered' },
                    { value: 'closed', label: 'Closed' },
                  ]}
                  style={styles.segmentedButtons}
                  multiline
                />
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Urgency Level</Text>
                <SegmentedButtons
                  value={urgency}
                  onValueChange={(value) => setUrgency(value as 'low' | 'medium' | 'high')}
                  buttons={[
                    { value: 'low', label: 'Low' },
                    { value: 'medium', label: 'Medium' },
                    { value: 'high', label: 'High' },
                  ]}
                  style={styles.segmentedButtons}
                />
              </View>
              
              <Divider style={styles.divider} />
              
              <View style={styles.formSection}>
                <Text variant="titleMedium" style={styles.sectionTitle}>Privacy Setting</Text>
                <SegmentedButtons
                  value={isPublic ? 'public' : 'private'}
                  onValueChange={(value) => setIsPublic(value === 'public')}
                  buttons={[
                    { value: 'public', label: 'Visible to Group' },
                    { value: 'private', label: 'Only Leaders' },
                  ]}
                  style={styles.segmentedButtons}
                />
                <Text variant="bodySmall" style={styles.privacyHint}>
                  {isPublic
                    ? 'All members of the group can see this request'
                    : 'Only group leaders can see this request'}
                </Text>
              </View>
              
              <View style={styles.actions}>
                <Button
                  mode="outlined"
                  onPress={() => navigation.goBack()}
                  style={styles.cancelButton}
                >
                  Cancel
                </Button>
                <Button
                  mode="contained"
                  onPress={handleUpdateRequest}
                  style={styles.submitButton}
                  loading={updateRequestMutation.isPending}
                  disabled={!title.trim() || !content.trim() || updateRequestMutation.isPending}
                >
                  Update Request
                </Button>
              </View>
            </Card.Content>
          </Card>
        </View>
      </ScrollView>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
  },
  title: {
    marginBottom: 16,
    fontWeight: 'bold',
  },
  formSection: {
    marginBottom: 16,
  },
  sectionTitle: {
    marginBottom: 8,
  },
  divider: {
    marginVertical: 16,
  },
  input: {
    marginBottom: 16,
  },
  textArea: {
    marginBottom: 8,
  },
  segmentedButtons: {
    marginVertical: 8,
  },
  privacyHint: {
    marginTop: 8,
    fontStyle: 'italic',
    opacity: 0.7,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  cancelButton: {
    flex: 1,
    marginRight: 8,
  },
  submitButton: {
    flex: 2,
  },
});
```

## File: mobile/src/screens/ExploreGroupsScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, RefreshControl } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { ExploreStackParamList } from '@navigation/MainNavigator';
import { 
  Text, 
  Card, 
  Button, 
  Chip, 
  ActivityIndicator, 
  useTheme, 
  Searchbar,
  Divider,
  FAB
} from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';

// Group categories for filtering
const CATEGORIES = ['General', 'Bible Study', 'Support', 'Prayer', 'Worship', 'Outreach', 'Youth'];

type Group = {
  id: number;
  name: string;
  description: string;
  memberCount: number;
  category: string;
  privacy: string;
  organizationName: string;
  isJoined: boolean;
};

export default function ExploreGroupsScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<ExploreStackParamList>>();
  const theme = useTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [refreshing, setRefreshing] = useState(false);

  // Fetch all groups
  const {
    data: groups,
    isLoading,
    refetch,
  } = useQuery<Group[]>({
    queryKey: ['/api/groups'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/groups');
      if (!res.ok) throw new Error('Failed to fetch groups');
      return res.json();
    },
  });

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await refetch();
    } catch (error) {
      console.error('Error refreshing groups:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refetch]);

  // Filter groups based on search and category
  const filteredGroups = React.useMemo(() => {
    if (!groups) return [];
    
    return groups.filter((group) => {
      const matchesSearch = 
        searchQuery === '' || 
        group.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        group.description.toLowerCase().includes(searchQuery.toLowerCase());
      
      const matchesCategory = 
        !selectedCategory || 
        group.category.toLowerCase() === selectedCategory.toLowerCase();
      
      return matchesSearch && matchesCategory;
    });
  }, [groups, searchQuery, selectedCategory]);

  const handleCategorySelect = (category: string) => {
    setSelectedCategory(selectedCategory === category ? null : category);
  };

  return (
    <View style={styles.container}>
      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <Searchbar
          placeholder="Search for groups"
          onChangeText={setSearchQuery}
          value={searchQuery}
          style={styles.searchBar}
        />
      </View>

      {/* Category Filters */}
      <ScrollView 
        horizontal 
        showsHorizontalScrollIndicator={false} 
        style={styles.categoryContainer}
        contentContainerStyle={styles.categoryContent}
      >
        {CATEGORIES.map((category) => (
          <Chip
            key={category}
            selected={selectedCategory === category}
            onPress={() => handleCategorySelect(category)}
            style={styles.categoryChip}
            selectedColor={theme.colors.primary}
          >
            {category}
          </Chip>
        ))}
      </ScrollView>
      
      <Divider style={styles.divider} />

      {/* Groups List */}
      {isLoading ? (
        <View style={styles.centered}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      ) : (
        <ScrollView
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
          contentContainerStyle={styles.groupsContainer}
        >
          {filteredGroups.length > 0 ? (
            filteredGroups.map((group) => (
              <Card 
                key={group.id} 
                style={styles.groupCard}
                onPress={() => navigation.navigate('GroupDetails', { groupId: group.id })}
              >
                <Card.Content>
                  <View style={styles.cardHeader}>
                    <Text variant="titleMedium">{group.name}</Text>
                    {group.privacy === 'private' && (
                      <Chip 
                        icon="lock" 
                        compact 
                        mode="outlined"
                      >
                        Private
                      </Chip>
                    )}
                  </View>
                  <Text variant="bodySmall" style={styles.organizationName}>
                    {group.organizationName}
                  </Text>
                  <Text variant="bodyMedium" style={styles.description}>
                    {group.description.length > 120
                      ? `${group.description.substring(0, 120)}...`
                      : group.description}
                  </Text>
                  <View style={styles.cardFooter}>
                    <Chip mode="outlined" style={styles.categoryLabel}>
                      {group.category}
                    </Chip>
                    <Text variant="bodySmall">{group.memberCount} members</Text>
                  </View>
                </Card.Content>
                <Card.Actions>
                  {group.isJoined ? (
                    <Button mode="outlined">View Group</Button>
                  ) : (
                    <Button 
                      mode="contained"
                      icon="account-plus"
                    >
                      Join Group
                    </Button>
                  )}
                </Card.Actions>
              </Card>
            ))
          ) : (
            <View style={styles.emptyContainer}>
              <Text variant="headlineSmall" style={styles.emptyText}>No Groups Found</Text>
              <Text variant="bodyMedium" style={styles.emptySubText}>
                {searchQuery || selectedCategory
                  ? "Try changing your search or filter"
                  : "No groups available in your organization"}
              </Text>
            </View>
          )}
        </ScrollView>
      )}

      {/* Create Group FAB */}
      <FAB
        icon="plus"
        style={[styles.fab, { backgroundColor: theme.colors.primary }]}
        onPress={() => navigation.navigate('CreateGroup')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  searchContainer: {
    padding: 16,
    paddingBottom: 8,
  },
  searchBar: {
    elevation: 0,
    backgroundColor: 'white',
  },
  categoryContainer: {
    maxHeight: 48,
  },
  categoryContent: {
    paddingHorizontal: 16,
  },
  categoryChip: {
    marginRight: 8,
    marginVertical: 8,
  },
  divider: {
    marginHorizontal: 16,
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  groupsContainer: {
    padding: 16,
    paddingTop: 8,
  },
  groupCard: {
    marginBottom: 16,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  organizationName: {
    marginBottom: 8,
    opacity: 0.6,
  },
  description: {
    marginVertical: 8,
  },
  cardFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
  },
  categoryLabel: {
    backgroundColor: 'transparent',
  },
  emptyContainer: {
    flex: 1,
    padding: 32,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyText: {
    textAlign: 'center',
    marginVertical: 8,
  },
  emptySubText: {
    textAlign: 'center',
    opacity: 0.6,
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
  },
});
```

## File: mobile/src/screens/ForgotPasswordScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, Image } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RootStackParamList } from '@navigation/AppNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  HelperText,
} from 'react-native-paper';
import { useMutation } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';

export default function ForgotPasswordScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<RootStackParamList>>();
  const theme = useTheme();
  
  // Form state
  const [email, setEmail] = useState('');
  
  // Success state
  const [successDialogVisible, setSuccessDialogVisible] = useState(false);
  
  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Request password reset mutation
  const requestResetMutation = useMutation({
    mutationFn: async (email: string) => {
      const res = await apiRequest('POST', '/api/forgot-password', { email });
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to send reset email' }));
        throw new Error(error.message || 'Failed to send reset email');
      }
      return res.json();
    },
    onSuccess: () => {
      setSuccessDialogVisible(true);
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const validateEmail = () => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!email) return "Email is required";
    if (!emailRegex.test(email)) return "Please enter a valid email address";
    return "";
  };

  const handleRequestReset = () => {
    const emailError = validateEmail();
    if (emailError) {
      setErrorMessage(emailError);
      setErrorDialogVisible(true);
      return;
    }
    
    requestResetMutation.mutate(email);
  };

  const handleSuccessDialogClose = () => {
    setSuccessDialogVisible(false);
    navigation.navigate('Auth');
  };

  const emailError = validateEmail();
  const isFormValid = !emailError;

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <View style={styles.headerContainer}>
            <Text variant="headlineMedium" style={styles.title}>
              Reset Your Password
            </Text>
            <Text variant="bodyLarge" style={styles.subtitle}>
              Enter your email address and we'll send you instructions to reset your password.
            </Text>
          </View>
          
          <Card style={styles.card}>
            <Card.Content>
              <TextInput
                label="Email Address"
                value={email}
                onChangeText={setEmail}
                mode="outlined"
                keyboardType="email-address"
                autoCapitalize="none"
                style={styles.input}
              />
              
              <Button
                mode="contained"
                onPress={handleRequestReset}
                style={styles.resetButton}
                loading={requestResetMutation.isPending}
                disabled={!isFormValid || requestResetMutation.isPending}
              >
                Send Reset Instructions
              </Button>
              
              <Button
                mode="text"
                onPress={() => navigation.navigate('Auth')}
                style={styles.backButton}
              >
                Back to Login
              </Button>
            </Card.Content>
          </Card>
          
          <View style={styles.imageContainer}>
            <Image
              source={require('@/assets/forgot-password-illustration.png')}
              style={styles.image}
              resizeMode="contain"
            />
          </View>
        </View>
      </ScrollView>
      
      {/* Success Dialog */}
      <Portal>
        <Dialog visible={successDialogVisible} onDismiss={handleSuccessDialogClose}>
          <Dialog.Title>Check Your Email</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              We've sent password reset instructions to your email address. Please check your inbox and follow the link to reset your password.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={handleSuccessDialogClose}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 24,
  },
  headerContainer: {
    marginBottom: 24,
  },
  title: {
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    textAlign: 'center',
    opacity: 0.7,
  },
  card: {
    marginBottom: 24,
  },
  input: {
    marginBottom: 16,
  },
  resetButton: {
    marginBottom: 16,
  },
  backButton: {
    marginBottom: 8,
  },
  imageContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 24,
  },
  image: {
    width: '80%',
    height: 180,
  },
});
```

## File: mobile/src/screens/GroupDetailsScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, RefreshControl } from 'react-native';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList, ExploreStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  Card,
  Button,
  IconButton,
  Chip,
  Portal,
  Modal,
  ActivityIndicator,
  useTheme,
  List,
  Divider,
  Avatar,
  FAB,
} from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@hooks/useAuth';
import { apiRequest } from '@/api/queryClient';

// Types for API responses
type Group = {
  id: number;
  name: string;
  description: string;
  category: string;
  privacy: string;
  organizationId: number;
  organizationName: string;
  memberCount: number;
  createdAt: string;
  isFavorite: boolean;
  isJoined: boolean;
  role?: string;
};

type GroupMember = {
  id: number;
  userId: number;
  userName: string;
  userAvatar?: string;
  role: string;
  joinedAt: string;
};

type PrayerRequest = {
  id: number;
  title: string;
  content: string;
  status: string;
  urgency: string;
  createdAt: string;
  updatedAt: string;
  userId: number;
  userName: string;
  commentCount: number;
};

type Meeting = {
  id: number;
  title: string;
  description: string;
  startTime: string;
  endTime: string;
  location: string;
  isRecurring: boolean;
  recurringPattern: string;
};

// Helper type to allow navigation from both Home and Explore stacks
type NavigationProp = NativeStackNavigationProp<
  HomeStackParamList & ExploreStackParamList
>;

export default function GroupDetailsScreen() {
  const route = useRoute<RouteProp<HomeStackParamList, 'GroupDetails'>>();
  const navigation = useNavigation<NavigationProp>();
  const theme = useTheme();
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { groupId } = route.params;
  
  const [activeTab, setActiveTab] = useState('requests');
  const [refreshing, setRefreshing] = useState(false);
  const [leaveModalVisible, setLeaveModalVisible] = useState(false);

  // Fetch group details
  const { 
    data: group, 
    isLoading: isGroupLoading,
    refetch: refetchGroup,
  } = useQuery<Group>({
    queryKey: [`/api/groups/${groupId}`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/groups/${groupId}`);
      if (!res.ok) throw new Error('Failed to fetch group details');
      return res.json();
    },
  });

  // Fetch group members
  const {
    data: members,
    isLoading: isMembersLoading,
    refetch: refetchMembers,
  } = useQuery<GroupMember[]>({
    queryKey: [`/api/groups/${groupId}/members`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/groups/${groupId}/members`);
      if (!res.ok) throw new Error('Failed to fetch group members');
      return res.json();
    },
  });

  // Fetch prayer requests
  const {
    data: requests,
    isLoading: isRequestsLoading,
    refetch: refetchRequests,
  } = useQuery<PrayerRequest[]>({
    queryKey: [`/api/groups/${groupId}/requests`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/groups/${groupId}/requests`);
      if (!res.ok) throw new Error('Failed to fetch prayer requests');
      return res.json();
    },
  });

  // Fetch meetings
  const {
    data: meetings,
    isLoading: isMeetingsLoading,
    refetch: refetchMeetings,
  } = useQuery<Meeting[]>({
    queryKey: [`/api/groups/${groupId}/meetings`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/groups/${groupId}/meetings`);
      if (!res.ok) throw new Error('Failed to fetch meetings');
      return res.json();
    },
  });

  // Toggle favorite mutation
  const toggleFavoriteMutation = useMutation({
    mutationFn: async () => {
      if (!group) return;
      
      const endpoint = `/api/groups/${groupId}/${group.isFavorite ? 'favorite' : 'unfavorite'}`;
      const method = group.isFavorite ? 'DELETE' : 'POST';
      
      const res = await apiRequest(method, endpoint);
      if (!res.ok) throw new Error('Failed to update favorite status');
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/groups/${groupId}`] });
      queryClient.invalidateQueries({ queryKey: ['/api/groups/favorites'] });
    },
  });

  // Join/leave group mutation
  const membershipMutation = useMutation({
    mutationFn: async (action: 'join' | 'leave') => {
      const endpoint = `/api/groups/${groupId}/${action === 'join' ? 'join' : 'leave'}`;
      const method = action === 'join' ? 'POST' : 'DELETE';
      
      const res = await apiRequest(method, endpoint);
      if (!res.ok) throw new Error(`Failed to ${action} group`);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/groups/${groupId}`] });
      queryClient.invalidateQueries({ queryKey: [`/api/groups/${groupId}/members`] });
      queryClient.invalidateQueries({ queryKey: ['/api/groups/user'] });
      setLeaveModalVisible(false);
    },
  });

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([
        refetchGroup(),
        refetchMembers(),
        refetchRequests(),
        refetchMeetings(),
      ]);
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refetchGroup, refetchMembers, refetchRequests, refetchMeetings]);

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const formatMeetingTime = (startTime: string, endTime: string) => {
    const start = new Date(startTime);
    const end = new Date(endTime);
    
    const timeFormat: Intl.DateTimeFormatOptions = {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
    };
    
    const dateFormat: Intl.DateTimeFormatOptions = {
      month: 'short',
      day: 'numeric',
    };
    
    return `${start.toLocaleDateString(undefined, dateFormat)} · ${start.toLocaleTimeString(
      undefined,
      timeFormat
    )} - ${end.toLocaleTimeString(undefined, timeFormat)}`;
  };

  const isAdmin = group?.role === 'admin' || group?.role === 'leader';
  const isLeader = group?.role === 'leader';

  if (isGroupLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (!group) {
    return (
      <View style={styles.errorContainer}>
        <Text variant="headlineSmall">Group not found</Text>
        <Button 
          mode="contained"
          onPress={() => navigation.goBack()}
          style={styles.errorButton}
        >
          Go Back
        </Button>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {/* Group Header Card */}
        <Card style={styles.headerCard}>
          <Card.Content>
            <View style={styles.headerActions}>
              <View style={styles.headerTags}>
                <Chip mode="outlined" style={styles.categoryChip}>
                  {group.category}
                </Chip>
                {group.privacy === 'private' && (
                  <Chip icon="lock" mode="outlined" style={styles.privacyChip}>
                    Private
                  </Chip>
                )}
              </View>
              
              <IconButton
                icon={group.isFavorite ? "star" : "star-outline"}
                iconColor={group.isFavorite ? theme.colors.primary : undefined}
                onPress={() => toggleFavoriteMutation.mutate()}
              />
            </View>
            
            <Text variant="headlineSmall">{group.name}</Text>
            <Text variant="bodySmall" style={styles.organizationName}>
              {group.organizationName}
            </Text>
            
            <Text variant="bodyMedium" style={styles.description}>
              {group.description}
            </Text>
            
            <View style={styles.statsRow}>
              <View style={styles.stat}>
                <Text variant="labelLarge">{group.memberCount}</Text>
                <Text variant="bodySmall">Members</Text>
              </View>
              <View style={styles.stat}>
                <Text variant="labelLarge">{requests?.length || 0}</Text>
                <Text variant="bodySmall">Prayers</Text>
              </View>
              <View style={styles.stat}>
                <Text variant="labelLarge">{meetings?.length || 0}</Text>
                <Text variant="bodySmall">Meetings</Text>
              </View>
            </View>
            
            {!group.isJoined ? (
              <Button
                mode="contained"
                icon="account-plus"
                style={styles.actionButton}
                onPress={() => membershipMutation.mutate('join')}
                loading={membershipMutation.isPending}
              >
                Join Group
              </Button>
            ) : isAdmin ? (
              <Button
                mode="contained"
                icon="pencil"
                style={[styles.actionButton, { backgroundColor: theme.colors.secondary }]}
                onPress={() => {
                  /* Navigate to edit group screen */
                }}
              >
                Manage Group
              </Button>
            ) : (
              <Button
                mode="outlined"
                icon="account-remove"
                style={styles.actionButton}
                onPress={() => setLeaveModalVisible(true)}
              >
                Leave Group
              </Button>
            )}
          </Card.Content>
        </Card>

        {/* Tab Selector */}
        <View style={styles.tabContainer}>
          <Button
            mode={activeTab === 'requests' ? 'contained' : 'text'}
            onPress={() => setActiveTab('requests')}
            style={styles.tabButton}
          >
            Prayer Requests
          </Button>
          <Button
            mode={activeTab === 'meetings' ? 'contained' : 'text'}
            onPress={() => setActiveTab('meetings')}
            style={styles.tabButton}
          >
            Meetings
          </Button>
          <Button
            mode={activeTab === 'members' ? 'contained' : 'text'}
            onPress={() => setActiveTab('members')}
            style={styles.tabButton}
          >
            Members
          </Button>
        </View>

        <Divider />

        {/* Prayer Requests Tab */}
        {activeTab === 'requests' && (
          <View style={styles.tabContent}>
            {isRequestsLoading ? (
              <ActivityIndicator style={styles.tabLoader} />
            ) : requests && requests.length > 0 ? (
              requests.map((request) => (
                <List.Item
                  key={request.id}
                  title={request.title}
                  description={
                    request.content.length > 100
                      ? `${request.content.substring(0, 100)}...`
                      : request.content
                  }
                  onPress={() => 
                    navigation.navigate('RequestDetails', { requestId: request.id })
                  }
                  left={(props) => (
                    <List.Icon
                      {...props}
                      icon={
                        request.status === 'answered'
                          ? 'check-circle'
                          : request.status === 'in-progress'
                          ? 'clock-outline'
                          : 'prayer'
                      }
                      color={
                        request.status === 'answered'
                          ? theme.colors.primary
                          : request.urgency === 'high'
                          ? '#ef4444'  // red for high urgency
                          : undefined
                      }
                    />
                  )}
                  right={(props) => (
                    <View {...props} style={styles.requestMeta}>
                      <Text variant="bodySmall">{formatDate(request.createdAt)}</Text>
                      {request.commentCount > 0 && (
                        <View style={styles.commentCount}>
                          <Text variant="labelSmall">{request.commentCount}</Text>
                        </View>
                      )}
                    </View>
                  )}
                  style={styles.listItem}
                />
              ))
            ) : (
              <View style={styles.emptyTab}>
                <Text variant="bodyLarge">No prayer requests yet</Text>
                <Text variant="bodySmall" style={styles.emptySubText}>
                  {group.isJoined
                    ? "Be the first to share a prayer request"
                    : "Join this group to see and share prayer requests"}
                </Text>
                {group.isJoined && (
                  <Button
                    mode="contained"
                    icon="plus"
                    style={styles.emptyButton}
                    onPress={() => {
                      /* Navigate to create prayer request screen */
                    }}
                  >
                    Add Prayer Request
                  </Button>
                )}
              </View>
            )}
          </View>
        )}

        {/* Meetings Tab */}
        {activeTab === 'meetings' && (
          <View style={styles.tabContent}>
            {isMeetingsLoading ? (
              <ActivityIndicator style={styles.tabLoader} />
            ) : meetings && meetings.length > 0 ? (
              meetings.map((meeting) => (
                <Card
                  key={meeting.id}
                  style={styles.meetingCard}
                  onPress={() =>
                    navigation.navigate('MeetingDetails', { meetingId: meeting.id })
                  }
                >
                  <Card.Content>
                    <Text variant="titleMedium">{meeting.title}</Text>
                    <Text variant="bodySmall" style={styles.meetingTime}>
                      {formatMeetingTime(meeting.startTime, meeting.endTime)}
                    </Text>
                    {meeting.location && (
                      <View style={styles.locationRow}>
                        <IconButton
                          icon="map-marker"
                          size={16}
                          style={styles.locationIcon}
                        />
                        <Text variant="bodySmall">{meeting.location}</Text>
                      </View>
                    )}
                    {meeting.isRecurring && (
                      <Chip icon="repeat" compact style={styles.recurringChip}>
                        {meeting.recurringPattern}
                      </Chip>
                    )}
                  </Card.Content>
                </Card>
              ))
            ) : (
              <View style={styles.emptyTab}>
                <Text variant="bodyLarge">No meetings scheduled</Text>
                <Text variant="bodySmall" style={styles.emptySubText}>
                  {isAdmin
                    ? "Schedule your first meeting for this group"
                    : "There are no upcoming meetings for this group"}
                </Text>
                {isAdmin && (
                  <Button
                    mode="contained"
                    icon="calendar-plus"
                    style={styles.emptyButton}
                    onPress={() => {
                      /* Navigate to create meeting screen */
                    }}
                  >
                    Schedule Meeting
                  </Button>
                )}
              </View>
            )}
          </View>
        )}

        {/* Members Tab */}
        {activeTab === 'members' && (
          <View style={styles.tabContent}>
            {isMembersLoading ? (
              <ActivityIndicator style={styles.tabLoader} />
            ) : members && members.length > 0 ? (
              members.map((member) => (
                <List.Item
                  key={member.id}
                  title={member.userName}
                  description={
                    member.role === 'leader'
                      ? 'Group Leader'
                      : member.role === 'admin'
                      ? 'Group Admin'
                      : `Joined ${formatDate(member.joinedAt)}`
                  }
                  left={() => (
                    <Avatar.Text
                      size={40}
                      label={member.userName.substring(0, 2).toUpperCase()}
                      style={
                        member.role === 'leader' || member.role === 'admin'
                          ? { backgroundColor: theme.colors.secondary }
                          : undefined
                      }
                    />
                  )}
                  style={styles.listItem}
                />
              ))
            ) : (
              <View style={styles.emptyTab}>
                <Text variant="bodyLarge">No members yet</Text>
                <Text variant="bodySmall" style={styles.emptySubText}>
                  This group doesn't have any members yet
                </Text>
              </View>
            )}
          </View>
        )}
      </ScrollView>

      {/* FAB for creating content (only show if user is a member) */}
      {group.isJoined && (
        <FAB
          icon={
            activeTab === 'requests'
              ? 'prayer'
              : activeTab === 'meetings'
              ? 'calendar-plus'
              : 'account-plus'
          }
          label={
            activeTab === 'requests'
              ? 'New Prayer'
              : activeTab === 'meetings'
              ? 'Schedule'
              : 'Invite'
          }
          style={[styles.fab, { backgroundColor: theme.colors.primary }]}
          visible={activeTab !== 'members' || isAdmin}
          onPress={() => {
            /* Navigate to appropriate creation screen based on activeTab */
          }}
        />
      )}

      {/* Leave Group Confirmation Modal */}
      <Portal>
        <Modal
          visible={leaveModalVisible}
          onDismiss={() => setLeaveModalVisible(false)}
          contentContainerStyle={styles.modalContainer}
        >
          <Text variant="headlineSmall">Leave Group?</Text>
          <Text variant="bodyMedium" style={styles.modalText}>
            Are you sure you want to leave {group.name}? You'll no longer have access to the group's prayer requests and meetings.
          </Text>
          <View style={styles.modalButtons}>
            <Button
              mode="outlined"
              onPress={() => setLeaveModalVisible(false)}
              style={styles.modalButton}
            >
              Cancel
            </Button>
            <Button
              mode="contained"
              onPress={() => membershipMutation.mutate('leave')}
              style={[styles.modalButton, styles.leaveButton]}
              loading={membershipMutation.isPending}
            >
              Leave
            </Button>
          </View>
        </Modal>
      </Portal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  errorButton: {
    marginTop: 16,
  },
  headerCard: {
    margin: 16,
    marginBottom: 8,
  },
  headerActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  headerTags: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  categoryChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  privacyChip: {
    marginBottom: 8,
  },
  organizationName: {
    marginBottom: 8,
    opacity: 0.6,
  },
  description: {
    marginVertical: 12,
  },
  statsRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginVertical: 16,
  },
  stat: {
    alignItems: 'center',
  },
  actionButton: {
    marginTop: 8,
  },
  tabContainer: {
    flexDirection: 'row',
    margin: 16,
    marginBottom: 0,
  },
  tabButton: {
    flex: 1,
    borderRadius: 0,
  },
  tabContent: {
    padding: 8,
  },
  tabLoader: {
    margin: 24,
  },
  listItem: {
    backgroundColor: 'white',
    marginHorizontal: 8,
    marginVertical: 4,
    borderRadius: 8,
  },
  requestMeta: {
    alignItems: 'flex-end',
  },
  commentCount: {
    backgroundColor: '#e5e5e5',
    borderRadius: 10,
    paddingHorizontal: 6,
    paddingVertical: 2,
    marginTop: 4,
  },
  meetingCard: {
    margin: 8,
  },
  meetingTime: {
    marginVertical: 8,
  },
  locationRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  locationIcon: {
    margin: 0,
    marginLeft: -8,
  },
  recurringChip: {
    marginTop: 8,
    alignSelf: 'flex-start',
  },
  emptyTab: {
    padding: 24,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptySubText: {
    marginTop: 8,
    textAlign: 'center',
    opacity: 0.6,
  },
  emptyButton: {
    marginTop: 16,
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
  },
  modalContainer: {
    backgroundColor: 'white',
    padding: 20,
    margin: 20,
    borderRadius: 8,
  },
  modalText: {
    marginVertical: 16,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  modalButton: {
    marginLeft: 8,
  },
  leaveButton: {
    backgroundColor: '#ef4444',  // red color for leave button
  },
});
```

## File: mobile/src/screens/HomeScreen.tsx
```typescript
import React from 'react';
import { View, StyleSheet, ScrollView, RefreshControl } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '@navigation/MainNavigator';
import { Text, Card, Button, Divider, List, ActivityIndicator, useTheme, Surface } from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { useAuth } from '@hooks/useAuth';
import { apiRequest } from '@/api/queryClient';

// Types for API responses
type Group = {
  id: number;
  name: string;
  description: string;
  memberCount: number;
  category: string;
};

type PrayerRequest = {
  id: number;
  title: string;
  content: string;
  status: string;
  createdAt: string;
  updatedAt: string;
  groupId: number;
  userId: number;
  userName: string;
};

export default function HomeScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();
  const theme = useTheme();
  const { user } = useAuth();
  const [refreshing, setRefreshing] = React.useState(false);

  // Query for user's groups
  const {
    data: groups,
    isLoading: isGroupsLoading,
    refetch: refetchGroups,
  } = useQuery<Group[]>({
    queryKey: ['/api/groups/user'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/groups/user');
      if (!res.ok) throw new Error('Failed to fetch groups');
      return res.json();
    },
  });

  // Query for recent prayer requests
  const {
    data: recentRequests,
    isLoading: isRequestsLoading,
    refetch: refetchRequests,
  } = useQuery<PrayerRequest[]>({
    queryKey: ['/api/requests/user/recent'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/requests/user/recent');
      if (!res.ok) throw new Error('Failed to fetch recent requests');
      return res.json();
    },
  });

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([refetchGroups(), refetchRequests()]);
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refetchGroups, refetchRequests]);

  const navigateToGroupDetails = (groupId: number) => {
    navigation.navigate('GroupDetails', { groupId });
  };

  const navigateToRequestDetails = (requestId: number) => {
    navigation.navigate('RequestDetails', { requestId });
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
      }
    >
      {/* Welcome Section */}
      <Surface style={styles.welcomeSection}>
        <Text variant="headlineSmall">Welcome back, {user?.name}!</Text>
        <Text variant="bodyMedium" style={{ marginTop: 5 }}>
          Your prayer journey continues today.
        </Text>
      </Surface>

      {/* My Groups Section */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text variant="titleLarge">My Groups</Text>
          <Button
            mode="text"
            onPress={() => navigation.navigate('Explore')}
          >
            Explore More
          </Button>
        </View>

        {isGroupsLoading ? (
          <ActivityIndicator style={styles.loader} />
        ) : groups && groups.length > 0 ? (
          <ScrollView horizontal showsHorizontalScrollIndicator={false}>
            <View style={styles.groupsContainer}>
              {groups.slice(0, 3).map((group) => (
                <Card
                  key={group.id}
                  style={styles.groupCard}
                  onPress={() => navigateToGroupDetails(group.id)}
                >
                  <Card.Content>
                    <Text variant="titleMedium">{group.name}</Text>
                    <Text variant="bodySmall" style={styles.groupDescription}>
                      {group.description.length > 80
                        ? `${group.description.substring(0, 80)}...`
                        : group.description}
                    </Text>
                    <View style={styles.groupMeta}>
                      <Text variant="labelSmall">{group.memberCount} members</Text>
                      <Text variant="labelSmall" style={styles.groupCategory}>
                        {group.category}
                      </Text>
                    </View>
                  </Card.Content>
                </Card>
              ))}
              
              {groups.length > 3 && (
                <Card
                  style={[styles.groupCard, styles.viewAllCard]}
                  onPress={() => {/* Navigate to all groups */}}
                >
                  <Card.Content style={styles.viewAllContent}>
                    <Text variant="titleMedium">View All</Text>
                    <Text variant="bodySmall">
                      {groups.length - 3} more {groups.length - 3 === 1 ? 'group' : 'groups'}
                    </Text>
                  </Card.Content>
                </Card>
              )}
            </View>
          </ScrollView>
        ) : (
          <Card style={styles.emptyCard}>
            <Card.Content>
              <Text variant="bodyMedium">You haven't joined any groups yet.</Text>
              <Button
                mode="contained"
                style={styles.emptyCardButton}
                onPress={() => navigation.navigate('Explore')}
              >
                Find Groups
              </Button>
            </Card.Content>
          </Card>
        )}
      </View>

      {/* Recent Prayer Requests Section */}
      <View style={styles.section}>
        <View style={styles.sectionHeader}>
          <Text variant="titleLarge">Recent Prayer Requests</Text>
          <Button
            mode="text"
            onPress={() => {/* Navigate to all prayer requests */}}
          >
            View All
          </Button>
        </View>

        {isRequestsLoading ? (
          <ActivityIndicator style={styles.loader} />
        ) : recentRequests && recentRequests.length > 0 ? (
          <View style={styles.requestsContainer}>
            {recentRequests.slice(0, 5).map((request) => (
              <List.Item
                key={request.id}
                title={request.title}
                description={
                  request.content.length > 100
                    ? `${request.content.substring(0, 100)}...`
                    : request.content
                }
                onPress={() => navigateToRequestDetails(request.id)}
                left={(props) => (
                  <List.Icon
                    {...props}
                    icon={
                      request.status === 'answered'
                        ? 'check-circle'
                        : request.status === 'in-progress'
                        ? 'clock-outline'
                        : 'prayer'
                    }
                  />
                )}
                right={(props) => (
                  <Text {...props} variant="bodySmall">
                    {formatDate(request.createdAt)}
                  </Text>
                )}
                style={styles.requestItem}
              />
            ))}
          </View>
        ) : (
          <Card style={styles.emptyCard}>
            <Card.Content>
              <Text variant="bodyMedium">No prayer requests yet.</Text>
              <Button
                mode="contained"
                style={styles.emptyCardButton}
                onPress={() => {/* Navigate to create prayer request */}}
              >
                Create Request
              </Button>
            </Card.Content>
          </Card>
        )}
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  contentContainer: {
    padding: 16,
  },
  welcomeSection: {
    padding: 16,
    marginBottom: 16,
    borderRadius: 8,
    elevation: 1,
  },
  section: {
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  loader: {
    marginVertical: 20,
  },
  groupsContainer: {
    flexDirection: 'row',
    paddingRight: 16,
  },
  groupCard: {
    width: 260,
    marginRight: 12,
  },
  groupDescription: {
    marginTop: 4,
    marginBottom: 8,
  },
  groupMeta: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  groupCategory: {
    textTransform: 'uppercase',
  },
  viewAllCard: {
    backgroundColor: '#f0f0f0',
  },
  viewAllContent: {
    justifyContent: 'center',
    alignItems: 'center',
    height: '100%',
  },
  requestsContainer: {
    backgroundColor: 'white',
    borderRadius: 8,
    overflow: 'hidden',
    elevation: 1,
  },
  requestItem: {
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  emptyCard: {
    alignItems: 'center',
    padding: 16,
  },
  emptyCardButton: {
    marginTop: 16,
  },
});
```

## File: mobile/src/screens/MeetingDetailsScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, RefreshControl, Linking } from 'react-native';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  Card,
  Button,
  IconButton,
  Chip,
  Portal,
  Dialog,
  ActivityIndicator,
  useTheme,
  Divider,
  Avatar,
  List,
  Surface,
} from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@hooks/useAuth';
import { apiRequest } from '@/api/queryClient';

// Types for API responses
type Meeting = {
  id: number;
  title: string;
  description: string;
  startTime: string;
  endTime: string;
  location: string;
  isVirtual: boolean;
  virtualMeetingUrl?: string;
  isRecurring: boolean;
  recurringPattern: string;
  groupId: number;
  groupName: string;
  organizationId: number;
  createdBy: number;
  creatorName: string;
  isOwner: boolean;
  attendeeCount: number;
  isAttending: boolean;
};

type Attendee = {
  id: number;
  userId: number;
  userName: string;
  userAvatar?: string;
  status: string;
  isGroup: boolean;
};

export default function MeetingDetailsScreen() {
  const route = useRoute<RouteProp<HomeStackParamList, 'MeetingDetails'>>();
  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();
  const theme = useTheme();
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { meetingId } = route.params;
  
  const [refreshing, setRefreshing] = useState(false);
  const [deleteDialogVisible, setDeleteDialogVisible] = useState(false);
  const [attendanceStatus, setAttendanceStatus] = useState<'attending' | 'not-attending' | 'maybe'>();

  // Fetch meeting details
  const { 
    data: meeting, 
    isLoading: isMeetingLoading,
    refetch: refetchMeeting,
  } = useQuery<Meeting>({
    queryKey: [`/api/meetings/${meetingId}`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/meetings/${meetingId}`);
      if (!res.ok) throw new Error('Failed to fetch meeting details');
      return res.json();
    },
  });

  // Fetch meeting attendees
  const {
    data: attendees,
    isLoading: isAttendeesLoading,
    refetch: refetchAttendees,
  } = useQuery<Attendee[]>({
    queryKey: [`/api/meetings/${meetingId}/attendees`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/meetings/${meetingId}/attendees`);
      if (!res.ok) throw new Error('Failed to fetch attendees');
      return res.json();
    },
  });

  // Update attendance status mutation
  const updateAttendanceMutation = useMutation({
    mutationFn: async (status: string) => {
      const res = await apiRequest('POST', `/api/meetings/${meetingId}/attendance`, { status });
      if (!res.ok) throw new Error('Failed to update attendance status');
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/meetings/${meetingId}`] });
      queryClient.invalidateQueries({ queryKey: [`/api/meetings/${meetingId}/attendees`] });
    },
  });

  // Delete meeting mutation
  const deleteMeetingMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest('DELETE', `/api/meetings/${meetingId}`);
      if (!res.ok) throw new Error('Failed to delete meeting');
      return res.json();
    },
    onSuccess: () => {
      navigation.goBack();
      queryClient.invalidateQueries({ queryKey: ['/api/meetings/upcoming'] });
      if (meeting?.groupId) {
        queryClient.invalidateQueries({ queryKey: [`/api/groups/${meeting.groupId}/meetings`] });
      }
    },
  });

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([
        refetchMeeting(),
        refetchAttendees(),
      ]);
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refetchMeeting, refetchAttendees]);

  const handleDeleteMeeting = () => {
    deleteMeetingMutation.mutate();
    setDeleteDialogVisible(false);
  };

  const handleAttendance = (status: 'attending' | 'not-attending' | 'maybe') => {
    setAttendanceStatus(status);
    updateAttendanceMutation.mutate(status);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  };

  const formatTime = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleTimeString(undefined, {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true,
    });
  };

  const openMaps = (location: string) => {
    const url = `https://maps.google.com/?q=${encodeURIComponent(location)}`;
    Linking.openURL(url);
  };

  const joinVirtualMeeting = (url?: string) => {
    if (url) {
      Linking.openURL(url);
    }
  };

  if (isMeetingLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (!meeting) {
    return (
      <View style={styles.errorContainer}>
        <Text variant="headlineSmall">Meeting not found</Text>
        <Button 
          mode="contained"
          onPress={() => navigation.goBack()}
          style={styles.errorButton}
        >
          Go Back
        </Button>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        style={styles.scrollView}
        contentContainerStyle={styles.contentContainer}
      >
        {/* Meeting Card */}
        <Card style={styles.meetingCard}>
          <Card.Content>
            <View style={styles.cardHeader}>
              <Text variant="bodySmall" style={styles.groupName}>
                {meeting.groupName}
              </Text>
              
              {meeting.isOwner && (
                <View style={styles.actionButtons}>
                  <IconButton
                    icon="pencil"
                    size={20}
                    onPress={() => {
                      /* Navigate to edit meeting screen */
                    }}
                  />
                  <IconButton
                    icon="delete"
                    size={20}
                    onPress={() => setDeleteDialogVisible(true)}
                  />
                </View>
              )}
            </View>
            
            <Text variant="headlineMedium" style={styles.title}>
              {meeting.title}
            </Text>
            
            <View style={styles.hostInfo}>
              <Text variant="bodyMedium">Hosted by </Text>
              <Avatar.Text
                size={24}
                label={meeting.creatorName.substring(0, 2).toUpperCase()}
                style={styles.hostAvatar}
              />
              <Text variant="bodyMedium" style={styles.hostName}>
                {meeting.creatorName}
              </Text>
            </View>
            
            {meeting.isRecurring && (
              <Chip icon="repeat" mode="outlined" style={styles.recurringChip}>
                {meeting.recurringPattern}
              </Chip>
            )}
            
            <Divider style={styles.divider} />
            
            {/* Date/Time */}
            <View style={styles.infoSection}>
              <IconButton
                icon="calendar"
                size={24}
                style={styles.infoIcon}
              />
              <View style={styles.infoContent}>
                <Text variant="bodyLarge" style={styles.infoTitle}>
                  {formatDate(meeting.startTime)}
                </Text>
                <Text variant="bodyMedium">
                  {formatTime(meeting.startTime)} - {formatTime(meeting.endTime)}
                </Text>
              </View>
            </View>
            
            {/* Location */}
            {meeting.location && (
              <View style={styles.infoSection}>
                <IconButton
                  icon="map-marker"
                  size={24}
                  style={styles.infoIcon}
                />
                <View style={styles.infoContent}>
                  <Text variant="bodyLarge" style={styles.infoTitle}>
                    {meeting.isVirtual ? 'Virtual Meeting' : 'Location'}
                  </Text>
                  <Text variant="bodyMedium">
                    {meeting.location}
                  </Text>
                  
                  {!meeting.isVirtual && (
                    <Button
                      mode="text"
                      icon="map"
                      onPress={() => openMaps(meeting.location)}
                      style={styles.locationButton}
                    >
                      View on Map
                    </Button>
                  )}
                  
                  {meeting.isVirtual && meeting.virtualMeetingUrl && (
                    <Button
                      mode="contained"
                      icon="video"
                      onPress={() => joinVirtualMeeting(meeting.virtualMeetingUrl)}
                      style={styles.joinButton}
                    >
                      Join Meeting
                    </Button>
                  )}
                </View>
              </View>
            )}
            
            {/* Description */}
            {meeting.description && (
              <View style={styles.descriptionContainer}>
                <Text variant="titleMedium" style={styles.descriptionTitle}>
                  About this meeting
                </Text>
                <Text variant="bodyMedium" style={styles.description}>
                  {meeting.description}
                </Text>
              </View>
            )}
            
            <Divider style={styles.divider} />
            
            {/* Attendance Buttons */}
            <View style={styles.attendanceContainer}>
              <Text variant="titleMedium" style={styles.attendanceTitle}>
                Are you going?
              </Text>
              <View style={styles.attendanceButtons}>
                <Button
                  mode={meeting.isAttending ? 'contained' : 'outlined'}
                  icon="check"
                  onPress={() => handleAttendance('attending')}
                  style={styles.attendanceButton}
                  loading={updateAttendanceMutation.isPending && attendanceStatus === 'attending'}
                >
                  Yes
                </Button>
                <Button
                  mode="outlined"
                  icon="close"
                  onPress={() => handleAttendance('not-attending')}
                  style={styles.attendanceButton}
                  loading={updateAttendanceMutation.isPending && attendanceStatus === 'not-attending'}
                >
                  No
                </Button>
                <Button
                  mode="outlined"
                  icon="help"
                  onPress={() => handleAttendance('maybe')}
                  style={styles.attendanceButton}
                  loading={updateAttendanceMutation.isPending && attendanceStatus === 'maybe'}
                >
                  Maybe
                </Button>
              </View>
            </View>
          </Card.Content>
        </Card>

        {/* Attendees Section */}
        <Surface style={styles.attendeesSection}>
          <Text variant="titleMedium" style={styles.attendeesHeader}>
            Attendees ({meeting.attendeeCount})
          </Text>
          
          {isAttendeesLoading ? (
            <ActivityIndicator style={styles.attendeesLoader} />
          ) : attendees && attendees.length > 0 ? (
            attendees.map((attendee) => (
              <List.Item
                key={attendee.id}
                title={attendee.userName}
                description={
                  attendee.isGroup
                    ? 'Entire Group'
                    : attendee.status === 'attending'
                    ? 'Going'
                    : attendee.status === 'maybe'
                    ? 'Maybe'
                    : 'Not Going'
                }
                left={() => (
                  <Avatar.Text
                    size={40}
                    label={attendee.userName.substring(0, 2).toUpperCase()}
                    style={[
                      styles.attendeeAvatar,
                      {
                        backgroundColor:
                          attendee.status === 'attending'
                            ? '#10b981' // green
                            : attendee.status === 'maybe'
                            ? '#f59e0b' // amber
                            : '#ef4444', // red
                      },
                    ]}
                  />
                )}
                style={styles.attendeeItem}
              />
            ))
          ) : (
            <Text variant="bodyMedium" style={styles.noAttendeesText}>
              No one has RSVP'd yet
            </Text>
          )}
        </Surface>
      </ScrollView>

      {/* Delete Confirmation Dialog */}
      <Portal>
        <Dialog visible={deleteDialogVisible} onDismiss={() => setDeleteDialogVisible(false)}>
          <Dialog.Title>Delete Meeting?</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              Are you sure you want to delete this meeting? All attendees will be notified that the meeting has been cancelled. This action cannot be undone.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setDeleteDialogVisible(false)}>Cancel</Button>
            <Button
              onPress={handleDeleteMeeting}
              textColor="#ef4444"
              loading={deleteMeetingMutation.isPending}
            >
              Delete
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  errorButton: {
    marginTop: 16,
  },
  meetingCard: {
    marginBottom: 16,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  groupName: {
    fontWeight: 'bold',
  },
  actionButtons: {
    flexDirection: 'row',
  },
  title: {
    marginBottom: 8,
  },
  hostInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  hostAvatar: {
    marginHorizontal: 8,
  },
  hostName: {
    fontWeight: 'bold',
  },
  recurringChip: {
    alignSelf: 'flex-start',
    marginBottom: 16,
  },
  divider: {
    marginVertical: 16,
  },
  infoSection: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  infoIcon: {
    margin: 0,
  },
  infoContent: {
    flex: 1,
    marginLeft: 8,
  },
  infoTitle: {
    fontWeight: 'bold',
    marginBottom: 4,
  },
  locationButton: {
    alignSelf: 'flex-start',
    marginTop: 8,
  },
  joinButton: {
    alignSelf: 'flex-start',
    marginTop: 8,
  },
  descriptionContainer: {
    marginVertical: 16,
  },
  descriptionTitle: {
    marginBottom: 8,
  },
  description: {
    lineHeight: 24,
  },
  attendanceContainer: {
    marginVertical: 8,
  },
  attendanceTitle: {
    marginBottom: 12,
  },
  attendanceButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  attendanceButton: {
    flex: 1,
    marginHorizontal: 4,
  },
  attendeesSection: {
    padding: 16,
    borderRadius: 8,
  },
  attendeesHeader: {
    marginBottom: 16,
  },
  attendeesLoader: {
    margin: 16,
  },
  attendeeItem: {
    paddingVertical: 8,
  },
  attendeeAvatar: {
    marginRight: 8,
  },
  noAttendeesText: {
    textAlign: 'center',
    opacity: 0.7,
    paddingVertical: 16,
  },
});
```

## File: mobile/src/screens/OrganizationDetailsScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, RefreshControl, Share, Clipboard } from 'react-native';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { SettingsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  Card,
  Button,
  IconButton,
  Portal,
  Dialog,
  TextInput,
  ActivityIndicator,
  useTheme,
  Avatar,
  List,
  Divider,
  Surface,
  Snackbar,
  Menu,
  TouchableRipple,
} from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@hooks/useAuth';
import { apiRequest } from '@/api/queryClient';

// Types for API responses
type OrganizationDetails = {
  id: number;
  name: string;
  description: string;
  website: string;
  inviteCode: string;
  memberCount: number;
  groupCount: number;
  isAdmin: boolean;
  createdAt: string;
};

type OrganizationMember = {
  id: number;
  userId: number;
  userName: string;
  userAvatar?: string;
  isAdmin: boolean;
  joinedAt: string;
};

export default function OrganizationDetailsScreen() {
  const route = useRoute<RouteProp<SettingsStackParamList, 'OrganizationDetails'>>();
  const navigation = useNavigation<NativeStackNavigationProp<SettingsStackParamList>>();
  const theme = useTheme();
  const { user, refreshUser } = useAuth();
  const queryClient = useQueryClient();
  const { organizationId } = route.params;
  
  const [refreshing, setRefreshing] = useState(false);
  const [activeTab, setActiveTab] = useState<'details' | 'members'>('details');
  const [editOrgDialogVisible, setEditOrgDialogVisible] = useState(false);
  const [editOrgName, setEditOrgName] = useState('');
  const [editOrgDescription, setEditOrgDescription] = useState('');
  const [editOrgWebsite, setEditOrgWebsite] = useState('');
  const [inviteDialogVisible, setInviteDialogVisible] = useState(false);
  const [inviteEmail, setInviteEmail] = useState('');
  const [regenerateCodeDialogVisible, setRegenerateCodeDialogVisible] = useState(false);
  const [removeDialogVisible, setRemoveDialogVisible] = useState(false);
  const [removeUserId, setRemoveUserId] = useState<number | null>(null);
  const [removeUserName, setRemoveUserName] = useState('');
  const [transferDialogVisible, setTransferDialogVisible] = useState(false);
  const [transferUserId, setTransferUserId] = useState<number | null>(null);
  const [transferUserName, setTransferUserName] = useState('');
  const [manageMenuVisible, setManageMenuVisible] = useState(false);
  const [memberMenuVisible, setMemberMenuVisible] = useState(false);
  const [selectedMemberId, setSelectedMemberId] = useState<number | null>(null);
  const [selectedMemberName, setSelectedMemberName] = useState('');
  const [selectedMemberIsAdmin, setSelectedMemberIsAdmin] = useState(false);
  const [snackbarVisible, setSnackbarVisible] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');

  // Fetch organization details
  const { 
    data: organization, 
    isLoading: isOrgLoading,
    refetch: refetchOrg,
  } = useQuery<OrganizationDetails>({
    queryKey: [`/api/organizations/${organizationId}`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/organizations/${organizationId}`);
      if (!res.ok) throw new Error('Failed to fetch organization details');
      return res.json();
    },
  });

  // Fetch organization members
  const {
    data: members,
    isLoading: isMembersLoading,
    refetch: refetchMembers,
  } = useQuery<OrganizationMember[]>({
    queryKey: [`/api/organizations/${organizationId}/members`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/organizations/${organizationId}/members`);
      if (!res.ok) throw new Error('Failed to fetch organization members');
      return res.json();
    },
  });

  // Update organization mutation
  const updateOrgMutation = useMutation({
    mutationFn: async (data: { name: string; description: string; website: string }) => {
      const res = await apiRequest('PUT', `/api/organizations/${organizationId}`, data);
      if (!res.ok) throw new Error('Failed to update organization');
      return res.json();
    },
    onSuccess: () => {
      setEditOrgDialogVisible(false);
      queryClient.invalidateQueries({ queryKey: [`/api/organizations/${organizationId}`] });
      queryClient.invalidateQueries({ queryKey: ['/api/organizations'] });
    },
  });

  // Regenerate invite code mutation
  const regenerateCodeMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest('POST', `/api/organizations/${organizationId}/regenerate-code`);
      if (!res.ok) throw new Error('Failed to regenerate invite code');
      return res.json();
    },
    onSuccess: () => {
      setRegenerateCodeDialogVisible(false);
      queryClient.invalidateQueries({ queryKey: [`/api/organizations/${organizationId}`] });
      showSnackbar('Invite code regenerated successfully');
    },
  });

  // Invite member mutation
  const inviteMemberMutation = useMutation({
    mutationFn: async (email: string) => {
      const res = await apiRequest('POST', `/api/organizations/${organizationId}/invite`, { email });
      if (!res.ok) throw new Error('Failed to send invitation');
      return res.json();
    },
    onSuccess: () => {
      setInviteDialogVisible(false);
      setInviteEmail('');
      showSnackbar('Invitation sent successfully');
    },
  });

  // Update member role mutation
  const updateMemberRoleMutation = useMutation({
    mutationFn: async ({ userId, isAdmin }: { userId: number; isAdmin: boolean }) => {
      const res = await apiRequest('PUT', `/api/organizations/${organizationId}/members/${userId}`, { isAdmin });
      if (!res.ok) throw new Error('Failed to update member role');
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/organizations/${organizationId}/members`] });
      showSnackbar('Member role updated');
    },
  });

  // Remove member mutation
  const removeMemberMutation = useMutation({
    mutationFn: async (userId: number) => {
      const res = await apiRequest('DELETE', `/api/organizations/${organizationId}/members/${userId}`);
      if (!res.ok) throw new Error('Failed to remove member');
      return res.json();
    },
    onSuccess: () => {
      setRemoveDialogVisible(false);
      queryClient.invalidateQueries({ queryKey: [`/api/organizations/${organizationId}/members`] });
      queryClient.invalidateQueries({ queryKey: [`/api/organizations/${organizationId}`] });
      showSnackbar('Member removed successfully');
    },
  });

  // Transfer ownership mutation
  const transferOwnershipMutation = useMutation({
    mutationFn: async (userId: number) => {
      const res = await apiRequest('POST', `/api/organizations/${organizationId}/transfer`, { userId });
      if (!res.ok) throw new Error('Failed to transfer ownership');
      return res.json();
    },
    onSuccess: () => {
      setTransferDialogVisible(false);
      queryClient.invalidateQueries({ queryKey: [`/api/organizations/${organizationId}/members`] });
      showSnackbar('Organization ownership transferred');
    },
  });

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([
        refetchOrg(),
        refetchMembers(),
      ]);
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refetchOrg, refetchMembers]);

  const handleOpenEditDialog = () => {
    if (organization) {
      setEditOrgName(organization.name);
      setEditOrgDescription(organization.description || '');
      setEditOrgWebsite(organization.website || '');
      setEditOrgDialogVisible(true);
    }
  };

  const handleUpdateOrg = () => {
    if (editOrgName.trim()) {
      updateOrgMutation.mutate({
        name: editOrgName.trim(),
        description: editOrgDescription.trim(),
        website: editOrgWebsite.trim(),
      });
    }
  };

  const handleInviteMember = () => {
    if (inviteEmail.trim()) {
      inviteMemberMutation.mutate(inviteEmail.trim());
    }
  };

  const handleCopyInviteCode = () => {
    if (organization?.inviteCode) {
      Clipboard.setString(organization.inviteCode);
      showSnackbar('Invite code copied to clipboard');
    }
  };

  const handleShareInviteCode = async () => {
    if (organization?.inviteCode) {
      try {
        await Share.share({
          message: `Join ${organization.name} on Prayer Pipeline using invite code: ${organization.inviteCode}`,
        });
      } catch (error) {
        console.error('Error sharing invite code:', error);
      }
    }
  };

  const handleToggleAdminRole = (userId: number, isCurrentlyAdmin: boolean) => {
    updateMemberRoleMutation.mutate({
      userId,
      isAdmin: !isCurrentlyAdmin,
    });
  };

  const openRemoveDialog = (userId: number, userName: string) => {
    setRemoveUserId(userId);
    setRemoveUserName(userName);
    setRemoveDialogVisible(true);
  };

  const handleRemoveMember = () => {
    if (removeUserId) {
      removeMemberMutation.mutate(removeUserId);
    }
  };

  const openTransferDialog = (userId: number, userName: string) => {
    setTransferUserId(userId);
    setTransferUserName(userName);
    setTransferDialogVisible(true);
  };

  const handleTransferOwnership = () => {
    if (transferUserId) {
      transferOwnershipMutation.mutate(transferUserId);
    }
  };

  const showSnackbar = (message: string) => {
    setSnackbarMessage(message);
    setSnackbarVisible(true);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  if (isOrgLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (!organization) {
    return (
      <View style={styles.errorContainer}>
        <Text variant="headlineSmall">Organization not found</Text>
        <Button 
          mode="contained"
          onPress={() => navigation.goBack()}
          style={styles.errorButton}
        >
          Go Back
        </Button>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        style={styles.scrollView}
        contentContainerStyle={styles.contentContainer}
      >
        {/* Organization Header */}
        <Surface style={styles.header}>
          <View style={styles.headerContent}>
            <Avatar.Text
              size={60}
              label={organization.name.substring(0, 2).toUpperCase()}
              style={styles.orgAvatar}
            />
            <View style={styles.headerInfo}>
              <Text variant="headlineSmall">{organization.name}</Text>
              <Text variant="bodyMedium" style={styles.headerStats}>
                {organization.memberCount} {organization.memberCount === 1 ? 'member' : 'members'} · {organization.groupCount} {organization.groupCount === 1 ? 'group' : 'groups'}
              </Text>
            </View>
            
            {organization.isAdmin && (
              <Menu
                visible={manageMenuVisible}
                onDismiss={() => setManageMenuVisible(false)}
                anchor={
                  <IconButton
                    icon="dots-vertical"
                    size={24}
                    onPress={() => setManageMenuVisible(true)}
                  />
                }
              >
                <Menu.Item
                  title="Edit Organization"
                  leadingIcon="pencil"
                  onPress={() => {
                    setManageMenuVisible(false);
                    handleOpenEditDialog();
                  }}
                />
                <Menu.Item
                  title="Invite Member"
                  leadingIcon="account-plus"
                  onPress={() => {
                    setManageMenuVisible(false);
                    setInviteDialogVisible(true);
                  }}
                />
                <Menu.Item
                  title="Regenerate Invite Code"
                  leadingIcon="refresh"
                  onPress={() => {
                    setManageMenuVisible(false);
                    setRegenerateCodeDialogVisible(true);
                  }}
                />
              </Menu>
            )}
          </View>
        </Surface>

        {/* Tab Selector */}
        <View style={styles.tabContainer}>
          <TouchableRipple
            style={[
              styles.tabButton,
              activeTab === 'details' && styles.activeTabButton,
            ]}
            onPress={() => setActiveTab('details')}
          >
            <Text
              variant="labelLarge"
              style={[
                styles.tabText,
                activeTab === 'details' && styles.activeTabText,
              ]}
            >
              Details
            </Text>
          </TouchableRipple>
          
          <TouchableRipple
            style={[
              styles.tabButton,
              activeTab === 'members' && styles.activeTabButton,
            ]}
            onPress={() => setActiveTab('members')}
          >
            <Text
              variant="labelLarge"
              style={[
                styles.tabText,
                activeTab === 'members' && styles.activeTabText,
              ]}
            >
              Members
            </Text>
          </TouchableRipple>
        </View>

        {/* Details Tab */}
        {activeTab === 'details' && (
          <View style={styles.tabContent}>
            <Card style={styles.detailsCard}>
              <Card.Content>
                {organization.description && (
                  <>
                    <Text variant="titleMedium" style={styles.sectionTitle}>
                      About
                    </Text>
                    <Text variant="bodyMedium" style={styles.description}>
                      {organization.description}
                    </Text>
                    <Divider style={styles.divider} />
                  </>
                )}
                
                {organization.website && (
                  <>
                    <Text variant="titleMedium" style={styles.sectionTitle}>
                      Website
                    </Text>
                    <Text
                      variant="bodyMedium"
                      style={styles.website}
                      onPress={() => Linking.openURL(organization.website)}
                    >
                      {organization.website}
                    </Text>
                    <Divider style={styles.divider} />
                  </>
                )}
                
                <Text variant="titleMedium" style={styles.sectionTitle}>
                  Created
                </Text>
                <Text variant="bodyMedium" style={styles.createdDate}>
                  {formatDate(organization.createdAt)}
                </Text>
                
                {organization.isAdmin && (
                  <>
                    <Divider style={styles.divider} />
                    <Text variant="titleMedium" style={styles.sectionTitle}>
                      Invite Code
                    </Text>
                    <View style={styles.inviteCodeContainer}>
                      <Text variant="bodyMedium" style={styles.inviteCode}>
                        {organization.inviteCode}
                      </Text>
                      <View style={styles.inviteCodeActions}>
                        <IconButton
                          icon="content-copy"
                          size={20}
                          onPress={handleCopyInviteCode}
                        />
                        <IconButton
                          icon="share-variant"
                          size={20}
                          onPress={handleShareInviteCode}
                        />
                      </View>
                    </View>
                    <Text variant="bodySmall" style={styles.inviteCodeHelp}>
                      Share this code to allow others to join your organization
                    </Text>
                  </>
                )}
              </Card.Content>
            </Card>
          </View>
        )}

        {/* Members Tab */}
        {activeTab === 'members' && (
          <View style={styles.tabContent}>
            {organization.isAdmin && (
              <Button
                mode="contained"
                icon="account-plus"
                onPress={() => setInviteDialogVisible(true)}
                style={styles.inviteButton}
              >
                Invite Member
              </Button>
            )}
            
            {isMembersLoading ? (
              <ActivityIndicator style={styles.loader} />
            ) : members && members.length > 0 ? (
              <Card style={styles.membersCard}>
                {members.map((member) => (
                  <React.Fragment key={member.id}>
                    <List.Item
                      title={member.userName}
                      description={
                        member.isAdmin
                          ? 'Administrator'
                          : `Joined ${formatDate(member.joinedAt)}`
                      }
                      left={() => (
                        <Avatar.Text
                          size={40}
                          label={member.userName.substring(0, 2).toUpperCase()}
                          style={[
                            styles.memberAvatar,
                            member.isAdmin && { backgroundColor: theme.colors.secondary },
                          ]}
                        />
                      )}
                      right={() => (
                        organization.isAdmin && member.userId !== user?.id ? (
                          <IconButton
                            icon="dots-vertical"
                            onPress={() => {
                              setSelectedMemberId(member.userId);
                              setSelectedMemberName(member.userName);
                              setSelectedMemberIsAdmin(member.isAdmin);
                              setMemberMenuVisible(true);
                            }}
                          />
                        ) : null
                      )}
                    />
                    <Divider style={styles.memberDivider} />
                  </React.Fragment>
                ))}
              </Card>
            ) : (
              <Card style={styles.emptyCard}>
                <Card.Content>
                  <Text variant="bodyLarge" style={styles.emptyText}>
                    No members found
                  </Text>
                </Card.Content>
              </Card>
            )}
          </View>
        )}
      </ScrollView>

      {/* Member Menu */}
      <Portal>
        <Menu
          visible={memberMenuVisible}
          onDismiss={() => setMemberMenuVisible(false)}
          anchor={{ x: 0, y: 0 }}
          style={styles.memberMenu}
        >
          <Menu.Item
            title={selectedMemberIsAdmin ? "Remove Admin Role" : "Make Admin"}
            leadingIcon={selectedMemberIsAdmin ? "account" : "shield-account"}
            onPress={() => {
              setMemberMenuVisible(false);
              if (selectedMemberId !== null) {
                handleToggleAdminRole(selectedMemberId, selectedMemberIsAdmin);
              }
            }}
          />
          <Menu.Item
            title="Transfer Ownership"
            leadingIcon="crown"
            onPress={() => {
              setMemberMenuVisible(false);
              if (selectedMemberId !== null) {
                openTransferDialog(selectedMemberId, selectedMemberName);
              }
            }}
          />
          <Menu.Item
            title="Remove from Organization"
            leadingIcon="account-remove"
            onPress={() => {
              setMemberMenuVisible(false);
              if (selectedMemberId !== null) {
                openRemoveDialog(selectedMemberId, selectedMemberName);
              }
            }}
          />
        </Menu>
      </Portal>

      {/* Edit Organization Dialog */}
      <Portal>
        <Dialog visible={editOrgDialogVisible} onDismiss={() => setEditOrgDialogVisible(false)}>
          <Dialog.Title>Edit Organization</Dialog.Title>
          <Dialog.Content>
            <TextInput
              label="Organization Name *"
              value={editOrgName}
              onChangeText={setEditOrgName}
              mode="outlined"
              style={styles.dialogInput}
            />
            <TextInput
              label="Description"
              value={editOrgDescription}
              onChangeText={setEditOrgDescription}
              mode="outlined"
              multiline
              numberOfLines={3}
              style={styles.dialogInput}
            />
            <TextInput
              label="Website"
              value={editOrgWebsite}
              onChangeText={setEditOrgWebsite}
              mode="outlined"
              style={styles.dialogInput}
              keyboardType="url"
              autoCapitalize="none"
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setEditOrgDialogVisible(false)}>Cancel</Button>
            <Button
              mode="contained"
              onPress={handleUpdateOrg}
              loading={updateOrgMutation.isPending}
              disabled={!editOrgName.trim()}
            >
              Save
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Invite Member Dialog */}
      <Portal>
        <Dialog visible={inviteDialogVisible} onDismiss={() => setInviteDialogVisible(false)}>
          <Dialog.Title>Invite Member</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium" style={styles.dialogText}>
              Enter the email address of the person you want to invite:
            </Text>
            <TextInput
              label="Email Address"
              value={inviteEmail}
              onChangeText={setInviteEmail}
              mode="outlined"
              style={styles.dialogInput}
              keyboardType="email-address"
              autoCapitalize="none"
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setInviteDialogVisible(false)}>Cancel</Button>
            <Button
              mode="contained"
              onPress={handleInviteMember}
              loading={inviteMemberMutation.isPending}
              disabled={!inviteEmail.trim()}
            >
              Send Invite
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Regenerate Invite Code Dialog */}
      <Portal>
        <Dialog visible={regenerateCodeDialogVisible} onDismiss={() => setRegenerateCodeDialogVisible(false)}>
          <Dialog.Title>Regenerate Invite Code?</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              This will invalidate the current invite code. Anyone with the old code will no longer be able to join the organization. Are you sure you want to proceed?
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setRegenerateCodeDialogVisible(false)}>
              Cancel
            </Button>
            <Button
              mode="contained"
              onPress={() => regenerateCodeMutation.mutate()}
              loading={regenerateCodeMutation.isPending}
            >
              Regenerate
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Remove Member Dialog */}
      <Portal>
        <Dialog visible={removeDialogVisible} onDismiss={() => setRemoveDialogVisible(false)}>
          <Dialog.Title>Remove Member?</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              Are you sure you want to remove {removeUserName} from this organization? They will lose access to all groups and prayer requests in this organization.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setRemoveDialogVisible(false)}>Cancel</Button>
            <Button
              onPress={handleRemoveMember}
              textColor="#ef4444"
              loading={removeMemberMutation.isPending}
            >
              Remove
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Transfer Ownership Dialog */}
      <Portal>
        <Dialog visible={transferDialogVisible} onDismiss={() => setTransferDialogVisible(false)}>
          <Dialog.Title>Transfer Ownership?</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              Are you sure you want to transfer ownership of this organization to {transferUserName}? 
              You will retain admin privileges, but {transferUserName} will become the primary owner with full control over the organization.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setTransferDialogVisible(false)}>Cancel</Button>
            <Button
              mode="contained"
              onPress={handleTransferOwnership}
              loading={transferOwnershipMutation.isPending}
            >
              Transfer
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Snackbar */}
      <Snackbar
        visible={snackbarVisible}
        onDismiss={() => setSnackbarVisible(false)}
        duration={3000}
        action={{
          label: 'Dismiss',
          onPress: () => setSnackbarVisible(false),
        }}
      >
        {snackbarMessage}
      </Snackbar>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    paddingBottom: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  errorButton: {
    marginTop: 16,
  },
  header: {
    padding: 16,
    marginBottom: 16,
    elevation: 1,
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  orgAvatar: {
    marginRight: 16,
  },
  headerInfo: {
    flex: 1,
  },
  headerStats: {
    marginTop: 4,
    opacity: 0.7,
  },
  tabContainer: {
    flexDirection: 'row',
    backgroundColor: 'white',
    marginBottom: 16,
  },
  tabButton: {
    flex: 1,
    alignItems: 'center',
    paddingVertical: 16,
  },
  activeTabButton: {
    borderBottomWidth: 2,
    borderBottomColor: '#6366f1',
  },
  tabText: {
    color: '#64748b',
  },
  activeTabText: {
    color: '#6366f1',
  },
  tabContent: {
    paddingHorizontal: 16,
  },
  detailsCard: {
    marginBottom: 16,
  },
  sectionTitle: {
    marginBottom: 8,
  },
  description: {
    marginBottom: 16,
    lineHeight: 24,
  },
  divider: {
    marginVertical: 16,
  },
  website: {
    marginBottom: 16,
    color: '#6366f1',
    textDecorationLine: 'underline',
  },
  createdDate: {
    marginBottom: 16,
  },
  inviteCodeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#f1f5f9',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    marginVertical: 8,
  },
  inviteCode: {
    fontFamily: 'monospace',
    letterSpacing: 1,
  },
  inviteCodeActions: {
    flexDirection: 'row',
  },
  inviteCodeHelp: {
    opacity: 0.6,
  },
  inviteButton: {
    marginBottom: 16,
  },
  membersCard: {
    marginBottom: 16,
  },
  memberAvatar: {
    marginRight: 8,
  },
  memberDivider: {
    height: 1,
    marginLeft: 72,
  },
  loader: {
    marginVertical: 24,
  },
  emptyCard: {
    padding: 16,
    alignItems: 'center',
  },
  emptyText: {
    textAlign: 'center',
    opacity: 0.7,
    padding: 16,
  },
  memberMenu: {
    position: 'absolute',
    right: 16,
    top: 100,
  },
  dialogText: {
    marginBottom: 16,
  },
  dialogInput: {
    marginBottom: 12,
  },
});
```

## File: mobile/src/screens/OrganizationOnboardingScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, Image } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RootStackParamList } from '@navigation/AppNavigator';
import {
  Text,
  Card,
  Button,
  Portal,
  Dialog,
  TextInput,
  ActivityIndicator,
  useTheme,
  SegmentedButtons,
  Divider,
} from 'react-native-paper';
import { useMutation } from '@tanstack/react-query';
import { useAuth } from '@hooks/useAuth';
import { apiRequest } from '@/api/queryClient';

export default function OrganizationOnboardingScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<RootStackParamList>>();
  const theme = useTheme();
  const { refreshUser } = useAuth();
  
  const [activeOption, setActiveOption] = useState<'create' | 'join'>('create');
  
  // Create organization state
  const [orgName, setOrgName] = useState('');
  const [orgDescription, setOrgDescription] = useState('');
  const [orgWebsite, setOrgWebsite] = useState('');
  
  // Join organization state
  const [inviteCode, setInviteCode] = useState('');

  // Error handling
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Create organization mutation
  const createOrgMutation = useMutation({
    mutationFn: async (data: { name: string; description: string; website: string }) => {
      const res = await apiRequest('POST', '/api/organizations', data);
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to create organization' }));
        throw new Error(error.message || 'Failed to create organization');
      }
      return res.json();
    },
    onSuccess: () => {
      refreshUser();
      navigation.navigate('Main');
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  // Join with invite code mutation
  const joinWithCodeMutation = useMutation({
    mutationFn: async (code: string) => {
      const res = await apiRequest('POST', '/api/organizations/join', { code });
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Invalid invite code' }));
        throw new Error(error.message || 'Invalid invite code');
      }
      return res.json();
    },
    onSuccess: () => {
      refreshUser();
      navigation.navigate('Main');
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const handleCreateOrg = () => {
    if (orgName.trim()) {
      createOrgMutation.mutate({
        name: orgName.trim(),
        description: orgDescription.trim(),
        website: orgWebsite.trim(),
      });
    } else {
      setErrorMessage('Organization name is required');
      setErrorDialogVisible(true);
    }
  };

  const handleJoinWithCode = () => {
    if (inviteCode.trim()) {
      joinWithCodeMutation.mutate(inviteCode.trim());
    } else {
      setErrorMessage('Invite code is required');
      setErrorDialogVisible(true);
    }
  };

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <View style={styles.header}>
            <Text variant="headlineMedium" style={styles.title}>
              Join a Community
            </Text>
            <Text variant="bodyLarge" style={styles.subtitle}>
              To use Prayer Pipeline, you need to be part of an organization. You can either create your own or join an existing one.
            </Text>
          </View>

          <SegmentedButtons
            value={activeOption}
            onValueChange={(value) => setActiveOption(value as 'create' | 'join')}
            buttons={[
              { value: 'create', label: 'Create New' },
              { value: 'join', label: 'Join Existing' },
            ]}
            style={styles.segmentedButtons}
          />
          
          <Divider style={styles.divider} />
          
          {/* Create Organization Form */}
          {activeOption === 'create' && (
            <Card style={styles.card}>
              <Card.Content>
                <Text variant="titleMedium" style={styles.cardTitle}>
                  Create a New Organization
                </Text>
                <Text variant="bodyMedium" style={styles.cardDescription}>
                  Start your own community and invite others to join.
                </Text>
                
                <TextInput
                  label="Organization Name *"
                  value={orgName}
                  onChangeText={setOrgName}
                  mode="outlined"
                  style={styles.input}
                />
                
                <TextInput
                  label="Description"
                  value={orgDescription}
                  onChangeText={setOrgDescription}
                  mode="outlined"
                  multiline
                  numberOfLines={3}
                  style={styles.input}
                />
                
                <TextInput
                  label="Website"
                  value={orgWebsite}
                  onChangeText={setOrgWebsite}
                  mode="outlined"
                  keyboardType="url"
                  autoCapitalize="none"
                  style={styles.input}
                />
                
                <Button
                  mode="contained"
                  onPress={handleCreateOrg}
                  style={styles.submitButton}
                  loading={createOrgMutation.isPending}
                  disabled={!orgName.trim() || createOrgMutation.isPending}
                >
                  Create Organization
                </Button>
              </Card.Content>
            </Card>
          )}

          {/* Join Organization Form */}
          {activeOption === 'join' && (
            <Card style={styles.card}>
              <Card.Content>
                <Text variant="titleMedium" style={styles.cardTitle}>
                  Join an Existing Organization
                </Text>
                <Text variant="bodyMedium" style={styles.cardDescription}>
                  Enter the invite code provided by your organization administrator.
                </Text>
                
                <TextInput
                  label="Invite Code *"
                  value={inviteCode}
                  onChangeText={setInviteCode}
                  mode="outlined"
                  autoCapitalize="none"
                  style={styles.input}
                />
                
                <Button
                  mode="contained"
                  onPress={handleJoinWithCode}
                  style={styles.submitButton}
                  loading={joinWithCodeMutation.isPending}
                  disabled={!inviteCode.trim() || joinWithCodeMutation.isPending}
                >
                  Join Organization
                </Button>
              </Card.Content>
            </Card>
          )}
          
          <Text variant="bodySmall" style={styles.helpText}>
            Organizations help keep prayer requests organized and secure. Each organization can have multiple prayer groups.
          </Text>
        </View>
        
        {/* Footer Image */}
        <View style={styles.imageContainer}>
          <Image
            source={require('@/assets/onboarding-illustration.png')}
            style={styles.image}
            resizeMode="contain"
          />
        </View>
      </ScrollView>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 24,
  },
  header: {
    marginBottom: 24,
  },
  title: {
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    textAlign: 'center',
    opacity: 0.7,
  },
  segmentedButtons: {
    marginBottom: 24,
  },
  divider: {
    marginBottom: 24,
  },
  card: {
    marginBottom: 24,
  },
  cardTitle: {
    marginBottom: 8,
  },
  cardDescription: {
    marginBottom: 16,
    opacity: 0.7,
  },
  input: {
    marginBottom: 16,
  },
  submitButton: {
    marginTop: 8,
  },
  helpText: {
    textAlign: 'center',
    opacity: 0.6,
  },
  imageContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 24,
  },
  image: {
    width: '80%',
    height: 180,
  },
});
```

## File: mobile/src/screens/OrganizationsScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, RefreshControl } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { SettingsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  Card,
  Button,
  Portal,
  Dialog,
  TextInput,
  ActivityIndicator,
  useTheme,
  Avatar,
  FAB,
  Divider,
  List,
} from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@hooks/useAuth';
import { apiRequest } from '@/api/queryClient';

// Types for API responses
type Organization = {
  id: number;
  name: string;
  description: string;
  website: string;
  memberCount: number;
  isAdmin: boolean;
  joinedAt: string;
};

type OrganizationInvite = {
  id: number;
  organizationId: number;
  organizationName: string;
  invitedByName: string;
  invitedAt: string;
  status: string;
};

export default function OrganizationsScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<SettingsStackParamList>>();
  const theme = useTheme();
  const { user, refreshUser } = useAuth();
  const queryClient = useQueryClient();
  
  const [refreshing, setRefreshing] = useState(false);
  const [inviteDialogVisible, setInviteDialogVisible] = useState(false);
  const [inviteCode, setInviteCode] = useState('');
  const [createDialogVisible, setCreateDialogVisible] = useState(false);
  const [newOrgName, setNewOrgName] = useState('');
  const [newOrgDescription, setNewOrgDescription] = useState('');
  const [newOrgWebsite, setNewOrgWebsite] = useState('');
  const [leaveDialogVisible, setLeaveDialogVisible] = useState(false);
  const [leaveOrgId, setLeaveOrgId] = useState<number | null>(null);
  const [leaveOrgName, setLeaveOrgName] = useState('');

  // Fetch user's organizations
  const {
    data: organizations,
    isLoading: isOrgsLoading,
    refetch: refetchOrgs,
  } = useQuery<Organization[]>({
    queryKey: ['/api/organizations'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/organizations');
      if (!res.ok) throw new Error('Failed to fetch organizations');
      return res.json();
    },
  });

  // Fetch organization invites
  const {
    data: invites,
    isLoading: isInvitesLoading,
    refetch: refetchInvites,
  } = useQuery<OrganizationInvite[]>({
    queryKey: ['/api/organizations/invites'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/organizations/invites');
      if (!res.ok) throw new Error('Failed to fetch invites');
      return res.json();
    },
  });

  // Accept invite mutation
  const acceptInviteMutation = useMutation({
    mutationFn: async (inviteId: number) => {
      const res = await apiRequest('POST', `/api/organizations/invites/${inviteId}/accept`);
      if (!res.ok) throw new Error('Failed to accept invite');
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/organizations/invites'] });
      queryClient.invalidateQueries({ queryKey: ['/api/organizations'] });
      refreshUser();
    },
  });

  // Decline invite mutation
  const declineInviteMutation = useMutation({
    mutationFn: async (inviteId: number) => {
      const res = await apiRequest('POST', `/api/organizations/invites/${inviteId}/decline`);
      if (!res.ok) throw new Error('Failed to decline invite');
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/organizations/invites'] });
    },
  });

  // Join with invite code mutation
  const joinWithCodeMutation = useMutation({
    mutationFn: async (code: string) => {
      const res = await apiRequest('POST', '/api/organizations/join', { code });
      if (!res.ok) throw new Error('Failed to join organization');
      return res.json();
    },
    onSuccess: () => {
      setInviteCode('');
      setInviteDialogVisible(false);
      queryClient.invalidateQueries({ queryKey: ['/api/organizations'] });
      refreshUser();
    },
  });

  // Create organization mutation
  const createOrgMutation = useMutation({
    mutationFn: async (data: { name: string; description: string; website: string }) => {
      const res = await apiRequest('POST', '/api/organizations', data);
      if (!res.ok) throw new Error('Failed to create organization');
      return res.json();
    },
    onSuccess: (data) => {
      setCreateDialogVisible(false);
      setNewOrgName('');
      setNewOrgDescription('');
      setNewOrgWebsite('');
      queryClient.invalidateQueries({ queryKey: ['/api/organizations'] });
      refreshUser();
      
      // Navigate to the new organization details
      navigation.navigate('OrganizationDetails', { organizationId: data.id });
    },
  });

  // Leave organization mutation
  const leaveOrgMutation = useMutation({
    mutationFn: async (orgId: number) => {
      const res = await apiRequest('DELETE', `/api/organizations/${orgId}/leave`);
      if (!res.ok) throw new Error('Failed to leave organization');
      return res.json();
    },
    onSuccess: () => {
      setLeaveDialogVisible(false);
      queryClient.invalidateQueries({ queryKey: ['/api/organizations'] });
      refreshUser();
    },
  });

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([
        refetchOrgs(),
        refetchInvites(),
      ]);
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refetchOrgs, refetchInvites]);

  const handleAcceptInvite = (inviteId: number) => {
    acceptInviteMutation.mutate(inviteId);
  };

  const handleDeclineInvite = (inviteId: number) => {
    declineInviteMutation.mutate(inviteId);
  };

  const handleJoinWithCode = () => {
    if (inviteCode.trim()) {
      joinWithCodeMutation.mutate(inviteCode.trim());
    }
  };

  const handleCreateOrg = () => {
    if (newOrgName.trim()) {
      createOrgMutation.mutate({
        name: newOrgName.trim(),
        description: newOrgDescription.trim(),
        website: newOrgWebsite.trim(),
      });
    }
  };

  const handleLeaveOrg = () => {
    if (leaveOrgId) {
      leaveOrgMutation.mutate(leaveOrgId);
    }
  };

  const openLeaveDialog = (orgId: number, orgName: string) => {
    setLeaveOrgId(orgId);
    setLeaveOrgName(orgName);
    setLeaveDialogVisible(true);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const getInitials = (name: string) => {
    return name
      .split(' ')
      .map((part) => part.charAt(0))
      .join('')
      .toUpperCase()
      .substring(0, 2);
  };

  return (
    <View style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        style={styles.scrollView}
        contentContainerStyle={styles.contentContainer}
      >
        {/* Current Organizations */}
        <Text variant="titleLarge" style={styles.sectionTitle}>
          Your Organizations
        </Text>
        
        {isOrgsLoading ? (
          <ActivityIndicator style={styles.loader} />
        ) : organizations && organizations.length > 0 ? (
          organizations.map((org) => (
            <Card
              key={org.id}
              style={styles.orgCard}
              onPress={() => navigation.navigate('OrganizationDetails', { organizationId: org.id })}
            >
              <Card.Content>
                <View style={styles.orgHeader}>
                  <Avatar.Text
                    size={40}
                    label={getInitials(org.name)}
                    style={[
                      styles.orgAvatar,
                      { backgroundColor: org.isAdmin ? theme.colors.secondary : theme.colors.primary },
                    ]}
                  />
                  <View style={styles.orgInfo}>
                    <Text variant="titleMedium">{org.name}</Text>
                    <Text variant="bodySmall">
                      {org.memberCount} {org.memberCount === 1 ? 'member' : 'members'}
                    </Text>
                  </View>
                </View>
                
                {org.description && (
                  <Text variant="bodyMedium" style={styles.orgDescription}>
                    {org.description.length > 100
                      ? `${org.description.substring(0, 100)}...`
                      : org.description}
                  </Text>
                )}
                
                <View style={styles.orgFooter}>
                  <Text variant="bodySmall" style={styles.joinedDate}>
                    Joined {formatDate(org.joinedAt)}
                  </Text>
                  
                  {org.isAdmin ? (
                    <Button
                      mode="outlined"
                      onPress={() => navigation.navigate('OrganizationDetails', { organizationId: org.id })}
                    >
                      Manage
                    </Button>
                  ) : (
                    <Button
                      mode="outlined"
                      onPress={() => openLeaveDialog(org.id, org.name)}
                    >
                      Leave
                    </Button>
                  )}
                </View>
              </Card.Content>
            </Card>
          ))
        ) : (
          <Card style={styles.emptyCard}>
            <Card.Content>
              <Text variant="bodyLarge" style={styles.emptyText}>
                You aren't a member of any organizations yet
              </Text>
              <Text variant="bodyMedium" style={styles.emptySubtext}>
                Create a new organization or join with an invite code
              </Text>
              <View style={styles.emptyActions}>
                <Button
                  mode="outlined"
                  icon="link-variant"
                  onPress={() => setInviteDialogVisible(true)}
                  style={styles.emptyButton}
                >
                  Join with Code
                </Button>
                <Button
                  mode="contained"
                  icon="plus"
                  onPress={() => setCreateDialogVisible(true)}
                  style={styles.emptyButton}
                >
                  Create New
                </Button>
              </View>
            </Card.Content>
          </Card>
        )}

        {/* Organization Invites */}
        {invites && invites.length > 0 && (
          <>
            <Text variant="titleLarge" style={styles.sectionTitle}>
              Pending Invites
            </Text>
            
            {isInvitesLoading ? (
              <ActivityIndicator style={styles.loader} />
            ) : (
              invites.map((invite) => (
                <Card key={invite.id} style={styles.inviteCard}>
                  <Card.Content>
                    <Text variant="titleMedium">{invite.organizationName}</Text>
                    <Text variant="bodyMedium" style={styles.inviteText}>
                      {invite.invitedByName} has invited you to join this organization
                    </Text>
                    <Text variant="bodySmall" style={styles.inviteDate}>
                      Invited on {formatDate(invite.invitedAt)}
                    </Text>
                    
                    <View style={styles.inviteActions}>
                      <Button
                        mode="outlined"
                        onPress={() => handleDeclineInvite(invite.id)}
                        style={styles.inviteButton}
                        loading={declineInviteMutation.isPending}
                      >
                        Decline
                      </Button>
                      <Button
                        mode="contained"
                        onPress={() => handleAcceptInvite(invite.id)}
                        style={styles.inviteButton}
                        loading={acceptInviteMutation.isPending}
                      >
                        Accept
                      </Button>
                    </View>
                  </Card.Content>
                </Card>
              ))
            )}
          </>
        )}
      </ScrollView>

      {/* FAB for creating/joining organizations */}
      <FAB
        icon="plus"
        style={[styles.fab, { backgroundColor: theme.colors.primary }]}
        onPress={() => setCreateDialogVisible(true)}
      />

      {/* Join with Invite Code Dialog */}
      <Portal>
        <Dialog visible={inviteDialogVisible} onDismiss={() => setInviteDialogVisible(false)}>
          <Dialog.Title>Join Organization</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium" style={styles.dialogText}>
              Enter the invite code provided by the organization admin:
            </Text>
            <TextInput
              label="Invite Code"
              value={inviteCode}
              onChangeText={setInviteCode}
              mode="outlined"
              style={styles.dialogInput}
              autoCapitalize="none"
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setInviteDialogVisible(false)}>Cancel</Button>
            <Button
              mode="contained"
              onPress={handleJoinWithCode}
              loading={joinWithCodeMutation.isPending}
              disabled={!inviteCode.trim()}
            >
              Join
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Create Organization Dialog */}
      <Portal>
        <Dialog visible={createDialogVisible} onDismiss={() => setCreateDialogVisible(false)}>
          <Dialog.Title>Create Organization</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium" style={styles.dialogText}>
              Create a new organization to connect with your community:
            </Text>
            <TextInput
              label="Organization Name *"
              value={newOrgName}
              onChangeText={setNewOrgName}
              mode="outlined"
              style={styles.dialogInput}
            />
            <TextInput
              label="Description"
              value={newOrgDescription}
              onChangeText={setNewOrgDescription}
              mode="outlined"
              multiline
              numberOfLines={3}
              style={styles.dialogInput}
            />
            <TextInput
              label="Website"
              value={newOrgWebsite}
              onChangeText={setNewOrgWebsite}
              mode="outlined"
              style={styles.dialogInput}
              keyboardType="url"
              autoCapitalize="none"
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setCreateDialogVisible(false)}>Cancel</Button>
            <Button
              mode="contained"
              onPress={handleCreateOrg}
              loading={createOrgMutation.isPending}
              disabled={!newOrgName.trim()}
            >
              Create
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Leave Organization Dialog */}
      <Portal>
        <Dialog visible={leaveDialogVisible} onDismiss={() => setLeaveDialogVisible(false)}>
          <Dialog.Title>Leave Organization?</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              Are you sure you want to leave {leaveOrgName}? You'll lose access to all groups and prayer requests in this organization.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setLeaveDialogVisible(false)}>Cancel</Button>
            <Button
              onPress={handleLeaveOrg}
              textColor="#ef4444"
              loading={leaveOrgMutation.isPending}
            >
              Leave
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 80, // Add space for FAB
  },
  sectionTitle: {
    marginBottom: 16,
  },
  loader: {
    marginVertical: 24,
  },
  orgCard: {
    marginBottom: 16,
  },
  orgHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  orgAvatar: {
    marginRight: 16,
  },
  orgInfo: {
    flex: 1,
  },
  orgDescription: {
    marginBottom: 16,
  },
  orgFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  joinedDate: {
    opacity: 0.6,
  },
  inviteCard: {
    marginBottom: 16,
  },
  inviteText: {
    marginVertical: 8,
  },
  inviteDate: {
    marginBottom: 16,
    opacity: 0.6,
  },
  inviteActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  inviteButton: {
    marginLeft: 12,
  },
  emptyCard: {
    alignItems: 'center',
    padding: 16,
    marginBottom: 24,
  },
  emptyText: {
    textAlign: 'center',
    marginBottom: 8,
  },
  emptySubtext: {
    textAlign: 'center',
    opacity: 0.6,
    marginBottom: 16,
  },
  emptyActions: {
    flexDirection: 'row',
    justifyContent: 'center',
    flexWrap: 'wrap',
  },
  emptyButton: {
    margin: 8,
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
  },
  dialogText: {
    marginBottom: 16,
  },
  dialogInput: {
    marginBottom: 12,
  },
});
```

## File: mobile/src/screens/PrayerRequestsScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, RefreshControl } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { PrayerRequestsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  Searchbar,
  Chip,
  List,
  ActivityIndicator,
  useTheme,
  IconButton,
  FAB,
  Menu,
  Divider,
} from 'react-native-paper';
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';

// Types for API response
type PrayerRequest = {
  id: number;
  title: string;
  content: string;
  status: string;
  createdAt: string;
  updatedAt: string;
  groupId: number;
  groupName: string;
  userId: number;
  userName: string;
};

// Status filter options
const STATUS_FILTERS = ['all', 'new', 'in-progress', 'answered'];

export default function PrayerRequestsScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<PrayerRequestsStackParamList>>();
  const theme = useTheme();
  
  // State for filters and search
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  const [refreshing, setRefreshing] = useState(false);
  const [menuVisible, setMenuVisible] = useState(false);
  
  // Query for prayer requests
  const {
    data: prayerRequests,
    isLoading,
    refetch,
  } = useQuery<PrayerRequest[]>({
    queryKey: ['/api/requests/user', { status: statusFilter !== 'all' ? statusFilter : undefined }],
    queryFn: async () => {
      let endpoint = '/api/requests/user';
      if (statusFilter !== 'all') {
        endpoint += `?status=${statusFilter}`;
      }
      const response = await apiRequest('GET', endpoint);
      if (!response.ok) throw new Error('Failed to fetch prayer requests');
      return response.json();
    },
  });
  
  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await refetch();
    } finally {
      setRefreshing(false);
    }
  }, [refetch]);
  
  const navigateToRequestDetails = (requestId: number) => {
    navigation.navigate('RequestDetails', { requestId });
  };
  
  // Filter requests based on search query
  const filteredRequests = prayerRequests
    ? prayerRequests.filter(
        (request) =>
          request.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
          request.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
          request.groupName.toLowerCase().includes(searchQuery.toLowerCase())
      )
    : [];
  
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };
  
  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'answered':
        return 'check-circle';
      case 'in-progress':
        return 'clock-outline';
      default:
        return 'prayer';
    }
  };
  
  return (
    <View style={styles.container}>
      {/* Search and Filter Bar */}
      <View style={styles.searchContainer}>
        <Searchbar
          placeholder="Search prayer requests"
          onChangeText={setSearchQuery}
          value={searchQuery}
          style={styles.searchBar}
        />
        <IconButton
          icon="filter-variant"
          size={24}
          onPress={() => setMenuVisible(true)}
        />
        <Menu
          visible={menuVisible}
          onDismiss={() => setMenuVisible(false)}
          anchor={{ x: 300, y: 60 }}
        >
          <Menu.Item
            onPress={() => {
              setStatusFilter('all');
              setMenuVisible(false);
            }}
            title="All Requests"
          />
          <Divider />
          <Menu.Item
            onPress={() => {
              setStatusFilter('new');
              setMenuVisible(false);
            }}
            title="New"
          />
          <Menu.Item
            onPress={() => {
              setStatusFilter('in-progress');
              setMenuVisible(false);
            }}
            title="In Progress"
          />
          <Menu.Item
            onPress={() => {
              setStatusFilter('answered');
              setMenuVisible(false);
            }}
            title="Answered"
          />
        </Menu>
      </View>
      
      {/* Status Filter Chips */}
      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        style={styles.chipsContainer}
        contentContainerStyle={styles.chipsContent}
      >
        {STATUS_FILTERS.map((status) => (
          <Chip
            key={status}
            selected={statusFilter === status}
            onPress={() => setStatusFilter(status)}
            style={styles.chip}
            mode={statusFilter === status ? 'flat' : 'outlined'}
          >
            {status === 'all' ? 'All' : status === 'in-progress' ? 'In Progress' : status.charAt(0).toUpperCase() + status.slice(1)}
          </Chip>
        ))}
      </ScrollView>
      
      {/* Prayer Requests List */}
      {isLoading ? (
        <ActivityIndicator style={styles.loader} size="large" />
      ) : (
        <ScrollView
          style={styles.listContainer}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
        >
          {filteredRequests.length > 0 ? (
            filteredRequests.map((request) => (
              <List.Item
                key={request.id}
                title={request.title}
                description={request.content.substring(0, 100) + (request.content.length > 100 ? '...' : '')}
                left={(props) => <List.Icon {...props} icon={getStatusIcon(request.status)} />}
                right={(props) => (
                  <View {...props} style={styles.metaContainer}>
                    <Text variant="labelSmall" style={styles.groupName}>
                      {request.groupName}
                    </Text>
                    <Text variant="labelSmall" style={styles.date}>
                      {formatDate(request.createdAt)}
                    </Text>
                  </View>
                )}
                onPress={() => navigateToRequestDetails(request.id)}
                style={styles.listItem}
              />
            ))
          ) : (
            <View style={styles.emptyContainer}>
              <Text variant="bodyLarge">No prayer requests found</Text>
              <Text variant="bodyMedium" style={styles.emptyText}>
                {searchQuery
                  ? 'Try using different search terms'
                  : statusFilter !== 'all'
                  ? `You don't have any ${statusFilter} prayer requests`
                  : 'You have not created any prayer requests yet'}
              </Text>
            </View>
          )}
        </ScrollView>
      )}
      
      {/* FAB for adding new prayer request */}
      <FAB
        icon="plus"
        style={styles.fab}
        onPress={() => {/* Navigate to create prayer request */}}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  searchContainer: {
    flexDirection: 'row',
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 8,
    alignItems: 'center',
  },
  searchBar: {
    flex: 1,
    marginRight: 8,
  },
  chipsContainer: {
    maxHeight: 50,
  },
  chipsContent: {
    paddingHorizontal: 16,
    paddingBottom: 8,
  },
  chip: {
    marginRight: 8,
  },
  listContainer: {
    flex: 1,
  },
  listItem: {
    backgroundColor: 'white',
    marginHorizontal: 16,
    marginVertical: 4,
    borderRadius: 8,
  },
  metaContainer: {
    alignItems: 'flex-end',
    justifyContent: 'center',
  },
  groupName: {
    marginBottom: 4,
  },
  date: {
    opacity: 0.6,
  },
  loader: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyText: {
    textAlign: 'center',
    marginTop: 8,
    opacity: 0.6,
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
  },
});
```

## File: mobile/src/screens/RequestDetailsScreen.tsx
```typescript
import React, { useState, useRef } from 'react';
import { View, StyleSheet, ScrollView, RefreshControl, TextInput as RNTextInput } from 'react-native';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { HomeStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  Card,
  Button,
  IconButton,
  Chip,
  Portal,
  Dialog,
  ActivityIndicator,
  useTheme,
  Divider,
  Avatar,
  TextInput,
  List,
  Menu,
} from 'react-native-paper';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@hooks/useAuth';
import { apiRequest } from '@/api/queryClient';

// Types for API responses
type PrayerRequest = {
  id: number;
  title: string;
  content: string;
  status: string;
  urgency: string;
  createdAt: string;
  updatedAt: string;
  groupId: number;
  groupName: string;
  userId: number;
  userName: string;
  commentCount: number;
  isOwner: boolean;
};

type Comment = {
  id: number;
  content: string;
  createdAt: string;
  userId: number;
  userName: string;
  userAvatar?: string;
  isOwner: boolean;
};

export default function RequestDetailsScreen() {
  const route = useRoute<RouteProp<HomeStackParamList, 'RequestDetails'>>();
  const navigation = useNavigation<NativeStackNavigationProp<HomeStackParamList>>();
  const theme = useTheme();
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { requestId } = route.params;
  
  const [refreshing, setRefreshing] = useState(false);
  const [comment, setComment] = useState('');
  const [editingCommentId, setEditingCommentId] = useState<number | null>(null);
  const [editedCommentContent, setEditedCommentContent] = useState('');
  const [deleteDialogVisible, setDeleteDialogVisible] = useState(false);
  const [deleteTargetId, setDeleteTargetId] = useState<number | null>(null);
  const [deleteType, setDeleteType] = useState<'request' | 'comment'>('comment');
  const [statusMenuVisible, setStatusMenuVisible] = useState(false);
  const [commentMenuVisible, setCommentMenuVisible] = useState(false);
  const [selectedCommentId, setSelectedCommentId] = useState<number | null>(null);
  
  const commentInputRef = useRef<RNTextInput>(null);

  // Fetch prayer request details
  const { 
    data: request, 
    isLoading: isRequestLoading,
    refetch: refetchRequest,
  } = useQuery<PrayerRequest>({
    queryKey: [`/api/requests/${requestId}`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/requests/${requestId}`);
      if (!res.ok) throw new Error('Failed to fetch prayer request');
      return res.json();
    },
  });

  // Fetch comments
  const {
    data: comments,
    isLoading: isCommentsLoading,
    refetch: refetchComments,
  } = useQuery<Comment[]>({
    queryKey: [`/api/requests/${requestId}/comments`],
    queryFn: async () => {
      const res = await apiRequest('GET', `/api/requests/${requestId}/comments`);
      if (!res.ok) throw new Error('Failed to fetch comments');
      return res.json();
    },
  });

  // Add comment mutation
  const addCommentMutation = useMutation({
    mutationFn: async (content: string) => {
      const res = await apiRequest('POST', `/api/requests/${requestId}/comments`, { content });
      if (!res.ok) throw new Error('Failed to add comment');
      return res.json();
    },
    onSuccess: () => {
      setComment('');
      queryClient.invalidateQueries({ queryKey: [`/api/requests/${requestId}/comments`] });
      queryClient.invalidateQueries({ queryKey: [`/api/requests/${requestId}`] });
    },
  });

  // Update comment mutation
  const updateCommentMutation = useMutation({
    mutationFn: async ({ commentId, content }: { commentId: number; content: string }) => {
      const res = await apiRequest('PUT', `/api/comments/${commentId}`, { content });
      if (!res.ok) throw new Error('Failed to update comment');
      return res.json();
    },
    onSuccess: () => {
      setEditingCommentId(null);
      queryClient.invalidateQueries({ queryKey: [`/api/requests/${requestId}/comments`] });
    },
  });

  // Delete comment mutation
  const deleteCommentMutation = useMutation({
    mutationFn: async (commentId: number) => {
      const res = await apiRequest('DELETE', `/api/comments/${commentId}`);
      if (!res.ok) throw new Error('Failed to delete comment');
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/requests/${requestId}/comments`] });
      queryClient.invalidateQueries({ queryKey: [`/api/requests/${requestId}`] });
    },
  });

  // Update prayer request status mutation
  const updateStatusMutation = useMutation({
    mutationFn: async (status: string) => {
      const res = await apiRequest('PUT', `/api/requests/${requestId}/status`, { status });
      if (!res.ok) throw new Error('Failed to update status');
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/requests/${requestId}`] });
      queryClient.invalidateQueries({ queryKey: ['/api/requests/user/recent'] });
      queryClient.invalidateQueries({ queryKey: [`/api/groups/${request?.groupId}/requests`] });
    },
  });

  // Delete prayer request mutation
  const deleteRequestMutation = useMutation({
    mutationFn: async () => {
      const res = await apiRequest('DELETE', `/api/requests/${requestId}`);
      if (!res.ok) throw new Error('Failed to delete prayer request');
      return res.json();
    },
    onSuccess: () => {
      navigation.goBack();
      queryClient.invalidateQueries({ queryKey: ['/api/requests/user/recent'] });
      if (request?.groupId) {
        queryClient.invalidateQueries({ queryKey: [`/api/groups/${request.groupId}/requests`] });
      }
    },
  });

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([
        refetchRequest(),
        refetchComments(),
      ]);
    } catch (error) {
      console.error('Error refreshing data:', error);
    } finally {
      setRefreshing(false);
    }
  }, [refetchRequest, refetchComments]);

  const handleAddComment = () => {
    if (comment.trim()) {
      addCommentMutation.mutate(comment.trim());
    }
  };

  const handleEditComment = (commentId: number, currentContent: string) => {
    setEditingCommentId(commentId);
    setEditedCommentContent(currentContent);
  };

  const handleUpdateComment = () => {
    if (editingCommentId && editedCommentContent.trim()) {
      updateCommentMutation.mutate({
        commentId: editingCommentId,
        content: editedCommentContent.trim(),
      });
    }
  };

  const handleCancelEdit = () => {
    setEditingCommentId(null);
  };

  const openDeleteDialog = (id: number, type: 'request' | 'comment') => {
    setDeleteTargetId(id);
    setDeleteType(type);
    setDeleteDialogVisible(true);
  };

  const handleDelete = () => {
    if (deleteType === 'comment' && deleteTargetId) {
      deleteCommentMutation.mutate(deleteTargetId);
    } else if (deleteType === 'request') {
      deleteRequestMutation.mutate();
    }
    setDeleteDialogVisible(false);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'new':
        return '#3b82f6'; // blue
      case 'in-progress':
        return '#f59e0b'; // amber
      case 'answered':
        return '#10b981'; // green
      default:
        return theme.colors.primary;
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'new':
        return 'prayer';
      case 'in-progress':
        return 'clock-outline';
      case 'answered':
        return 'check-circle';
      default:
        return 'prayer';
    }
  };

  const getUrgencyColor = (urgency: string) => {
    switch (urgency) {
      case 'low':
        return '#22c55e'; // green
      case 'medium':
        return '#f59e0b'; // amber
      case 'high':
        return '#ef4444'; // red
      default:
        return undefined;
    }
  };

  if (isRequestLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (!request) {
    return (
      <View style={styles.errorContainer}>
        <Text variant="headlineSmall">Prayer request not found</Text>
        <Button 
          mode="contained"
          onPress={() => navigation.goBack()}
          style={styles.errorButton}
        >
          Go Back
        </Button>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <ScrollView
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
        style={styles.scrollView}
        contentContainerStyle={styles.contentContainer}
      >
        {/* Prayer Request Card */}
        <Card style={styles.requestCard}>
          <Card.Content>
            <View style={styles.cardHeader}>
              <View style={styles.metaInfo}>
                <Text variant="bodySmall" style={styles.groupName}>
                  {request.groupName}
                </Text>
                <Text variant="bodySmall">
                  {formatDate(request.createdAt)}
                </Text>
              </View>
              
              {request.isOwner && (
                <Menu
                  visible={statusMenuVisible}
                  onDismiss={() => setStatusMenuVisible(false)}
                  anchor={
                    <Button
                      mode="outlined"
                      icon={getStatusIcon(request.status)}
                      textColor={getStatusColor(request.status)}
                      style={[styles.statusButton, { borderColor: getStatusColor(request.status) }]}
                      onPress={() => setStatusMenuVisible(true)}
                    >
                      {request.status === 'new'
                        ? 'New'
                        : request.status === 'in-progress'
                        ? 'In Progress'
                        : 'Answered'}
                    </Button>
                  }
                >
                  <Menu.Item
                    title="Mark as New"
                    leadingIcon="prayer"
                    onPress={() => {
                      updateStatusMutation.mutate('new');
                      setStatusMenuVisible(false);
                    }}
                  />
                  <Menu.Item
                    title="Mark In Progress"
                    leadingIcon="clock-outline"
                    onPress={() => {
                      updateStatusMutation.mutate('in-progress');
                      setStatusMenuVisible(false);
                    }}
                  />
                  <Menu.Item
                    title="Mark as Answered"
                    leadingIcon="check-circle"
                    onPress={() => {
                      updateStatusMutation.mutate('answered');
                      setStatusMenuVisible(false);
                    }}
                  />
                  <Divider />
                  <Menu.Item
                    title="Edit Request"
                    leadingIcon="pencil"
                    onPress={() => {
                      setStatusMenuVisible(false);
                      /* Navigate to edit request screen */
                    }}
                  />
                  <Menu.Item
                    title="Delete Request"
                    leadingIcon="delete"
                    onPress={() => {
                      setStatusMenuVisible(false);
                      openDeleteDialog(request.id, 'request');
                    }}
                  />
                </Menu>
              )}
            </View>
            
            <Text variant="headlineSmall" style={styles.title}>
              {request.title}
            </Text>
            
            <View style={styles.userInfo}>
              <Avatar.Text
                size={24}
                label={request.userName.substring(0, 2).toUpperCase()}
                style={styles.avatar}
              />
              <Text variant="bodyMedium">{request.userName}</Text>
            </View>
            
            <View style={styles.tagsContainer}>
              <Chip
                style={[styles.urgencyChip, { borderColor: getUrgencyColor(request.urgency) }]}
                textStyle={{ color: getUrgencyColor(request.urgency) }}
                mode="outlined"
              >
                {request.urgency === 'high'
                  ? 'Urgent'
                  : request.urgency === 'medium'
                  ? 'Medium'
                  : 'Low'} Priority
              </Chip>
              
              <Chip
                style={[styles.statusChip, { borderColor: getStatusColor(request.status) }]}
                textStyle={{ color: getStatusColor(request.status) }}
                mode="outlined"
                icon={getStatusIcon(request.status)}
              >
                {request.status === 'new'
                  ? 'New'
                  : request.status === 'in-progress'
                  ? 'In Progress'
                  : 'Answered'}
              </Chip>
            </View>
            
            <Text variant="bodyLarge" style={styles.content}>
              {request.content}
            </Text>
          </Card.Content>
        </Card>

        {/* Comments Section */}
        <View style={styles.commentsSection}>
          <Text variant="titleMedium" style={styles.commentsHeader}>
            Comments ({request.commentCount})
          </Text>
          
          {isCommentsLoading ? (
            <ActivityIndicator style={styles.commentsLoader} />
          ) : comments && comments.length > 0 ? (
            comments.map((comment) => (
              <Card key={comment.id} style={styles.commentCard}>
                <Card.Content>
                  {editingCommentId === comment.id ? (
                    <View>
                      <TextInput
                        value={editedCommentContent}
                        onChangeText={setEditedCommentContent}
                        multiline
                        mode="outlined"
                        style={styles.editInput}
                      />
                      <View style={styles.editActions}>
                        <Button onPress={handleCancelEdit}>Cancel</Button>
                        <Button 
                          mode="contained"
                          onPress={handleUpdateComment}
                          disabled={!editedCommentContent.trim()}
                          loading={updateCommentMutation.isPending}
                        >
                          Save
                        </Button>
                      </View>
                    </View>
                  ) : (
                    <>
                      <View style={styles.commentHeader}>
                        <View style={styles.commentUser}>
                          <Avatar.Text
                            size={24}
                            label={comment.userName.substring(0, 2).toUpperCase()}
                            style={styles.commentAvatar}
                          />
                          <Text variant="bodyMedium">{comment.userName}</Text>
                        </View>
                        
                        {comment.isOwner && (
                          <IconButton
                            icon="dots-vertical"
                            size={20}
                            onPress={() => {
                              setSelectedCommentId(comment.id);
                              setCommentMenuVisible(true);
                            }}
                          />
                        )}
                      </View>
                      
                      <Text variant="bodyMedium" style={styles.commentContent}>
                        {comment.content}
                      </Text>
                      
                      <Text variant="bodySmall" style={styles.commentDate}>
                        {formatDate(comment.createdAt)}
                      </Text>
                    </>
                  )}
                </Card.Content>
                
                {/* Comment Menu */}
                <Menu
                  visible={commentMenuVisible && selectedCommentId === comment.id}
                  onDismiss={() => setCommentMenuVisible(false)}
                  anchor={{ x: 0, y: 0 }}
                  style={styles.commentMenu}
                >
                  <Menu.Item
                    title="Edit"
                    leadingIcon="pencil"
                    onPress={() => {
                      setCommentMenuVisible(false);
                      handleEditComment(comment.id, comment.content);
                    }}
                  />
                  <Menu.Item
                    title="Delete"
                    leadingIcon="delete"
                    onPress={() => {
                      setCommentMenuVisible(false);
                      openDeleteDialog(comment.id, 'comment');
                    }}
                  />
                </Menu>
              </Card>
            ))
          ) : (
            <Card style={styles.emptyCommentsCard}>
              <Card.Content>
                <Text variant="bodyMedium" style={styles.emptyCommentsText}>
                  No comments yet. Be the first to add your thoughts or encouragement.
                </Text>
              </Card.Content>
            </Card>
          )}
        </View>
      </ScrollView>

      {/* Comment Input */}
      <Card style={styles.commentInputCard}>
        <Card.Content style={styles.commentInputContent}>
          <TextInput
            ref={commentInputRef}
            placeholder="Add a comment..."
            value={comment}
            onChangeText={setComment}
            mode="outlined"
            multiline
            style={styles.commentInput}
          />
          <Button
            mode="contained"
            onPress={handleAddComment}
            disabled={!comment.trim()}
            loading={addCommentMutation.isPending}
            style={styles.sendButton}
            icon="send"
            contentStyle={styles.sendButtonContent}
          >
            Send
          </Button>
        </Card.Content>
      </Card>

      {/* Delete Confirmation Dialog */}
      <Portal>
        <Dialog visible={deleteDialogVisible} onDismiss={() => setDeleteDialogVisible(false)}>
          <Dialog.Title>
            {deleteType === 'comment' ? 'Delete Comment?' : 'Delete Prayer Request?'}
          </Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              {deleteType === 'comment'
                ? 'Are you sure you want to delete this comment? This action cannot be undone.'
                : 'Are you sure you want to delete this prayer request? All comments will also be deleted. This action cannot be undone.'}
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setDeleteDialogVisible(false)}>Cancel</Button>
            <Button
              onPress={handleDelete}
              textColor="#ef4444"
              loading={
                (deleteType === 'comment' && deleteCommentMutation.isPending) ||
                (deleteType === 'request' && deleteRequestMutation.isPending)
              }
            >
              Delete
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 100, // Add space for the comment input
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  errorButton: {
    marginTop: 16,
  },
  requestCard: {
    marginBottom: 16,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  metaInfo: {
    flex: 1,
  },
  groupName: {
    fontWeight: 'bold',
    marginBottom: 4,
  },
  statusButton: {
    height: 36,
  },
  title: {
    marginBottom: 8,
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  avatar: {
    marginRight: 8,
  },
  tagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
  },
  urgencyChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  statusChip: {
    marginBottom: 8,
  },
  content: {
    lineHeight: 24,
  },
  commentsSection: {
    marginBottom: 16,
  },
  commentsHeader: {
    marginBottom: 12,
  },
  commentsLoader: {
    margin: 24,
  },
  commentCard: {
    marginBottom: 12,
  },
  commentHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  commentUser: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  commentAvatar: {
    marginRight: 8,
  },
  commentContent: {
    marginBottom: 8,
  },
  commentDate: {
    opacity: 0.6,
  },
  emptyCommentsCard: {
    marginBottom: 12,
  },
  emptyCommentsText: {
    textAlign: 'center',
    opacity: 0.7,
  },
  commentMenu: {
    position: 'absolute',
    right: 8,
    top: 40,
  },
  editInput: {
    marginBottom: 8,
  },
  editActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  commentInputCard: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    borderTopWidth: 1,
    borderTopColor: '#e5e5e5',
    borderRadius: 0,
  },
  commentInputContent: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
  },
  commentInput: {
    flex: 1,
    maxHeight: 100,
    marginRight: 8,
  },
  sendButton: {
    height: 40,
    width: 100,
  },
  sendButtonContent: {
    flexDirection: 'row-reverse',
  },
});
```

## File: mobile/src/screens/ResetPasswordScreen.tsx
```typescript
import React, { useState } from 'react';
import { View, StyleSheet, ScrollView, Image } from 'react-native';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { RootStackParamList } from '@navigation/AppNavigator';
import {
  Text,
  TextInput,
  Button,
  Portal,
  Dialog,
  useTheme,
  Card,
  HelperText,
} from 'react-native-paper';
import { useMutation } from '@tanstack/react-query';
import { apiRequest } from '@/api/queryClient';

export default function ResetPasswordScreen() {
  const route = useRoute<RouteProp<RootStackParamList, 'ResetPassword'>>();
  const navigation = useNavigation<NativeStackNavigationProp<RootStackParamList>>();
  const theme = useTheme();
  const { token } = route.params;
  
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [passwordVisible, setPasswordVisible] = useState(false);
  const [confirmPasswordVisible, setConfirmPasswordVisible] = useState(false);
  const [successDialogVisible, setSuccessDialogVisible] = useState(false);
  const [errorDialogVisible, setErrorDialogVisible] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');

  // Password reset mutation
  const resetPasswordMutation = useMutation({
    mutationFn: async (data: { token: string; password: string }) => {
      const res = await apiRequest('POST', '/api/reset-password', data);
      if (!res.ok) {
        const error = await res.json().catch(() => ({ message: 'Failed to reset password' }));
        throw new Error(error.message || 'Failed to reset password');
      }
      return res.json();
    },
    onSuccess: () => {
      setSuccessDialogVisible(true);
    },
    onError: (error: Error) => {
      setErrorMessage(error.message);
      setErrorDialogVisible(true);
    },
  });

  const validatePassword = () => {
    if (password.length < 8) {
      return 'Password must be at least 8 characters';
    }
    return '';
  };

  const validateConfirmPassword = () => {
    if (confirmPassword && password !== confirmPassword) {
      return 'Passwords do not match';
    }
    return '';
  };

  const handleResetPassword = () => {
    const passwordError = validatePassword();
    const confirmError = validateConfirmPassword();
    
    if (passwordError) {
      setErrorMessage(passwordError);
      setErrorDialogVisible(true);
      return;
    }
    
    if (confirmError) {
      setErrorMessage(confirmError);
      setErrorDialogVisible(true);
      return;
    }
    
    resetPasswordMutation.mutate({
      token,
      password,
    });
  };

  const handleSuccessClose = () => {
    setSuccessDialogVisible(false);
    navigation.navigate('Auth');
  };

  const passwordError = validatePassword();
  const confirmPasswordError = validateConfirmPassword();
  const isFormValid = password.length >= 8 && password === confirmPassword;

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContent}>
        <View style={styles.content}>
          <View style={styles.headerContainer}>
            <Text variant="headlineMedium" style={styles.title}>
              Create New Password
            </Text>
            <Text variant="bodyLarge" style={styles.subtitle}>
              Your password must be at least 8 characters long.
            </Text>
          </View>
          
          <Card style={styles.card}>
            <Card.Content>
              <TextInput
                label="New Password"
                value={password}
                onChangeText={setPassword}
                secureTextEntry={!passwordVisible}
                right={
                  <TextInput.Icon
                    icon={passwordVisible ? 'eye-off' : 'eye'}
                    onPress={() => setPasswordVisible(!passwordVisible)}
                  />
                }
                mode="outlined"
                style={styles.input}
              />
              {password ? (
                <HelperText type={passwordError ? 'error' : 'info'} visible={!!password}>
                  {passwordError || 'Password strength: ' + (password.length >= 12 ? 'Strong' : password.length >= 8 ? 'Medium' : 'Weak')}
                </HelperText>
              ) : null}
              
              <TextInput
                label="Confirm Password"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                secureTextEntry={!confirmPasswordVisible}
                right={
                  <TextInput.Icon
                    icon={confirmPasswordVisible ? 'eye-off' : 'eye'}
                    onPress={() => setConfirmPasswordVisible(!confirmPasswordVisible)}
                  />
                }
                mode="outlined"
                style={styles.input}
              />
              {confirmPassword ? (
                <HelperText type={confirmPasswordError ? 'error' : 'info'} visible={!!confirmPassword}>
                  {confirmPasswordError || 'Passwords match'}
                </HelperText>
              ) : null}
              
              <Button
                mode="contained"
                onPress={handleResetPassword}
                style={styles.resetButton}
                loading={resetPasswordMutation.isPending}
                disabled={!isFormValid || resetPasswordMutation.isPending}
              >
                Reset Password
              </Button>
              
              <Button
                mode="text"
                onPress={() => navigation.navigate('Auth')}
                style={styles.backButton}
              >
                Back to Login
              </Button>
            </Card.Content>
          </Card>
          
          <View style={styles.imageContainer}>
            <Image
              source={require('@/assets/reset-password-illustration.png')}
              style={styles.image}
              resizeMode="contain"
            />
          </View>
        </View>
      </ScrollView>
      
      {/* Success Dialog */}
      <Portal>
        <Dialog visible={successDialogVisible} onDismiss={handleSuccessClose}>
          <Dialog.Title>Password Reset</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">
              Your password has been reset successfully. You can now log in with your new password.
            </Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={handleSuccessClose}>Login</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
      
      {/* Error Dialog */}
      <Portal>
        <Dialog visible={errorDialogVisible} onDismiss={() => setErrorDialogVisible(false)}>
          <Dialog.Title>Error</Dialog.Title>
          <Dialog.Content>
            <Text variant="bodyMedium">{errorMessage}</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setErrorDialogVisible(false)}>OK</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    padding: 24,
  },
  headerContainer: {
    marginBottom: 24,
  },
  title: {
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    textAlign: 'center',
    opacity: 0.7,
  },
  card: {
    marginBottom: 24,
  },
  input: {
    marginTop: 8,
  },
  resetButton: {
    marginTop: 16,
    marginBottom: 16,
  },
  backButton: {
    marginBottom: 8,
  },
  imageContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 24,
  },
  image: {
    width: '80%',
    height: 180,
  },
});
```

## File: mobile/src/screens/SettingsScreen.tsx
```typescript
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { SettingsStackParamList } from '@navigation/MainNavigator';
import {
  Text,
  List,
  Switch,
  Avatar,
  Divider,
  Button,
  TextInput,
  Card,
  useTheme,
  Surface,
  SegmentedButtons,
} from 'react-native-paper';
import { useAuth } from '@hooks/useAuth';
import { useNotifications } from '@hooks/useNotifications';
import { useForm, Controller } from 'react-hook-form';

type ProfileFormInputs = {
  name: string;
  email: string;
  phone: string;
  bio: string;
};

export default function SettingsScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<SettingsStackParamList>>();
  const theme = useTheme();
  const { user, logoutMutation } = useAuth();
  const { isNotificationsEnabled, enableNotifications, disableNotifications } = useNotifications();
  
  // State for active tab
  const [activeTab, setActiveTab] = useState('profile');
  
  // State for notification settings
  const [pushNotificationsEnabled, setPushNotificationsEnabled] = useState(isNotificationsEnabled);
  const [emailNotificationsEnabled, setEmailNotificationsEnabled] = useState(true);
  const [newRequestNotifications, setNewRequestNotifications] = useState(true);
  const [commentNotifications, setCommentNotifications] = useState(true);
  const [reminderNotifications, setReminderNotifications] = useState(true);
  
  // Sync the push notification toggle with the notification system
  useEffect(() => {
    setPushNotificationsEnabled(isNotificationsEnabled);
  }, [isNotificationsEnabled]);
  
  // Form for profile editing
  const { control, handleSubmit, formState: { errors } } = useForm<ProfileFormInputs>({
    defaultValues: {
      name: user?.name || '',
      email: user?.email || '',
      phone: user?.phone || '',
      bio: user?.bio || '',
    },
  });
  
  const onSubmitProfile = (data: ProfileFormInputs) => {
    console.log('Profile update data:', data);
    // Would typically call an API to update the profile here
  };
  
  const handleLogout = async () => {
    try {
      await logoutMutation.mutateAsync();
    } catch (error) {
      console.error('Logout error:', error);
    }
  };
  
  const navigateToOrganizations = () => {
    navigation.navigate('Organizations');
  };
  
  return (
    <View style={styles.container}>
      {/* Tab Selection */}
      <SegmentedButtons
        value={activeTab}
        onValueChange={setActiveTab}
        buttons={[
          { value: 'profile', label: 'Profile' },
          { value: 'notifications', label: 'Notifications' },
          { value: 'reminders', label: 'Reminders' },
          { value: 'account', label: 'Account' },
        ]}
        style={styles.tabs}
      />
      
      <ScrollView style={styles.content}>
        {/* Profile Tab */}
        {activeTab === 'profile' && (
          <View>
            <Surface style={styles.profileHeader}>
              <Avatar.Text
                size={80}
                label={user?.name?.substring(0, 2) || 'U'}
                style={styles.avatar}
              />
              <Text variant="headlineSmall" style={styles.profileName}>
                {user?.name}
              </Text>
              <Text variant="bodyMedium" style={styles.profileUsername}>
                @{user?.username}
              </Text>
            </Surface>
            
            <Card style={styles.profileForm}>
              <Card.Content>
                <Controller
                  control={control}
                  rules={{ required: 'Name is required' }}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Name"
                      value={value}
                      onBlur={onBlur}
                      onChangeText={onChange}
                      error={!!errors.name}
                      style={styles.input}
                    />
                  )}
                  name="name"
                />
                {errors.name && (
                  <Text style={styles.errorText}>{errors.name.message}</Text>
                )}
                
                <Controller
                  control={control}
                  rules={{
                    required: 'Email is required',
                    pattern: {
                      value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
                      message: 'Invalid email address',
                    },
                  }}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Email"
                      value={value}
                      onBlur={onBlur}
                      onChangeText={onChange}
                      error={!!errors.email}
                      style={styles.input}
                      keyboardType="email-address"
                    />
                  )}
                  name="email"
                />
                {errors.email && (
                  <Text style={styles.errorText}>{errors.email.message}</Text>
                )}
                
                <Controller
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Phone"
                      value={value}
                      onBlur={onBlur}
                      onChangeText={onChange}
                      error={!!errors.phone}
                      style={styles.input}
                      keyboardType="phone-pad"
                    />
                  )}
                  name="phone"
                />
                
                <Controller
                  control={control}
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      label="Bio"
                      value={value}
                      onBlur={onBlur}
                      onChangeText={onChange}
                      error={!!errors.bio}
                      style={styles.input}
                      multiline
                      numberOfLines={4}
                    />
                  )}
                  name="bio"
                />
                
                <Button
                  mode="contained"
                  onPress={handleSubmit(onSubmitProfile)}
                  style={styles.submitButton}
                >
                  Update Profile
                </Button>
              </Card.Content>
            </Card>
          </View>
        )}
        
        {/* Notifications Tab */}
        {activeTab === 'notifications' && (
          <Card style={styles.card}>
            <Card.Content>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                Notification Preferences
              </Text>
              
              <List.Item
                title="Push Notifications"
                description="Receive notifications on your device"
                right={() => (
                  <Switch
                    value={pushNotificationsEnabled}
                    onValueChange={(value) => {
                      setPushNotificationsEnabled(value);
                      if (value) {
                        enableNotifications();
                      } else {
                        disableNotifications();
                      }
                    }}
                    color={theme.colors.primary}
                  />
                )}
              />
              <Divider />
              
              <List.Item
                title="Email Notifications"
                description="Receive notifications via email"
                right={() => (
                  <Switch
                    value={emailNotificationsEnabled}
                    onValueChange={setEmailNotificationsEnabled}
                    color={theme.colors.primary}
                  />
                )}
              />
              <Divider />
              
              <Text variant="titleMedium" style={[styles.sectionTitle, { marginTop: 20 }]}>
                Notification Types
              </Text>
              
              <List.Item
                title="New Prayer Requests"
                description="When new prayer requests are added to your groups"
                right={() => (
                  <Switch
                    value={newRequestNotifications}
                    onValueChange={setNewRequestNotifications}
                    color={theme.colors.primary}
                  />
                )}
              />
              <Divider />
              
              <List.Item
                title="Comments"
                description="When someone comments on your prayer requests"
                right={() => (
                  <Switch
                    value={commentNotifications}
                    onValueChange={setCommentNotifications}
                    color={theme.colors.primary}
                  />
                )}
              />
              <Divider />
              
              <List.Item
                title="Prayer Reminders"
                description="Get reminders for your scheduled prayers"
                right={() => (
                  <Switch
                    value={reminderNotifications}
                    onValueChange={setReminderNotifications}
                    color={theme.colors.primary}
                  />
                )}
              />
            </Card.Content>
          </Card>
        )}
        
        {/* Reminders Tab */}
        {activeTab === 'reminders' && (
          <Card style={styles.card}>
            <Card.Content>
              <Text variant="titleMedium" style={styles.sectionTitle}>
                Prayer Reminders
              </Text>
              
              <Text variant="bodyMedium" style={styles.reminderDescription}>
                Set up scheduled reminders to pray for specific requests or groups.
              </Text>
              
              {/* This would typically display a list of existing reminders */}
              <View style={styles.emptyReminders}>
                <Text variant="bodyLarge" style={{ textAlign: 'center' }}>
                  You don't have any prayer reminders yet
                </Text>
                <Button
                  mode="contained"
                  onPress={() => {/* Navigate to create reminder */}}
                  style={styles.addReminderButton}
                >
                  Create Reminder
                </Button>
              </View>
            </Card.Content>
          </Card>
        )}
        
        {/* Account Tab */}
        {activeTab === 'account' && (
          <View>
            <Card style={styles.card}>
              <Card.Content>
                <Text variant="titleMedium" style={styles.sectionTitle}>
                  Organizations
                </Text>
                
                <List.Item
                  title="Manage Organizations"
                  description="Create, join, or leave organizations"
                  left={props => <List.Icon {...props} icon="office-building" />}
                  onPress={navigateToOrganizations}
                />
                <Divider />
                
                <Text variant="titleMedium" style={[styles.sectionTitle, { marginTop: 20 }]}>
                  Account Security
                </Text>
                
                <List.Item
                  title="Change Password"
                  description="Update your account password"
                  left={props => <List.Icon {...props} icon="lock" />}
                  onPress={() => {/* Navigate to change password */}}
                />
                <Divider />
                
                <List.Item
                  title="Delete Account"
                  description="Permanently delete your account and data"
                  left={props => <List.Icon {...props} icon="delete" color="red" />}
                  onPress={() => {/* Show delete account confirmation */}}
                />
              </Card.Content>
            </Card>
            
            <Button
              mode="outlined"
              onPress={handleLogout}
              style={styles.logoutButton}
              icon="logout"
            >
              Log Out
            </Button>
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  tabs: {
    margin: 16,
  },
  content: {
    flex: 1,
  },
  profileHeader: {
    alignItems: 'center',
    padding: 20,
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 8,
  },
  avatar: {
    marginBottom: 16,
  },
  profileName: {
    marginBottom: 4,
  },
  profileUsername: {
    opacity: 0.6,
  },
  profileForm: {
    marginHorizontal: 16,
    marginBottom: 16,
  },
  input: {
    marginBottom: 16,
  },
  errorText: {
    color: 'red',
    marginTop: -12,
    marginBottom: 16,
    fontSize: 12,
  },
  submitButton: {
    marginTop: 8,
  },
  card: {
    margin: 16,
  },
  sectionTitle: {
    marginBottom: 16,
  },
  reminderDescription: {
    marginBottom: 24,
  },
  emptyReminders: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  addReminderButton: {
    marginTop: 16,
  },
  logoutButton: {
    margin: 16,
  },
});
```

## File: mobile/src/services/notificationService.ts
```typescript
import * as Device from 'expo-device';
import * as Notifications from 'expo-notifications';
import { Platform } from 'react-native';
import Constants from 'expo-constants';
import { apiRequest } from '@/api/queryClient';

// Configure how notifications appear when the app is in the foreground
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: true,
  }),
});

// Check if the device can receive push notifications
export async function checkNotificationPermissions(): Promise<boolean> {
  if (!Device.isDevice) {
    console.log('Push notifications are not available on simulators/emulators');
    return false;
  }

  const { status: existingStatus } = await Notifications.getPermissionsAsync();
  let finalStatus = existingStatus;

  // If we don't have permission yet, ask for it
  if (existingStatus !== 'granted') {
    const { status } = await Notifications.requestPermissionsAsync();
    finalStatus = status;
  }

  // If we still don't have permission, we can't send notifications
  if (finalStatus !== 'granted') {
    console.log('Failed to get push token for push notification!');
    return false;
  }

  return true;
}

// Register for push notifications
export async function registerForPushNotifications(): Promise<string | null> {
  try {
    const hasPermission = await checkNotificationPermissions();
    
    if (!hasPermission) {
      return null;
    }

    // Get the token that uniquely identifies this device
    const pushToken = await Notifications.getExpoPushTokenAsync({
      projectId: Constants.expoConfig?.extra?.eas?.projectId,
    });

    // Register the token with our backend
    try {
      await apiRequest('POST', '/api/push/register-token', {
        token: pushToken.data,
        deviceType: Platform.OS,
      });
      console.log('Push token registered with backend:', pushToken.data);
    } catch (error) {
      console.error('Failed to register push token with backend:', error);
    }

    // Return the token
    return pushToken.data;
  } catch (error) {
    console.error('Error registering for push notifications:', error);
    return null;
  }
}

// Unregister from push notifications (e.g., on logout)
export async function unregisterFromPushNotifications(token: string): Promise<boolean> {
  try {
    await apiRequest('POST', '/api/push/unregister-token', {
      token,
    });
    return true;
  } catch (error) {
    console.error('Failed to unregister push token with backend:', error);
    return false;
  }
}

// Setup notification listeners to handle received notifications
export function setupNotificationListeners(
  onNotificationReceived?: (notification: Notifications.Notification) => void,
  onNotificationResponseReceived?: (response: Notifications.NotificationResponse) => void
) {
  // Get notification when received while app is foregrounded
  const receivedSubscription = Notifications.addNotificationReceivedListener(
    (notification) => {
      if (onNotificationReceived) {
        onNotificationReceived(notification);
      }
    }
  );

  // Get notification when user taps/interacts with the notification
  const responseSubscription = Notifications.addNotificationResponseReceivedListener(
    (response) => {
      if (onNotificationResponseReceived) {
        onNotificationResponseReceived(response);
      }
      
      // Handle notification action here
      // You can extract data from the notification and navigate accordingly
      const data = response.notification.request.content.data;
      handleNotificationNavigation(data);
    }
  );

  // Return cleanup function to remove listeners
  return () => {
    receivedSubscription.remove();
    responseSubscription.remove();
  };
}

// Handle navigation based on notification data
export function handleNotificationNavigation(data: any) {
  // This would be integrated with your navigation system
  // Example:
  // if (data.type === 'prayer_request' && data.requestId) {
  //   navigation.navigate('RequestDetails', { requestId: data.requestId });
  // }
  console.log('Notification navigation data:', data);
}

// Send a local notification for testing
export async function sendLocalNotification(
  title: string,
  body: string,
  data?: any
): Promise<void> {
  await Notifications.scheduleNotificationAsync({
    content: {
      title,
      body,
      data: data || {},
    },
    trigger: null, // null means send immediately
  });
}

// Schedule a notification for a specific time
export async function scheduleNotification(
  title: string,
  body: string,
  scheduledTime: Date,
  data?: any
): Promise<string> {
  return await Notifications.scheduleNotificationAsync({
    content: {
      title,
      body,
      data: data || {},
    },
    trigger: {
      date: scheduledTime,
    },
  });
}

// Cancel a specific notification by ID
export async function cancelNotification(notificationId: string): Promise<void> {
  await Notifications.cancelScheduledNotificationAsync(notificationId);
}

// Cancel all notifications
export async function cancelAllNotifications(): Promise<void> {
  await Notifications.cancelAllScheduledNotificationsAsync();
}
```

## File: mobile/App.tsx
```typescript
import React from 'react';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { PaperProvider, MD3LightTheme as DefaultTheme } from 'react-native-paper';
import { QueryClientProvider } from '@tanstack/react-query';
import { NavigationContainer } from '@react-navigation/native';
import AppNavigator from '@navigation/AppNavigator';
import { AuthProvider } from '@/context/AuthContext';
import { NotificationProvider } from '@/context/NotificationContext';
import { queryClient } from '@/api/queryClient';

// Customize the theme
const theme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    primary: '#6366f1', // Indigo for primary color
    secondary: '#0ea5e9', // Sky blue for secondary accents
    background: '#f5f5f5',
  },
};

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <PaperProvider theme={theme}>
        <SafeAreaProvider>
          <NavigationContainer>
            <AuthProvider>
              <NotificationProvider>
                <AppNavigator />
                <StatusBar style="auto" />
              </NotificationProvider>
            </AuthProvider>
          </NavigationContainer>
        </SafeAreaProvider>
      </PaperProvider>
    </QueryClientProvider>
  );
}
```

## File: mobile/babel.config.js
```javascript
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      [
        'module-resolver',
        {
          root: ['./'],
          alias: {
            '@': './src',
            '@components': './src/components',
            '@screens': './src/screens',
            '@hooks': './src/hooks',
            '@utils': './src/utils',
            '@api': './src/api',
            '@navigation': './src/navigation',
            '@assets': './assets'
          },
          extensions: ['.js', '.jsx', '.ts', '.tsx']
        }
      ]
    ]
  };
};
```

## File: mobile/package.json
```json
{
  "name": "prayer-pipeline-mobile",
  "version": "1.0.0",
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/webpack-config": "^19.0.0",
    "@react-navigation/native": "^6.1.12",
    "@react-navigation/native-stack": "^6.9.20",
    "@tanstack/react-query": "^5.25.0",
    "expo": "~50.0.7",
    "expo-status-bar": "~1.11.1",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-hook-form": "^7.50.1",
    "react-native": "0.73.4",
    "react-native-paper": "^5.12.3",
    "react-native-safe-area-context": "4.8.2",
    "react-native-screens": "~3.29.0",
    "react-native-web": "~0.19.6",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "~18.2.45",
    "typescript": "^5.1.3"
  },
  "private": true
}
```

## File: mobile/tsconfig.json
```json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@screens/*": ["src/screens/*"],
      "@hooks/*": ["src/hooks/*"],
      "@utils/*": ["src/utils/*"],
      "@api/*": ["src/api/*"],
      "@navigation/*": ["src/navigation/*"],
      "@assets/*": ["assets/*"]
    }
  }
}
```

## File: server/auth.ts
```typescript
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import { storage } from "./storage";
import { User as SelectUser } from "@shared/schema";

declare global {
  namespace Express {
    interface User extends SelectUser {}
  }
}

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedBuf, suppliedBuf);
}

export function setupAuth(app: Express) {
  const sessionSettings: session.SessionOptions = {
    secret: process.env.SESSION_SECRET || "prayer-pipeline-secret-key",
    resave: false,
    saveUninitialized: false,
    store: storage.sessionStore,
  };

  app.set("trust proxy", 1);
  app.use(session(sessionSettings));
  app.use(passport.initialize());
  app.use(passport.session());

  passport.use(
    new LocalStrategy(async (username, password, done) => {
      const user = await storage.getUserByUsername(username);
      if (!user || !(await comparePasswords(password, user.password))) {
        return done(null, false);
      } else {
        return done(null, user);
      }
    }),
  );

  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id: number, done) => {
    const user = await storage.getUser(id);
    done(null, user);
  });

  app.post("/api/register", async (req, res, next) => {
    try {
      const { username, password, name, email, role } = req.body;

      if (!email || !email.includes('@')) {
        return res.status(400).json({ message: "Invalid email address" });
      }

      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(400).json({ message: "Username already exists" });
      }

      // Check for existing email
      const users = await storage.getUsers();
      const emailExists = users.some(user => user.email === email);
      if (emailExists) {
        return res.status(400).json({ message: "Email already in use" });
      }

      const user = await storage.createUser({
        username,
        password: await hashPassword(password),
        name,
        email,
        role: role || "regular",
      });

      // Remove password from response
      const { password: _, ...userWithoutPassword } = user;

      req.login(user, (err) => {
        if (err) return next(err);
        res.status(201).json(userWithoutPassword);
      });
    } catch (error) {
      next(error);
    }
  });

  app.post("/api/login", (req, res, next) => {
    passport.authenticate("local", (err, user, info) => {
      if (err) return next(err);
      if (!user) return res.status(401).json({ message: "Invalid credentials" });
      
      req.login(user, (err) => {
        if (err) return next(err);
        
        // Remove password from response
        const { password, ...userWithoutPassword } = user;
        
        res.status(200).json(userWithoutPassword);
      });
    })(req, res, next);
  });

  app.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });

  app.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) return res.sendStatus(401);
    
    // Remove password from response
    const { password, ...userWithoutPassword } = req.user;
    
    res.json(userWithoutPassword);
  });
}
```

## File: server/db.ts
```typescript
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });
```

## File: server/index.ts
```typescript
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { runMigrations } from "./migrations";

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  try {
    // Run database migrations first
    await runMigrations();
  } catch (error) {
    console.error("Failed to run migrations:", error);
    process.exit(1);
  }
  
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = 5000;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();
```

## File: server/migrations.ts
```typescript
import { db, pool } from "./db";
import { sql } from "drizzle-orm";

export async function runMigrations() {
  console.log("Running database migrations...");
  
  try {
    // Check if is_recurring column exists in meetings table
    const result = await pool.query(`
      SELECT column_name FROM information_schema.columns 
      WHERE table_name = 'meetings' AND column_name = 'is_recurring'
    `);
    
    if (result.rows.length === 0) {
      console.log("Adding is_recurring column to meetings table...");
      await pool.query(`
        ALTER TABLE meetings 
        ADD COLUMN is_recurring BOOLEAN NOT NULL DEFAULT false
      `);
      console.log("is_recurring column added successfully");
    } else {
      console.log("is_recurring column already exists");
    }
    
    // Check if other columns exist and add them if needed
    const recurringPatternResult = await pool.query(`
      SELECT column_name FROM information_schema.columns 
      WHERE table_name = 'meetings' AND column_name = 'recurring_pattern'
    `);
    
    if (recurringPatternResult.rows.length === 0) {
      console.log("Adding recurring_pattern column to meetings table...");
      await pool.query(`
        ALTER TABLE meetings 
        ADD COLUMN recurring_pattern TEXT DEFAULT NULL
      `);
      console.log("recurring_pattern column added successfully");
    }
    
    const recurringDayResult = await pool.query(`
      SELECT column_name FROM information_schema.columns 
      WHERE table_name = 'meetings' AND column_name = 'recurring_day'
    `);
    
    if (recurringDayResult.rows.length === 0) {
      console.log("Adding recurring_day column to meetings table...");
      await pool.query(`
        ALTER TABLE meetings 
        ADD COLUMN recurring_day INTEGER DEFAULT NULL
      `);
      console.log("recurring_day column added successfully");
    }
    
    const recurringUntilResult = await pool.query(`
      SELECT column_name FROM information_schema.columns 
      WHERE table_name = 'meetings' AND column_name = 'recurring_until'
    `);
    
    if (recurringUntilResult.rows.length === 0) {
      console.log("Adding recurring_until column to meetings table...");
      await pool.query(`
        ALTER TABLE meetings 
        ADD COLUMN recurring_until TIMESTAMP DEFAULT NULL
      `);
      console.log("recurring_until column added successfully");
    }
    
    const parentMeetingIdResult = await pool.query(`
      SELECT column_name FROM information_schema.columns 
      WHERE table_name = 'meetings' AND column_name = 'parent_meeting_id'
    `);
    
    if (parentMeetingIdResult.rows.length === 0) {
      console.log("Adding parent_meeting_id column to meetings table...");
      await pool.query(`
        ALTER TABLE meetings 
        ADD COLUMN parent_meeting_id INTEGER DEFAULT NULL
      `);
      console.log("parent_meeting_id column added successfully");
    }
    
    // Check if prayer_reminders table exists
    const prayerRemindersResult = await pool.query(`
      SELECT table_name FROM information_schema.tables 
      WHERE table_name = 'prayer_reminders'
    `);
    
    if (prayerRemindersResult.rows.length === 0) {
      console.log("Creating prayer_reminders table...");
      await pool.query(`
        CREATE TABLE prayer_reminders (
          id SERIAL PRIMARY KEY,
          user_id INTEGER NOT NULL,
          title TEXT NOT NULL,
          description TEXT,
          reminder_time TIME NOT NULL,
          is_recurring BOOLEAN NOT NULL DEFAULT FALSE,
          recurring_days TEXT,
          active_until TIMESTAMP,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
          is_active BOOLEAN NOT NULL DEFAULT TRUE
        )
      `);
      console.log("prayer_reminders table created successfully");
    } else {
      console.log("prayer_reminders table already exists");
    }
    
    console.log("All migrations completed successfully");
  } catch (error) {
    console.error("Error running migrations:", error);
    throw error;
  }
}
```

## File: server/push-notifications.ts
```typescript
import webpush from 'web-push';
import { storage } from './storage';
import { Request, Response } from 'express';
import { db } from './db';
import { subscriptions, PrayerReminder, pushTokens } from '@shared/schema';
import { eq } from 'drizzle-orm';
import fetch from 'node-fetch';

// Generate VAPID keys for web push notifications
// These should be generated only once and stored securely
// In production, these should be stored in environment variables
const vapidKeys = {
  publicKey: process.env.VAPID_PUBLIC_KEY || 'BLc-Gp6TOcOkblpBXVHGHD9iqTX5tkQIBOuhk0NmM5S6v4Ym3xIhw0YWKUvAVj_2s5lNw-rIiLPEazLmIeaD87U',
  privateKey: process.env.VAPID_PRIVATE_KEY || 'HF3isULudwZfpBfLLgj86qnUAfZtYAP1RKGCxWQmq_o'
};

// Set up web push with VAPID keys
webpush.setVapidDetails(
  'mailto:contact@prayerpipeline.app', // Change to your email
  vapidKeys.publicKey,
  vapidKeys.privateKey
);

// Function to subscribe a user to push notifications
export async function subscribeUser(req: Request, res: Response) {
  if (!req.user) {
    return res.status(401).json({ message: 'Not authenticated' });
  }

  const { subscription, deviceInfo } = req.body;

  if (!subscription) {
    return res.status(400).json({ message: 'Subscription data is required' });
  }

  try {
    // Save subscription to database with user ID
    const [savedSubscription] = await db.insert(subscriptions)
      .values({
        userId: req.user.id,
        endpoint: subscription.endpoint,
        p256dh: subscription.keys.p256dh,
        auth: subscription.keys.auth,
        userAgent: deviceInfo?.userAgent || req.headers['user-agent'] || '',
        createdAt: new Date()
      })
      .returning();

    return res.status(201).json({
      message: 'Subscription added successfully',
      id: savedSubscription.id
    });
  } catch (error) {
    console.error('Error saving subscription:', error);
    return res.status(500).json({ message: 'Failed to save subscription' });
  }
}

// Function to unsubscribe a user from push notifications
export async function unsubscribeUser(req: Request, res: Response) {
  if (!req.user) {
    return res.status(401).json({ message: 'Not authenticated' });
  }

  const { endpoint } = req.body;

  if (!endpoint) {
    return res.status(400).json({ message: 'Endpoint is required' });
  }

  try {
    // Remove subscription from database
    await db.delete(subscriptions)
      .where(eq(subscriptions.endpoint, endpoint));

    return res.status(200).json({ message: 'Subscription removed successfully' });
  } catch (error) {
    console.error('Error removing subscription:', error);
    return res.status(500).json({ message: 'Failed to remove subscription' });
  }
}

// Function to send a push notification to a user
export async function sendPushNotification(userId: number, title: string, body: string, url?: string) {
  try {
    // Track results
    let webPushSuccessful = 0;
    let webPushFailed = 0;
    let expoPushSuccessful = 0;
    let expoPushFailed = 0;

    // 1. Send Web Push Notifications
    const userSubscriptions = await db.select()
      .from(subscriptions)
      .where(eq(subscriptions.userId, userId));

    if (userSubscriptions.length > 0) {
      // Prepare web push notification payload
      const webPushPayload = JSON.stringify({
        title,
        body,
        url: url || '/',
        timestamp: new Date().getTime()
      });

      // Send notification to all user's web push subscriptions
      const webPushResults = await Promise.allSettled(
        userSubscriptions.map(async (subscription) => {
          try {
            await webpush.sendNotification({
              endpoint: subscription.endpoint,
              keys: {
                p256dh: subscription.p256dh,
                auth: subscription.auth
              }
            }, webPushPayload);
            return { success: true, endpoint: subscription.endpoint };
          } catch (error: any) {
            // If subscription is expired or invalid, remove it
            if (error.statusCode === 404 || error.statusCode === 410) {
              await db.delete(subscriptions)
                .where(eq(subscriptions.endpoint, subscription.endpoint));
            }
            throw error;
          }
        })
      );

      // Count successful and failed web push notifications
      webPushSuccessful = webPushResults.filter(r => r.status === 'fulfilled').length;
      webPushFailed = webPushResults.filter(r => r.status === 'rejected').length;
    }

    // 2. Send Expo Push Notifications
    const userTokens = await db.select()
      .from(pushTokens)
      .where(eq(pushTokens.userId, userId));

    if (userTokens.length > 0) {
      // Prepare messages for Expo push service
      const messages = userTokens.map(tokenRecord => ({
        to: tokenRecord.token,
        sound: 'default',
        title,
        body,
        data: { url: url || '/' },
      }));

      // Send to Expo push service
      const expoPushResponse = await fetch('https://exp.host/--/api/v2/push/send', {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(messages)
      });

      const expoPushResult = await expoPushResponse.json() as {
        data?: { 
          status: 'ok' | 'error';
          message?: string;
        }[] 
      };
      
      if (expoPushResult.data) {
        // Count successful and failed expo push notifications
        expoPushSuccessful = expoPushResult.data.filter(item => item.status === 'ok').length;
        expoPushFailed = messages.length - expoPushSuccessful;

        // Clean up any invalid tokens
        if (expoPushResult.data.some(item => item.status === 'error')) {
          for (let i = 0; i < expoPushResult.data.length; i++) {
            const item = expoPushResult.data[i];
            if (item.status === 'error' && 
                item.message && (
                  item.message === 'DeviceNotRegistered' || 
                  item.message === 'InvalidCredentials' || 
                  item.message === 'MessageTooBig' || 
                  item.message === 'MessageRateExceeded'
                )) {
              // Remove invalid token
              await db.delete(pushTokens)
                .where(eq(pushTokens.token, messages[i].to));
            }
          }
        }
      }
    }

    const totalSuccessful = webPushSuccessful + expoPushSuccessful;
    const totalFailed = webPushFailed + expoPushFailed;
    const totalAttempted = totalSuccessful + totalFailed;

    if (totalAttempted === 0) {
      return { success: false, message: 'No push notification subscriptions found for user' };
    }

    return {
      success: totalSuccessful > 0,
      message: `Sent ${totalSuccessful} notifications (${webPushSuccessful} web, ${expoPushSuccessful} mobile), failed to send ${totalFailed} notifications`,
      web: { successful: webPushSuccessful, failed: webPushFailed },
      expo: { successful: expoPushSuccessful, failed: expoPushFailed }
    };
  } catch (error) {
    console.error('Error sending push notification:', error);
    return { success: false, message: 'Failed to send push notification' };
  }
}

// Function to send group notifications for new prayer requests
export async function sendGroupNotification(groupId: number, exceptUserId: number, title: string, body: string, url?: string) {
  try {
    // Get all members of the group
    const members = await storage.getGroupMembers(groupId);
    
    // Send notification to each member except the one who triggered it
    const results = await Promise.allSettled(
      members
        .filter(member => member.userId !== exceptUserId)
        .map(member => sendPushNotification(member.userId, title, body, url))
    );

    // Count successful and failed notifications
    const successful = results.filter(r => r.status === 'fulfilled' && (r.value as any).success).length;
    const failed = results.length - successful;

    return {
      success: successful > 0,
      message: `Sent ${successful} group notifications, failed to send ${failed} notifications`
    };
  } catch (error) {
    console.error('Error sending group notification:', error);
    return { success: false, message: 'Failed to send group notification' };
  }
}

// VAPID public key getter - for the frontend to use
export function getVapidPublicKey(req: Request, res: Response) {
  res.json({ publicKey: vapidKeys.publicKey });
}

// Function to register an Expo push token
export async function registerPushToken(req: Request, res: Response) {
  if (!req.user) {
    return res.status(401).json({ message: 'Not authenticated' });
  }

  const { token, deviceType } = req.body;

  if (!token) {
    return res.status(400).json({ message: 'Push token is required' });
  }

  try {
    // Check if token already exists
    const existingToken = await db.select()
      .from(pushTokens)
      .where(eq(pushTokens.token, token))
      .limit(1);

    if (existingToken.length > 0) {
      // Update last used time
      await db.update(pushTokens)
        .set({ 
          lastUsed: new Date(),
          userId: req.user.id, // Update user ID in case token was transferred between accounts
          deviceType: deviceType || existingToken[0].deviceType 
        })
        .where(eq(pushTokens.token, token));

      return res.status(200).json({ 
        message: 'Push token updated successfully',
        id: existingToken[0].id
      });
    }

    // Save new token to database with user ID
    const [savedToken] = await db.insert(pushTokens)
      .values({
        userId: req.user.id,
        token,
        deviceType: deviceType || 'unknown',
        createdAt: new Date(),
        lastUsed: new Date()
      })
      .returning();

    return res.status(201).json({
      message: 'Push token registered successfully',
      id: savedToken.id
    });
  } catch (error) {
    console.error('Error registering push token:', error);
    return res.status(500).json({ message: 'Failed to register push token' });
  }
}

// Function to unregister an Expo push token
export async function unregisterPushToken(req: Request, res: Response) {
  if (!req.user) {
    return res.status(401).json({ message: 'Not authenticated' });
  }

  const { token } = req.body;

  if (!token) {
    return res.status(400).json({ message: 'Push token is required' });
  }

  try {
    // Remove token from database
    await db.delete(pushTokens)
      .where(eq(pushTokens.token, token));

    return res.status(200).json({ message: 'Push token removed successfully' });
  } catch (error) {
    console.error('Error removing push token:', error);
    return res.status(500).json({ message: 'Failed to remove push token' });
  }
}

// Function to schedule a prayer reminder notification
export async function schedulePrayerReminderNotification(userId: number, reminder: PrayerReminder): Promise<boolean> {
  try {
    // Convert time string to Date object for today
    const now = new Date();
    const reminderTimeStr = reminder.reminderTime.toString(); // "HH:MM:SS"
    const [hours, minutes] = reminderTimeStr.split(':').map(Number);
    
    let targetDate = new Date(now);
    targetDate.setHours(hours, minutes, 0, 0);
    
    // If the time has already passed today, schedule for tomorrow
    if (targetDate.getTime() < now.getTime()) {
      targetDate.setDate(targetDate.getDate() + 1);
    }
    
    // Check if this is a recurring reminder and if it should be scheduled today
    if (reminder.isRecurring && reminder.recurringDays) {
      const recurringDays = JSON.parse(reminder.recurringDays) as string[];
      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      const currentDayName = dayNames[targetDate.getDay()].toLowerCase();
      
      // If today is not in the recurring days, find the next valid day
      if (!recurringDays.includes(currentDayName)) {
        let daysToAdd = 1;
        let nextDayName = dayNames[(targetDate.getDay() + daysToAdd) % 7].toLowerCase();
        
        // Find the next valid day
        while (!recurringDays.includes(nextDayName) && daysToAdd < 7) {
          daysToAdd++;
          nextDayName = dayNames[(targetDate.getDay() + daysToAdd) % 7].toLowerCase();
        }
        
        // Adjust the target date to the next valid day
        targetDate.setDate(targetDate.getDate() + daysToAdd);
      }
    }
    
    // Check if the reminder is still active (activeUntil not passed)
    if (reminder.activeUntil && new Date(reminder.activeUntil) < targetDate) {
      return false; // Don't schedule if the reminder has expired
    }
    
    // Calculate milliseconds until the notification should be sent
    const timeUntilNotification = targetDate.getTime() - now.getTime();
    
    // Schedule the notification
    setTimeout(() => {
      sendPushNotification(
        userId,
        reminder.title,
        reminder.description || 'Time to pray!',
        '/prayer-requests'
      ).catch(err => console.error('Error sending prayer reminder notification:', err));
    }, timeUntilNotification);
    
    console.log(`Prayer reminder "${reminder.title}" scheduled for ${targetDate.toLocaleString()} (in ${Math.round(timeUntilNotification / 60000)} minutes)`);
    
    return true;
  } catch (error) {
    console.error('Error scheduling prayer reminder notification:', error);
    return false;
  }
}
```

## File: server/routes.ts
```typescript
import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth } from "./auth";
import { db } from "./db";
import { 
  subscribeUser, 
  unsubscribeUser, 
  getVapidPublicKey, 
  schedulePrayerReminderNotification,
  registerPushToken,
  unregisterPushToken
} from "./push-notifications";
import {
  insertGroupSchema,
  insertPrayerRequestSchema,
  insertCommentSchema,
  insertGroupMemberSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
  insertOrganizationSchema,
  insertOrganizationMemberSchema,
  insertMeetingSchema,
  insertMeetingNotesSchema,
  insertPrayerReminderSchema,
  prayerRequests,
  prayerReminders,
  users,
  meetings,
  meetingNotes,
} from "@shared/schema";
import { sql, and, eq, lt, isNull } from "drizzle-orm";
import { ZodError } from "zod";
import { fromZodError } from "zod-validation-error";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedBuf, suppliedBuf);
}

// Middleware to check if user is authenticated
const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  if (req.isAuthenticated()) {
    // If this passes, req.user is guaranteed to be defined
    return next();
  }
  res.status(401).json({ message: "Not authenticated" });
};

// TypeScript type guard to ensure req.user is defined
function assertUser(req: Request): asserts req is Request & { user: Express.User } {
  if (!req.user) throw new Error("User is not authenticated");
}

// Middleware to check if user has a specific role
const hasRole = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ message: "Insufficient permissions" });
    }

    next();
  };
};

// Middleware to check if user is member of a group
const isGroupMember = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  const groupId = parseInt(req.params.groupId);
  if (isNaN(groupId)) {
    return res.status(400).json({ message: "Invalid group ID" });
  }

  const membership = await storage.getGroupMember(groupId, req.user.id);
  if (!membership) {
    return res.status(403).json({ message: "You are not a member of this group" });
  }

  next();
};

// Middleware to check if user is leader of a group
const isGroupLeader = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  const groupId = parseInt(req.params.groupId);
  if (isNaN(groupId)) {
    return res.status(400).json({ message: "Invalid group ID" });
  }

  const membership = await storage.getGroupMember(groupId, req.user.id);
  if (!membership || membership.role !== "leader") {
    return res.status(403).json({ message: "You are not a leader of this group" });
  }

  next();
};

// Middleware to check if user is owner of a prayer request
const isPrayerRequestOwner = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  const requestId = parseInt(req.params.requestId);
  if (isNaN(requestId)) {
    return res.status(400).json({ message: "Invalid request ID" });
  }

  const request = await storage.getPrayerRequest(requestId);
  if (!request) {
    return res.status(404).json({ message: "Prayer request not found" });
  }

  if (request.userId !== req.user.id && req.user.role !== "admin") {
    return res.status(403).json({ message: "You don't have permission to modify this prayer request" });
  }

  next();
};

// Middleware to check if user is owner of a comment
const isCommentOwner = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  const commentId = parseInt(req.params.commentId);
  if (isNaN(commentId)) {
    return res.status(400).json({ message: "Invalid comment ID" });
  }

  const comment = await storage.getComment(commentId);
  if (!comment) {
    return res.status(404).json({ message: "Comment not found" });
  }

  if (comment.userId !== req.user.id && req.user.role !== "admin") {
    return res.status(403).json({ message: "You don't have permission to modify this comment" });
  }

  next();
};

// Middleware to check if user is a member of an organization
const isOrganizationMember = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  const organizationId = parseInt(req.params.organizationId);
  if (isNaN(organizationId)) {
    return res.status(400).json({ message: "Invalid organization ID" });
  }

  const membership = await storage.getOrganizationMember(organizationId, req.user.id);
  if (!membership) {
    return res.status(403).json({ message: "You are not a member of this organization" });
  }

  next();
};

// Middleware to check if user is an admin of an organization
const isOrganizationAdmin = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  const organizationId = parseInt(req.params.organizationId);
  if (isNaN(organizationId)) {
    return res.status(400).json({ message: "Invalid organization ID" });
  }

  const membership = await storage.getOrganizationMember(organizationId, req.user.id);
  if (!membership || membership.role !== "admin") {
    return res.status(403).json({ message: "You are not an admin of this organization" });
  }

  next();
};

// Middleware to check if user is owner of a meeting
const isMeetingOwner = async (req: Request, res: Response, next: NextFunction) => {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  const meetingId = parseInt(req.params.meetingId);
  if (isNaN(meetingId)) {
    return res.status(400).json({ message: "Invalid meeting ID" });
  }

  const meeting = await storage.getMeeting(meetingId);
  if (!meeting) {
    return res.status(404).json({ message: "Meeting not found" });
  }

  // Allow meeting creator or group leader to manage the meeting
  if (meeting.createdBy !== req.user.id) {
    // Check if user is a group leader
    const membership = await storage.getGroupMember(meeting.groupId, req.user.id);
    if (!membership || membership.role !== "leader") {
      return res.status(403).json({ message: "You don't have permission to modify this meeting" });
    }
  }

  // Add meeting to request object for later use
  (req as any).meeting = meeting;
  next();
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Set up authentication routes
  setupAuth(app);

  // Error handling middleware for Zod validation errors
  app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
    if (err instanceof ZodError) {
      const validationError = fromZodError(err);
      return res.status(400).json({ message: validationError.message });
    }
    next(err);
  });

  // Groups
  app.post("/api/groups", isAuthenticated, async (req, res, next) => {
    try {
      // Assert user is authenticated
      assertUser(req);
      
      // Validate organization membership if organizationId is provided
      if (req.body.organizationId) {
        const organizationId = parseInt(req.body.organizationId);
        const membership = await storage.getOrganizationMember(organizationId, req.user.id);
        if (!membership) {
          return res.status(403).json({ message: "You are not a member of this organization" });
        }
      }
      
      const parsedData = insertGroupSchema.parse({
        ...req.body,
        createdBy: req.user.id
      });
      
      const group = await storage.createGroup(parsedData);
      res.status(201).json(group);
    } catch (error) {
      next(error);
    }
  });

  // Get all favorite groups for the current user
  // This specific route must be defined BEFORE any parameterized routes like /api/groups/:groupId
  app.get("/api/groups/favorites", isAuthenticated, async (req, res) => {
    assertUser(req);
    const userId = req.user.id;
    
    try {
      const favoriteGroups = await storage.getUserFavoriteGroups(userId);
      res.json(favoriteGroups);
    } catch (error) {
      console.error("Error fetching favorite groups:", error);
      res.status(500).json({ message: "Failed to fetch favorite groups" });
    }
  });
  
  app.get("/api/groups", isAuthenticated, async (req, res) => {
    assertUser(req);
    const organizationId = req.query.organizationId ? parseInt(req.query.organizationId as string) : null;
    
    // If organizationId is provided, filter groups by that organization
    if (organizationId) {
      // Verify the user belongs to this organization
      const userOrganizations = await storage.getUserOrganizations(req.user.id);
      const userOrganizationIds = userOrganizations.map(org => org.id);
      
      if (!userOrganizationIds.includes(organizationId)) {
        return res.status(403).json({ message: "You don't have access to this organization" });
      }
      
      // Get all groups and filter by organization
      const allGroups = await storage.getGroups();
      const organizationGroups = allGroups.filter(group => group.organizationId === organizationId);
      return res.json(organizationGroups);
    }
    
    // If no organizationId is provided, get groups from all user's organizations
    const userOrganizations = await storage.getUserOrganizations(req.user.id);
    
    if (userOrganizations.length === 0) {
      return res.json([]);
    }
    
    // Get only groups from the user's organizations
    const organizationIds = userOrganizations.map(org => org.id);
    const allGroups = await storage.getGroups();
    
    // Filter groups to only include those from the user's organizations
    const filteredGroups = allGroups.filter(group => 
      organizationIds.includes(group.organizationId)
    );
    
    res.json(filteredGroups);
  });

  app.get("/api/groups/category/:category", isAuthenticated, async (req, res) => {
    assertUser(req);
    const { category } = req.params;
    const organizationId = req.query.organizationId ? parseInt(req.query.organizationId as string) : null;
    
    // If organizationId is provided, filter groups by organization
    if (organizationId) {
      const groups = await storage.getGroupsByCategory(category);
      const filteredGroups = groups.filter(group => group.organizationId === organizationId);
      return res.json(filteredGroups);
    }
    
    // Otherwise, get groups from all organizations the user belongs to
    const userOrganizations = await storage.getUserOrganizations(req.user.id);
    if (userOrganizations.length === 0) {
      return res.json([]);
    }
    
    const organizationIds = userOrganizations.map(org => org.id);
    const groups = await storage.getGroupsByCategory(category);
    const filteredGroups = groups.filter(group => 
      organizationIds.includes(group.organizationId)
    );
    
    res.json(filteredGroups);
  });

  app.get("/api/groups/user", isAuthenticated, async (req, res) => {
    assertUser(req);
    const userOrganizations = await storage.getUserOrganizations(req.user.id);
    
    if (userOrganizations.length === 0) {
      return res.json([]);
    }
    
    // Get only groups from the user's current organization
    // Get the currentOrganizationId from query parameter if provided
    const currentOrganizationId = req.query.organizationId 
      ? parseInt(req.query.organizationId as string) 
      : userOrganizations[0].id;
    
    // Get the user's groups
    const userGroups = await storage.getUserGroups(req.user.id);
    
    // Filter to include only groups from the current organization
    const filteredGroups = userGroups.filter(group => 
      group.organizationId === currentOrganizationId
    );
    
    res.json(filteredGroups);
  });

  app.get("/api/groups/:groupId", isAuthenticated, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }

    const group = await storage.getGroup(groupId);
    if (!group) {
      return res.status(404).json({ message: "Group not found" });
    }

    res.json(group);
  });

  app.put("/api/groups/:groupId", isGroupLeader, async (req, res, next) => {
    try {
      const groupId = parseInt(req.params.groupId);
      const updates = insertGroupSchema.partial().parse(req.body);
      
      const updatedGroup = await storage.updateGroup(groupId, updates);
      if (!updatedGroup) {
        return res.status(404).json({ message: "Group not found" });
      }
      
      res.json(updatedGroup);
    } catch (error) {
      next(error);
    }
  });

  app.delete("/api/groups/:groupId", hasRole(["admin"]), async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }

    const success = await storage.deleteGroup(groupId);
    if (!success) {
      return res.status(404).json({ message: "Group not found" });
    }

    res.status(204).send();
  });

  // Group Members
  app.get("/api/groups/:groupId/members", isGroupMember, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    const members = await storage.getGroupMembers(groupId);
    
    // Fetch user details for each member
    const memberDetails = await Promise.all(
      members.map(async (member) => {
        const user = await storage.getUser(member.userId);
        if (!user) return null;
        
        const { password, ...userWithoutPassword } = user;
        return {
          ...member,
          user: userWithoutPassword
        };
      })
    );
    
    res.json(memberDetails.filter(m => m !== null));
  });

  app.post("/api/groups/:groupId/members", isGroupLeader, async (req, res, next) => {
    try {
      const groupId = parseInt(req.params.groupId);
      const { userId, role } = req.body;
      
      // Check if user exists
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check if already a member
      const existingMember = await storage.getGroupMember(groupId, userId);
      if (existingMember) {
        return res.status(400).json({ message: "User is already a member of this group" });
      }
      
      const memberData = insertGroupMemberSchema.parse({
        groupId,
        userId,
        role: role || "member"
      });
      
      const member = await storage.addGroupMember(memberData);
      
      // Create notification for added user
      const group = await storage.getGroup(groupId);
      if (group) {
        await storage.createNotification({
          userId,
          type: "added_to_group",
          message: `You were added to the group "${group.name}"`,
          referenceId: groupId
        });
      }
      
      res.status(201).json(member);
    } catch (error) {
      next(error);
    }
  });

  app.put("/api/groups/:groupId/members/:userId", isGroupLeader, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    const userId = parseInt(req.params.userId);
    const { role } = req.body;
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const updatedMember = await storage.updateGroupMember(groupId, userId, role);
    if (!updatedMember) {
      return res.status(404).json({ message: "Group member not found" });
    }
    
    res.json(updatedMember);
  });

  app.delete("/api/groups/:groupId/members/:userId", isGroupLeader, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    // Check if trying to remove the last leader
    const members = await storage.getGroupMembers(groupId);
    const leaders = members.filter(m => m.role === "leader");
    
    const targetMember = members.find(m => m.userId === userId);
    if (targetMember?.role === "leader" && leaders.length <= 1) {
      return res.status(400).json({ 
        message: "Cannot remove the last leader. Assign another leader first." 
      });
    }
    
    const success = await storage.removeGroupMember(groupId, userId);
    if (!success) {
      return res.status(404).json({ message: "Group member not found" });
    }
    
    res.status(204).send();
  });

  // Self-join a group
  app.post("/api/groups/:groupId/join", isAuthenticated, async (req, res) => {
    assertUser(req);
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }
    
    // Check if group exists
    const group = await storage.getGroup(groupId);
    if (!group) {
      return res.status(404).json({ message: "Group not found" });
    }
    
    // Check if already a member
    const existingMember = await storage.getGroupMember(groupId, req.user.id);
    if (existingMember) {
      return res.status(400).json({ message: "You are already a member of this group" });
    }
    
    // Check group privacy
    if (group.privacy !== "open") {
      return res.status(403).json({ 
        message: "This group requires an invitation or approval to join" 
      });
    }
    
    const member = await storage.addGroupMember({
      groupId,
      userId: req.user.id,
      role: "member"
    });
    
    res.status(201).json(member);
  });

  // Self-leave a group
  app.post("/api/groups/:groupId/leave", isAuthenticated, async (req, res) => {
    assertUser(req);
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }
    
    // Check if user is a member
    const membership = await storage.getGroupMember(groupId, req.user.id);
    if (!membership) {
      return res.status(400).json({ message: "You are not a member of this group" });
    }
    
    // Check if trying to leave as the last leader
    if (membership.role === "leader") {
      const members = await storage.getGroupMembers(groupId);
      const leaders = members.filter(m => m.role === "leader");
      
      if (leaders.length <= 1) {
        return res.status(400).json({ 
          message: "You are the last leader. Assign another leader first." 
        });
      }
    }
    
    const success = await storage.removeGroupMember(groupId, req.user.id);
    if (!success) {
      return res.status(500).json({ message: "Failed to leave group" });
    }
    
    res.status(204).send();
  });

  // Prayer Requests
  app.post("/api/groups/:groupId/requests", isGroupMember, async (req, res, next) => {
    try {
      const groupId = parseInt(req.params.groupId);
      
      // Pre-process followUpDate if it exists
      let processedBody = { ...req.body };
      if (processedBody.followUpDate && typeof processedBody.followUpDate === 'string') {
        processedBody.followUpDate = new Date(processedBody.followUpDate);
      }
      
      const requestData = insertPrayerRequestSchema.parse({
        ...processedBody,
        groupId,
        userId: req.user.id
      });
      
      const request = await storage.createPrayerRequest(requestData);
      res.status(201).json(request);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/groups/:groupId/requests", isGroupMember, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    const requests = await storage.getGroupPrayerRequests(groupId);
    
    // Enrich each request with author details and comment count
    const enrichedRequests = await Promise.all(
      requests.map(async (request) => {
        const author = await storage.getUser(request.userId);
        const comments = await storage.getPrayerRequestComments(request.id);
        const prayingCount = await storage.getPrayingForCount(request.id);
        const isPraying = await storage.isPrayingFor(request.id, req.user.id);
        
        const authorDetails = author ? {
          id: author.id,
          name: author.name,
          username: author.username
        } : null;
        
        return {
          ...request,
          author: request.isAnonymous ? null : authorDetails,
          isOwn: request.userId === req.user.id,
          commentCount: comments.length,
          prayingCount,
          isPraying
        };
      })
    );
    
    res.json(enrichedRequests);
  });

  app.get("/api/requests/:requestId", isAuthenticated, async (req, res) => {
    assertUser(req);
    const requestId = parseInt(req.params.requestId);
    if (isNaN(requestId)) {
      return res.status(400).json({ message: "Invalid request ID" });
    }
    
    const request = await storage.getPrayerRequest(requestId);
    if (!request) {
      return res.status(404).json({ message: "Prayer request not found" });
    }
    
    // Check if user is member of the group
    const membership = await storage.getGroupMember(request.groupId, req.user.id);
    if (!membership && req.user.role !== "admin") {
      return res.status(403).json({ 
        message: "You don't have permission to view this prayer request" 
      });
    }
    
    // Enrich request with author details and comment count
    const author = await storage.getUser(request.userId);
    const comments = await storage.getPrayerRequestComments(request.id);
    const prayingCount = await storage.getPrayingForCount(request.id);
    const isPraying = await storage.isPrayingFor(request.id, req.user.id);
    const group = await storage.getGroup(request.groupId);
    
    const authorDetails = author ? {
      id: author.id,
      name: author.name,
      username: author.username
    } : null;
    
    const enrichedRequest = {
      ...request,
      author: request.isAnonymous ? null : authorDetails,
      isOwn: request.userId === req.user.id,
      commentCount: comments.length,
      prayingCount,
      isPraying,
      group: group ? {
        id: group.id,
        name: group.name
      } : null
    };
    
    res.json(enrichedRequest);
  });

  app.put("/api/requests/:requestId", isPrayerRequestOwner, async (req, res, next) => {
    try {
      const requestId = parseInt(req.params.requestId);
      
      // Pre-process followUpDate if it exists
      let processedBody = { ...req.body };
      if (processedBody.followUpDate && typeof processedBody.followUpDate === 'string') {
        processedBody.followUpDate = new Date(processedBody.followUpDate);
      }
      
      const updates = insertPrayerRequestSchema.partial().parse(processedBody);
      
      const updatedRequest = await storage.updatePrayerRequest(requestId, updates);
      if (!updatedRequest) {
        return res.status(404).json({ message: "Prayer request not found" });
      }
      
      res.json(updatedRequest);
    } catch (error) {
      next(error);
    }
  });

  app.delete("/api/requests/:requestId", isPrayerRequestOwner, async (req, res) => {
    const requestId = parseInt(req.params.requestId);
    
    const success = await storage.deletePrayerRequest(requestId);
    if (!success) {
      return res.status(404).json({ message: "Prayer request not found" });
    }
    
    res.status(204).send();
  });

  app.get("/api/requests/user/recent", isAuthenticated, async (req, res) => {
    assertUser(req);
    const limit = req.query.limit ? parseInt(req.query.limit as string) : 5;
    const organizationId = req.query.organizationId ? parseInt(req.query.organizationId as string) : null;
    
    if (!organizationId) {
      return res.status(400).json({ error: "Organization ID is required" });
    }
    
    // Get user's groups in this organization
    const userGroups = await storage.getUserGroups(req.user.id);
    const organizationGroups = userGroups.filter(group => group.organizationId === organizationId);
    
    if (organizationGroups.length === 0) {
      return res.json([]);
    }
    
    // Get prayer requests only from the user's groups in this organization
    const organizationGroupIds = organizationGroups.map(group => group.id);
    const requests = await storage.getRecentPrayerRequestsByGroups(organizationGroupIds, limit);
    
    // Enrich each request with author details and comment count
    const enrichedRequests = await Promise.all(
      requests.map(async (request) => {
        const author = await storage.getUser(request.userId);
        const comments = await storage.getPrayerRequestComments(request.id);
        const group = await storage.getGroup(request.groupId);
        
        const authorDetails = author ? {
          id: author.id,
          name: author.name,
          username: author.username
        } : null;
        
        return {
          ...request,
          author: request.isAnonymous ? null : authorDetails,
          isOwn: request.userId === req.user.id,
          commentCount: comments.length,
          group: group ? {
            id: group.id,
            name: group.name
          } : null
        };
      })
    );
    
    res.json(enrichedRequests);
  });
  
  // Get all prayer requests from the user (for prayer journey page)
  app.get("/api/requests/user/all", isAuthenticated, async (req, res) => {
    assertUser(req);
    const organizationId = req.query.organizationId ? parseInt(req.query.organizationId as string) : null;
    
    if (!organizationId) {
      return res.status(400).json({ error: "Organization ID is required" });
    }
    
    // Get user's groups in this organization
    const userGroups = await storage.getUserGroups(req.user.id);
    const organizationGroups = userGroups.filter(group => group.organizationId === organizationId);
    
    if (organizationGroups.length === 0) {
      return res.json([]);
    }
    
    // Get prayer requests only from the user's groups in this organization
    const organizationGroupIds = organizationGroups.map(group => group.id);
    
    // Get all prayer requests by the user
    const requests = await storage.getUserPrayerRequests(req.user.id);
    
    // Filter to only include requests in groups from this organization
    const orgRequests = requests.filter(request => 
      organizationGroupIds.includes(request.groupId)
    );
    
    // Enrich each request with group and comment info
    const enrichedRequests = await Promise.all(
      orgRequests.map(async (request) => {
        const comments = await storage.getPrayerRequestComments(request.id);
        const group = await storage.getGroup(request.groupId);
        
        return {
          ...request,
          commentCount: comments.length,
          group: group ? {
            id: group.id,
            name: group.name
          } : null
        };
      })
    );
    
    res.json(enrichedRequests);
  });

  // Comments
  app.post("/api/requests/:requestId/comments", isAuthenticated, async (req, res, next) => {
    try {
      const requestId = parseInt(req.params.requestId);
      if (isNaN(requestId)) {
        return res.status(400).json({ message: "Invalid request ID" });
      }
      
      // Check if request exists
      const request = await storage.getPrayerRequest(requestId);
      if (!request) {
        return res.status(404).json({ message: "Prayer request not found" });
      }
      
      // Check if user is member of the group
      const membership = await storage.getGroupMember(request.groupId, req.user.id);
      if (!membership && req.user.role !== "admin") {
        return res.status(403).json({ 
          message: "You don't have permission to comment on this prayer request" 
        });
      }
      
      const commentData = insertCommentSchema.parse({
        ...req.body,
        prayerRequestId: requestId,
        userId: req.user.id
      });
      
      const comment = await storage.createComment(commentData);
      
      // Enrich comment with author details
      const author = await storage.getUser(comment.userId);
      const enrichedComment = {
        ...comment,
        author: {
          id: author!.id,
          name: author!.name,
          username: author!.username
        },
        isOwn: true
      };
      
      res.status(201).json(enrichedComment);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/requests/:requestId/comments", isAuthenticated, async (req, res) => {
    const requestId = parseInt(req.params.requestId);
    if (isNaN(requestId)) {
      return res.status(400).json({ message: "Invalid request ID" });
    }
    
    // Check if request exists
    const request = await storage.getPrayerRequest(requestId);
    if (!request) {
      return res.status(404).json({ message: "Prayer request not found" });
    }
    
    // Check if user is member of the group
    const membership = await storage.getGroupMember(request.groupId, req.user.id);
    if (!membership && req.user.role !== "admin") {
      return res.status(403).json({ 
        message: "You don't have permission to view comments on this prayer request" 
      });
    }
    
    const comments = await storage.getPrayerRequestComments(requestId);
    
    // Filter out private comments if not the request owner
    const filteredComments = comments.filter(comment => 
      !comment.isPrivate || request.userId === req.user.id || comment.userId === req.user.id
    );
    
    // Enrich each comment with author details
    const enrichedComments = await Promise.all(
      filteredComments.map(async (comment) => {
        const author = await storage.getUser(comment.userId);
        
        return {
          ...comment,
          author: {
            id: author!.id,
            name: author!.name,
            username: author!.username
          },
          isOwn: comment.userId === req.user.id
        };
      })
    );
    
    res.json(enrichedComments);
  });

  app.delete("/api/comments/:commentId", isCommentOwner, async (req, res) => {
    const commentId = parseInt(req.params.commentId);
    
    const success = await storage.deleteComment(commentId);
    if (!success) {
      return res.status(404).json({ message: "Comment not found" });
    }
    
    res.status(204).send();
  });

  // Notifications
  app.get("/api/notifications", isAuthenticated, async (req, res) => {
    const organizationId = req.query.organizationId ? parseInt(req.query.organizationId as string) : undefined;
    const notifications = await storage.getUserNotifications(req.user.id, organizationId);
    res.json(notifications);
  });

  app.patch("/api/notifications/:id/read", isAuthenticated, async (req, res) => {
    const notificationId = parseInt(req.params.id);
    if (isNaN(notificationId)) {
      return res.status(400).json({ message: "Invalid notification ID" });
    }
    
    const notification = await storage.markNotificationRead(notificationId);
    if (!notification) {
      return res.status(404).json({ message: "Notification not found" });
    }
    
    res.json(notification);
  });

  app.patch("/api/notifications/mark-all-read", isAuthenticated, async (req, res) => {
    const organizationId = req.query.organizationId ? parseInt(req.query.organizationId as string) : undefined;
    await storage.markAllNotificationsRead(req.user.id, organizationId);
    res.status(204).send();
  });

  app.delete("/api/notifications/:id", isAuthenticated, async (req, res) => {
    const notificationId = parseInt(req.params.id);
    if (isNaN(notificationId)) {
      return res.status(400).json({ message: "Invalid notification ID" });
    }
    
    const success = await storage.deleteNotification(notificationId);
    if (!success) {
      return res.status(404).json({ message: "Notification not found" });
    }
    
    res.status(204).send();
  });

  // Praying for
  app.post("/api/requests/:requestId/pray", isAuthenticated, async (req, res) => {
    const requestId = parseInt(req.params.requestId);
    if (isNaN(requestId)) {
      return res.status(400).json({ message: "Invalid request ID" });
    }
    
    // Check if request exists
    const request = await storage.getPrayerRequest(requestId);
    if (!request) {
      return res.status(404).json({ message: "Prayer request not found" });
    }
    
    // Check if user is already praying for this request
    const alreadyPraying = await storage.isPrayingFor(requestId, req.user.id);
    if (alreadyPraying) {
      return res.status(400).json({ message: "You are already praying for this request" });
    }
    
    const prayingFor = await storage.addPrayingFor({
      prayerRequestId: requestId,
      userId: req.user.id
    });
    
    const count = await storage.getPrayingForCount(requestId);
    
    res.status(201).json({ 
      prayingFor, 
      count 
    });
  });

  app.delete("/api/requests/:requestId/pray", isAuthenticated, async (req, res) => {
    const requestId = parseInt(req.params.requestId);
    if (isNaN(requestId)) {
      return res.status(400).json({ message: "Invalid request ID" });
    }
    
    // Check if user is praying for this request
    const isPraying = await storage.isPrayingFor(requestId, req.user.id);
    if (!isPraying) {
      return res.status(400).json({ message: "You are not praying for this request" });
    }
    
    const success = await storage.removePrayingFor(requestId, req.user.id);
    if (!success) {
      return res.status(500).json({ message: "Failed to remove prayer" });
    }
    
    const count = await storage.getPrayingForCount(requestId);
    
    res.json({ success, count });
  });

  // Favorite Groups routes
  app.post("/api/groups/:groupId/favorite", isAuthenticated, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }
    
    assertUser(req);
    const userId = req.user.id;
    
    // Check if group exists
    const group = await storage.getGroup(groupId);
    if (!group) {
      return res.status(404).json({ message: "Group not found" });
    }
    
    // Check if user is a member of the group
    const member = await storage.getGroupMember(groupId, userId);
    if (!member) {
      return res.status(403).json({ message: "You must be a member of the group to favorite it" });
    }
    
    try {
      const favorite = await storage.addFavoriteGroup(userId, groupId);
      res.status(201).json(favorite);
    } catch (error) {
      console.error("Error adding favorite group:", error);
      res.status(500).json({ message: "Failed to favorite group" });
    }
  });
  
  app.delete("/api/groups/:groupId/favorite", isAuthenticated, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }
    
    assertUser(req);
    const userId = req.user.id;
    
    try {
      const success = await storage.removeFavoriteGroup(userId, groupId);
      
      if (!success) {
        return res.status(404).json({ message: "Group is not in favorites" });
      }
      
      res.status(200).json({ success: true });
    } catch (error) {
      console.error("Error removing favorite group:", error);
      res.status(500).json({ message: "Failed to remove group from favorites" });
    }
  });
  
  app.get("/api/groups/:groupId/favorite", isAuthenticated, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }
    
    assertUser(req);
    const userId = req.user.id;
    
    try {
      const isFavorite = await storage.isFavoriteGroup(userId, groupId);
      res.json({ isFavorite });
    } catch (error) {
      console.error("Error checking if group is favorite:", error);
      res.status(500).json({ message: "Failed to check favorite status" });
    }
  });

  // User profile routes
  app.put("/api/user/profile", isAuthenticated, async (req, res) => {
    const { name, email, bio } = req.body;
    
    // Validate inputs
    if (typeof name !== 'string' || typeof email !== 'string') {
      return res.status(400).json({ message: "Invalid input data" });
    }
    
    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Invalid email format" });
    }
    
    try {
      // For now, we only update user's name and email since the User schema doesn't have a bio field
      const updatedUser = await storage.updateUser(req.user.id, { 
        name: name.trim(),
        email: email.trim()
      });
      
      if (!updatedUser) {
        return res.status(500).json({ message: "Failed to update user profile" });
      }
      
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "An error occurred while updating your profile" });
    }
  });
  
  app.post("/api/user/change-password", isAuthenticated, async (req, res) => {
    const { currentPassword, newPassword } = req.body;
    
    // Validate inputs
    if (typeof currentPassword !== 'string' || typeof newPassword !== 'string') {
      return res.status(400).json({ message: "Invalid input data" });
    }
    
    if (newPassword.length < 8) {
      return res.status(400).json({ message: "New password must be at least 8 characters long" });
    }
    
    try {
      // First verify the current password
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      const isPasswordCorrect = await comparePasswords(currentPassword, user.password);
      if (!isPasswordCorrect) {
        return res.status(401).json({ message: "Current password is incorrect" });
      }
      
      // Hash the new password
      const hashedPassword = await hashPassword(newPassword);
      
      // Update the password
      const updatedUser = await storage.updateUser(req.user.id, { 
        password: hashedPassword
      });
      
      if (!updatedUser) {
        return res.status(500).json({ message: "Failed to update password" });
      }
      
      res.json({ success: true, message: "Password updated successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "An error occurred while changing your password" });
    }
  });

  // Admin routes
  app.get("/api/admin/users", hasRole(["admin"]), async (req, res) => {
    const users = await Promise.all(
      Array.from(Array(100).keys()) // Limit to first 100 users
        .map(id => storage.getUser(id + 1))
    );
    
    const validUsers = users.filter((user): user is NonNullable<typeof user> => 
      user !== undefined
    ).map(user => {
      const { password, ...userWithoutPassword } = user;
      return userWithoutPassword;
    });
    
    res.json(validUsers);
  });

  app.patch("/api/admin/users/:userId/role", hasRole(["admin"]), async (req, res) => {
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    const { role } = req.body;
    if (!role || !["regular", "leader", "admin"].includes(role)) {
      return res.status(400).json({ message: "Invalid role" });
    }
    
    const updatedUser = await storage.updateUserRole(userId, role);
    if (!updatedUser) {
      return res.status(404).json({ message: "User not found" });
    }
    
    const { password, ...userWithoutPassword } = updatedUser;
    res.json(userWithoutPassword);
  });

  // Organization routes
  app.post("/api/organizations", isAuthenticated, async (req, res, next) => {
    try {
      assertUser(req);
      
      const parsedData = insertOrganizationSchema.parse({
        ...req.body,
        createdBy: req.user.id
      });
      
      const organization = await storage.createOrganization(parsedData);
      res.status(201).json(organization);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/organizations", isAuthenticated, async (req, res) => {
    assertUser(req);
    const organizations = await storage.getUserOrganizations(req.user.id);
    res.json(organizations);
  });
  
  // Keep the original route for backward compatibility
  app.get("/api/organizations/user", isAuthenticated, async (req, res) => {
    assertUser(req);
    const organizations = await storage.getUserOrganizations(req.user.id);
    res.json(organizations);
  });

  app.get("/api/organizations/:organizationId", isOrganizationMember, async (req, res) => {
    const organizationId = parseInt(req.params.organizationId);
    const organization = await storage.getOrganization(organizationId);
    
    if (!organization) {
      return res.status(404).json({ message: "Organization not found" });
    }
    
    res.json(organization);
  });

  app.patch("/api/organizations/:organizationId", isOrganizationAdmin, async (req, res, next) => {
    try {
      const organizationId = parseInt(req.params.organizationId);
      const updates = insertOrganizationSchema.partial().parse(req.body);
      
      const updatedOrganization = await storage.updateOrganization(organizationId, updates);
      if (!updatedOrganization) {
        return res.status(404).json({ message: "Organization not found" });
      }
      
      res.json(updatedOrganization);
    } catch (error) {
      next(error);
    }
  });
  
  // Keep PUT for backward compatibility
  app.put("/api/organizations/:organizationId", isOrganizationAdmin, async (req, res, next) => {
    try {
      const organizationId = parseInt(req.params.organizationId);
      const updates = insertOrganizationSchema.partial().parse(req.body);
      
      const updatedOrganization = await storage.updateOrganization(organizationId, updates);
      if (!updatedOrganization) {
        return res.status(404).json({ message: "Organization not found" });
      }
      
      res.json(updatedOrganization);
    } catch (error) {
      next(error);
    }
  });

  app.delete("/api/organizations/:organizationId", isOrganizationAdmin, async (req, res) => {
    const organizationId = parseInt(req.params.organizationId);
    
    const success = await storage.deleteOrganization(organizationId);
    if (!success) {
      return res.status(404).json({ message: "Organization not found" });
    }
    
    res.status(204).send();
  });

  // Organization Members
  app.get("/api/organizations/members", isAuthenticated, async (req, res) => {
    assertUser(req);
    const currentOrgId = parseInt(req.query.organizationId as string);
    
    if (!currentOrgId || isNaN(currentOrgId)) {
      return res.status(400).json({ message: "Invalid organization ID" });
    }
    
    // Check if user is a member of this organization
    const membership = await storage.getOrganizationMember(currentOrgId, req.user.id);
    if (!membership) {
      return res.status(403).json({ message: "You are not a member of this organization" });
    }
    
    const members = await storage.getOrganizationMembers(currentOrgId);
    
    // Fetch user details for each member
    const memberDetails = await Promise.all(
      members.map(async (member) => {
        const user = await storage.getUser(member.userId);
        if (!user) return null;
        
        const { password, ...userWithoutPassword } = user;
        return {
          ...member,
          user: userWithoutPassword
        };
      })
    );
    
    res.json(memberDetails.filter(m => m !== null));
  });
  
  app.get("/api/organizations/:organizationId/members", isOrganizationMember, async (req, res) => {
    const organizationId = parseInt(req.params.organizationId);
    const members = await storage.getOrganizationMembers(organizationId);
    
    // Fetch user details for each member
    const memberDetails = await Promise.all(
      members.map(async (member) => {
        const user = await storage.getUser(member.userId);
        if (!user) return null;
        
        const { password, ...userWithoutPassword } = user;
        return {
          ...member,
          user: userWithoutPassword
        };
      })
    );
    
    res.json(memberDetails.filter(m => m !== null));
  });

  app.post("/api/organizations/:organizationId/members", isOrganizationAdmin, async (req, res, next) => {
    try {
      const organizationId = parseInt(req.params.organizationId);
      const { userId, role } = req.body;
      
      // Check if user exists
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Check if already a member
      const existingMember = await storage.getOrganizationMember(organizationId, userId);
      if (existingMember) {
        return res.status(400).json({ message: "User is already a member of this organization" });
      }
      
      const memberData = insertOrganizationMemberSchema.parse({
        organizationId,
        userId,
        role: role || "member"
      });
      
      const member = await storage.addOrganizationMember(memberData);
      
      // Create notification for added user
      const organization = await storage.getOrganization(organizationId);
      if (organization) {
        await storage.createNotification({
          userId,
          type: "added_to_organization",
          message: `You were added to the organization "${organization.name}"`,
          referenceId: organizationId
        });
      }
      
      res.status(201).json(member);
    } catch (error) {
      next(error);
    }
  });
  
  // Invite a user to an organization by email
  app.post("/api/organizations/:organizationId/invite", isOrganizationAdmin, async (req, res, next) => {
    try {
      assertUser(req);
      const organizationId = parseInt(req.params.organizationId);
      const { email, role = "member" } = req.body;
      
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }
      
      // Check if user with email exists
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(404).json({ message: "User with this email not found" });
      }
      
      // Check if already a member
      const existingMember = await storage.getOrganizationMember(organizationId, user.id);
      if (existingMember) {
        return res.status(400).json({ message: "User is already a member of this organization" });
      }
      
      const memberData = insertOrganizationMemberSchema.parse({
        organizationId,
        userId: user.id,
        role: role
      });
      
      const member = await storage.addOrganizationMember(memberData);
      
      // Create notification for invited user
      const organization = await storage.getOrganization(organizationId);
      if (organization) {
        await storage.createNotification({
          userId: user.id,
          type: "invited_to_organization",
          message: `You were invited to join the organization "${organization.name}"`,
          referenceId: organizationId
        });
      }
      
      res.status(201).json(member);
    } catch (error) {
      next(error);
    }
  });

  app.put("/api/organizations/:organizationId/members/:userId", isOrganizationAdmin, async (req, res) => {
    const organizationId = parseInt(req.params.organizationId);
    const userId = parseInt(req.params.userId);
    const { role } = req.body;
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    // Prevent removing the last admin
    if (role !== "admin") {
      const members = await storage.getOrganizationMembers(organizationId);
      const admins = members.filter(m => m.role === "admin");
      
      const targetMember = members.find(m => m.userId === userId);
      if (targetMember?.role === "admin" && admins.length <= 1) {
        return res.status(400).json({ 
          message: "Cannot demote the last admin. Promote another member first."
        });
      }
    }
    
    const updatedMember = await storage.updateOrganizationMember(organizationId, userId, role);
    if (!updatedMember) {
      return res.status(404).json({ message: "Organization member not found" });
    }
    
    res.json(updatedMember);
  });

  app.delete("/api/organizations/:organizationId/members/:userId", isOrganizationAdmin, async (req, res) => {
    const organizationId = parseInt(req.params.organizationId);
    const userId = parseInt(req.params.userId);
    assertUser(req);
    
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }
    
    // Prevent removing the last admin
    const members = await storage.getOrganizationMembers(organizationId);
    const admins = members.filter(m => m.role === "admin");
    
    const targetMember = members.find(m => m.userId === userId);
    if (targetMember?.role === "admin" && admins.length <= 1) {
      return res.status(400).json({ 
        message: "Cannot remove the last admin. Promote another member first."
      });
    }
    
    // Prevent removing self if last admin
    if (userId === req.user.id && targetMember?.role === "admin" && admins.length <= 1) {
      return res.status(400).json({ 
        message: "You are the last admin. Promote another member first."
      });
    }
    
    const success = await storage.removeOrganizationMember(organizationId, userId);
    if (!success) {
      return res.status(404).json({ message: "Organization member not found" });
    }
    
    res.status(204).send();
  });

  // Organization Groups
  app.get("/api/organizations/groups", isAuthenticated, async (req, res) => {
    assertUser(req);
    const currentOrgId = parseInt(req.query.organizationId as string);
    
    if (!currentOrgId || isNaN(currentOrgId)) {
      return res.status(400).json({ message: "Invalid organization ID" });
    }
    
    // Check if user is a member of this organization
    const membership = await storage.getOrganizationMember(currentOrgId, req.user.id);
    if (!membership) {
      return res.status(403).json({ message: "You are not a member of this organization" });
    }
    
    const groups = await storage.getGroupsByOrganization(currentOrgId);
    res.json(groups);
  });
  
  app.get("/api/organizations/:organizationId/groups", isOrganizationMember, async (req, res) => {
    const organizationId = parseInt(req.params.organizationId);
    const groups = await storage.getGroupsByOrganization(organizationId);
    res.json(groups);
  });

  // Self-leave an organization
  app.post("/api/organizations/:organizationId/leave", isAuthenticated, async (req, res) => {
    assertUser(req);
    const organizationId = parseInt(req.params.organizationId);
    
    // Check if user is a member
    const membership = await storage.getOrganizationMember(organizationId, req.user.id);
    if (!membership) {
      return res.status(400).json({ message: "You are not a member of this organization" });
    }
    
    // Check if trying to leave as the last admin
    if (membership.role === "admin") {
      const members = await storage.getOrganizationMembers(organizationId);
      const admins = members.filter(m => m.role === "admin");
      
      if (admins.length <= 1) {
        return res.status(400).json({ 
          message: "You are the last admin. Promote another member first."
        });
      }
    }
    
    const success = await storage.removeOrganizationMember(organizationId, req.user.id);
    if (!success) {
      return res.status(500).json({ message: "Failed to leave organization" });
    }
    
    res.status(204).send();
  });

  // Push notification routes
  // Web Push Notification endpoints
  app.get("/api/push/vapid-public-key", getVapidPublicKey);
  app.post("/api/push/subscribe", isAuthenticated, subscribeUser);
  app.post("/api/push/unsubscribe", isAuthenticated, unsubscribeUser);
  
  // Expo Push Notification endpoints
  app.post("/api/push/register-token", isAuthenticated, registerPushToken);
  app.post("/api/push/unregister-token", isAuthenticated, unregisterPushToken);
  
  // Prayer Reminder Routes
  app.get("/api/prayer-reminders", isAuthenticated, async (req, res) => {
    if (!req.user) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    try {
      const reminders = await db
        .select()
        .from(prayerReminders)
        .where(eq(prayerReminders.userId, req.user.id));
      
      res.json(reminders);
    } catch (error) {
      console.error("Error getting prayer reminders:", error);
      res.status(500).json({ message: "Failed to get prayer reminders" });
    }
  });
  
  app.post("/api/prayer-reminders", isAuthenticated, async (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    try {
      const reminderData = insertPrayerReminderSchema.parse({
        ...req.body,
        userId: req.user.id
      });
      
      // Handle recurring days as JSON
      if (reminderData.recurringDays && !reminderData.isRecurring) {
        reminderData.isRecurring = true;
      }
      
      if (reminderData.isRecurring && Array.isArray(reminderData.recurringDays)) {
        reminderData.recurringDays = JSON.stringify(reminderData.recurringDays);
      }
      
      const [reminder] = await db
        .insert(prayerReminders)
        .values(reminderData)
        .returning();
      
      // Schedule the notification
      schedulePrayerReminderNotification(req.user.id, reminder);
      
      res.status(201).json(reminder);
    } catch (error) {
      next(error);
    }
  });
  
  app.put("/api/prayer-reminders/:id", isAuthenticated, async (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const reminderId = parseInt(req.params.id);
    if (isNaN(reminderId)) {
      return res.status(400).json({ message: "Invalid reminder ID" });
    }
    
    try {
      // Check if the reminder exists and belongs to the user
      const [existingReminder] = await db
        .select()
        .from(prayerReminders)
        .where(and(
          eq(prayerReminders.id, reminderId),
          eq(prayerReminders.userId, req.user.id)
        ));
      
      if (!existingReminder) {
        return res.status(404).json({ message: "Prayer reminder not found" });
      }
      
      const updates = insertPrayerReminderSchema.partial().parse(req.body);
      
      // Handle recurring days as JSON
      if (updates.recurringDays && !updates.isRecurring) {
        updates.isRecurring = true;
      }
      
      if (updates.isRecurring && Array.isArray(updates.recurringDays)) {
        updates.recurringDays = JSON.stringify(updates.recurringDays);
      }
      
      // We don't need to explicitly set updatedAt as it's handled by the database
      
      const [updatedReminder] = await db
        .update(prayerReminders)
        .set(updates)
        .where(eq(prayerReminders.id, reminderId))
        .returning();
      
      // Reschedule the notification with updated settings
      schedulePrayerReminderNotification(req.user.id, updatedReminder);
      
      res.json(updatedReminder);
    } catch (error) {
      next(error);
    }
  });
  
  app.delete("/api/prayer-reminders/:id", isAuthenticated, async (req, res) => {
    if (!req.user) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    const reminderId = parseInt(req.params.id);
    if (isNaN(reminderId)) {
      return res.status(400).json({ message: "Invalid reminder ID" });
    }
    
    try {
      // Check if the reminder exists and belongs to the user
      const [existingReminder] = await db
        .select()
        .from(prayerReminders)
        .where(and(
          eq(prayerReminders.id, reminderId),
          eq(prayerReminders.userId, req.user.id)
        ));
      
      if (!existingReminder) {
        return res.status(404).json({ message: "Prayer reminder not found" });
      }
      
      await db
        .delete(prayerReminders)
        .where(eq(prayerReminders.id, reminderId));
      
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting prayer reminder:", error);
      res.status(500).json({ message: "Failed to delete prayer reminder" });
    }
  });

  // Password reset routes
  app.post("/api/forgot-password", async (req, res, next) => {
    try {
      const { email } = forgotPasswordSchema.parse(req.body);
      
      // Find user by email
      const user = await storage.getUserByEmail(email);
      let resetToken = null;
      
      if (user) {
        // Create password reset token
        resetToken = await storage.createPasswordResetToken(user.id);
        console.log(`Password reset token for ${user.email}: ${resetToken.token}`);
      }
      
      // In a real-world application, send an email with the reset link
      // For now, we'll just return the token in the response for testing
      // This would normally be sent via email with a link like:
      // https://yourapp.com/reset-password?token=resetToken.token
      
      // Return success regardless if user found or not for security reasons
      // During development, include the token in the response for testing
      res.status(200).json({ 
        message: "If your email is registered, you will receive a password reset link shortly",
        // Remove this in production! This is just for testing
        debug: {
          email,
          userFound: !!user,
          token: resetToken ? resetToken.token : null
        }
      });
      
    } catch (error) {
      next(error);
    }
  });
  
  app.post("/api/reset-password", async (req, res, next) => {
    try {
      const { token, password } = resetPasswordSchema.parse(req.body);
      
      // Find valid token
      const resetToken = await storage.getPasswordResetToken(token);
      if (!resetToken) {
        return res.status(400).json({ 
          message: "Invalid or expired reset token" 
        });
      }
      
      // Hash the new password
      const hashedPassword = await hashPassword(password);
      
      // Update user password
      await storage.updateUser(resetToken.userId, { password: hashedPassword });
      
      // Mark token as used
      await storage.markPasswordResetTokenUsed(resetToken.id);
      
      res.status(200).json({ 
        message: "Password has been reset successfully" 
      });
      
    } catch (error) {
      next(error);
    }
  });

  // Notification Preferences routes
  app.get("/api/notification-preferences", isAuthenticated, async (req, res, next) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      
      const preferences = await storage.getUserNotificationPreferences(req.user.id);
      
      if (!preferences) {
        // Create default preferences if none exist
        const newPreferences = await storage.createNotificationPreferences({
          userId: req.user.id,
          emailNotifications: true,
          pushNotifications: true,
          inAppNotifications: true,
          prayerRequests: true,
          groupInvitations: true,
          comments: true,
          statusUpdates: true,
          groupUpdates: true,
          stalePrayerReminders: true,
          reminderInterval: 7
        });
        return res.status(200).json(newPreferences);
      }
      
      res.status(200).json(preferences);
    } catch (error) {
      next(error);
    }
  });

  app.patch("/api/notification-preferences", isAuthenticated, async (req, res, next) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      
      // Get existing preferences
      let preferences = await storage.getUserNotificationPreferences(req.user.id);
      
      if (!preferences) {
        // Create default preferences if none exist
        preferences = await storage.createNotificationPreferences({
          userId: req.user.id,
          ...req.body // Apply the requested changes
        });
        return res.status(200).json(preferences);
      }
      
      // Update existing preferences
      const updatedPreferences = await storage.updateNotificationPreferences(
        req.user.id,
        req.body
      );
      
      res.status(200).json(updatedPreferences);
    } catch (error) {
      next(error);
    }
  });

  // Group Notification Preferences routes
  app.get("/api/groups/:groupId/notification-preferences", isAuthenticated, async (req, res, next) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      
      const { groupId } = req.params;
      const groupIdNum = parseInt(groupId, 10);
      
      if (isNaN(groupIdNum)) {
        return res.status(400).json({ message: "Invalid group ID" });
      }
      
      // Check if the user is a member of the group
      const membership = await storage.getGroupMember(groupIdNum, req.user.id);
      if (!membership) {
        return res.status(403).json({ message: "You are not a member of this group" });
      }
      
      const preferences = await storage.getGroupNotificationPreferences(req.user.id, groupIdNum);
      
      if (!preferences) {
        // Create default preferences if none exist
        const newPreferences = await storage.createGroupNotificationPreferences({
          userId: req.user.id,
          groupId: groupIdNum,
          muted: false,
          newPrayerRequests: true,
          prayerStatusUpdates: true,
          newComments: true,
          groupUpdates: true,
          meetingReminders: true
        });
        return res.status(200).json(newPreferences);
      }
      
      res.status(200).json(preferences);
    } catch (error) {
      next(error);
    }
  });

  app.patch("/api/groups/:groupId/notification-preferences", isAuthenticated, async (req, res, next) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      
      const { groupId } = req.params;
      const groupIdNum = parseInt(groupId, 10);
      
      if (isNaN(groupIdNum)) {
        return res.status(400).json({ message: "Invalid group ID" });
      }
      
      // Check if the user is a member of the group
      const membership = await storage.getGroupMember(groupIdNum, req.user.id);
      if (!membership) {
        return res.status(403).json({ message: "You are not a member of this group" });
      }
      
      // Get existing preferences
      let preferences = await storage.getGroupNotificationPreferences(req.user.id, groupIdNum);
      
      if (!preferences) {
        // Create default preferences if none exist
        preferences = await storage.createGroupNotificationPreferences({
          userId: req.user.id,
          groupId: groupIdNum,
          ...req.body // Apply the requested changes
        });
        return res.status(200).json(preferences);
      }
      
      // Update existing preferences
      const updatedPreferences = await storage.updateGroupNotificationPreferences(
        req.user.id,
        groupIdNum,
        req.body
      );
      
      res.status(200).json(updatedPreferences);
    } catch (error) {
      next(error);
    }
  });

  // Meeting routes
  // Get all meetings for a group
  app.get("/api/groups/:groupId/meetings", isGroupMember, async (req, res) => {
    const groupId = parseInt(req.params.groupId);
    if (isNaN(groupId)) {
      return res.status(400).json({ message: "Invalid group ID" });
    }
    
    const meetings = await storage.getGroupMeetings(groupId);
    
    // Enrich meetings with creator info
    const enrichedMeetings = await Promise.all(
      meetings.map(async (meeting) => {
        const creator = await storage.getUser(meeting.createdBy);
        
        return {
          ...meeting,
          creator: creator ? {
            id: creator.id,
            name: creator.name,
            username: creator.username
          } : null
        };
      })
    );
    
    res.json(enrichedMeetings);
  });
  
  // Get upcoming meetings for the authenticated user
  app.get("/api/meetings/upcoming", isAuthenticated, async (req, res) => {
    assertUser(req);
    const meetings = await storage.getUpcomingMeetings(req.user.id);
    
    // Enrich meetings with creator and group info
    const enrichedMeetings = await Promise.all(
      meetings.map(async (meeting) => {
        const creator = await storage.getUser(meeting.createdBy);
        const group = await storage.getGroup(meeting.groupId);
        
        return {
          ...meeting,
          creator: creator ? {
            id: creator.id,
            name: creator.name,
            username: creator.username
          } : null,
          group: group ? {
            id: group.id,
            name: group.name
          } : null
        };
      })
    );
    
    res.json(enrichedMeetings);
  });
  
  // Get a specific meeting
  app.get("/api/meetings/:meetingId", isAuthenticated, async (req, res) => {
    const meetingId = parseInt(req.params.meetingId);
    if (isNaN(meetingId)) {
      return res.status(400).json({ message: "Invalid meeting ID" });
    }
    
    const meeting = await storage.getMeeting(meetingId);
    if (!meeting) {
      return res.status(404).json({ message: "Meeting not found" });
    }
    
    // Check if user is a member of the group this meeting belongs to
    assertUser(req);
    const membership = await storage.getGroupMember(meeting.groupId, req.user.id);
    if (!membership && req.user.role !== "admin") {
      return res.status(403).json({ message: "You don't have access to this meeting" });
    }
    
    // Enrich meeting with creator info and group details
    const creator = await storage.getUser(meeting.createdBy);
    const group = await storage.getGroup(meeting.groupId);
    
    const enrichedMeeting = {
      ...meeting,
      creator: creator ? {
        id: creator.id,
        name: creator.name,
        username: creator.username
      } : null,
      group: group ? {
        id: group.id,
        name: group.name
      } : null
    };
    
    res.json(enrichedMeeting);
  });
  
  // Create a new meeting for a group
  app.post("/api/groups/:groupId/meetings", isGroupLeader, async (req, res, next) => {
    try {
      const groupId = parseInt(req.params.groupId);
      if (isNaN(groupId)) {
        return res.status(400).json({ message: "Invalid group ID" });
      }
      
      assertUser(req);
      
      // Process date fields - convert strings to Date objects
      const requestBody = {
        ...req.body,
        groupId,
        createdBy: req.user.id,
        // Make sure timestamps are converted to Date objects
        startTime: req.body.startTime ? new Date(req.body.startTime) : undefined,
        endTime: req.body.endTime ? new Date(req.body.endTime) : null,
        recurringUntil: req.body.recurringUntil ? new Date(req.body.recurringUntil) : null
      };
      
      const meetingData = insertMeetingSchema.parse(requestBody);
      
      const meeting = await storage.createMeeting(meetingData);
      
      // Send notifications to all group members
      const group = await storage.getGroup(groupId);
      const members = await storage.getGroupMembers(groupId);
      
      if (group) {
        for (const member of members) {
          // Don't notify the creator
          if (member.userId !== req.user.id) {
            await storage.createNotification({
              userId: member.userId,
              type: "new_meeting",
              message: `New meeting scheduled for ${group.name}: ${meeting.title}`,
              referenceId: meeting.id
            });
          }
        }
      }
      
      res.status(201).json(meeting);
    } catch (error) {
      next(error);
    }
  });
  
  // Update a meeting
  app.put("/api/meetings/:meetingId", isMeetingOwner, async (req, res, next) => {
    try {
      const meetingId = parseInt(req.params.meetingId);
      
      // Process date fields for the update
      const requestBody = {
        ...req.body,
        // Make sure timestamps are converted to Date objects
        startTime: req.body.startTime ? new Date(req.body.startTime) : undefined,
        endTime: req.body.endTime ? new Date(req.body.endTime) : null,
        recurringUntil: req.body.recurringUntil ? new Date(req.body.recurringUntil) : null
      };
      
      const updates = insertMeetingSchema.partial().parse(requestBody);
      
      const meeting = (req as any).meeting; // Added by middleware
      if (!meeting) {
        return res.status(404).json({ message: "Meeting not found" });
      }
      
      const updatedMeeting = await storage.updateMeeting(meetingId, updates);
      
      // Send update notifications to all group members
      const group = await storage.getGroup(meeting.groupId);
      const members = await storage.getGroupMembers(meeting.groupId);
      
      if (group) {
        for (const member of members) {
          assertUser(req);
          // Don't notify the updater
          if (member.userId !== req.user.id) {
            await storage.createNotification({
              userId: member.userId,
              type: "meeting_updated",
              message: `Meeting updated for ${group.name}: ${meeting.title}`,
              referenceId: meeting.id
            });
          }
        }
      }
      
      res.json(updatedMeeting);
    } catch (error) {
      next(error);
    }
  });
  
  // Delete a meeting
  app.delete("/api/meetings/:meetingId", isMeetingOwner, async (req, res) => {
    const meetingId = parseInt(req.params.meetingId);
    
    const meeting = (req as any).meeting; // Added by middleware
    if (!meeting) {
      return res.status(404).json({ message: "Meeting not found" });
    }
    
    const success = await storage.deleteMeeting(meetingId);
    if (!success) {
      return res.status(500).json({ message: "Failed to delete meeting" });
    }
    
    // Notify group members about cancellation
    const group = await storage.getGroup(meeting.groupId);
    const members = await storage.getGroupMembers(meeting.groupId);
    
    if (group) {
      for (const member of members) {
        assertUser(req);
        // Don't notify the deleter
        if (member.userId !== req.user.id) {
          await storage.createNotification({
            userId: member.userId,
            type: "meeting_cancelled",
            message: `Meeting cancelled for ${group.name}: ${meeting.title}`,
            referenceId: meeting.id
          });
        }
      }
    }
    
    res.status(204).send();
  });
  
  // Meeting Notes routes
  // Get notes for a meeting
  app.get("/api/meetings/:meetingId/notes", isAuthenticated, async (req, res) => {
    const meetingId = parseInt(req.params.meetingId);
    if (isNaN(meetingId)) {
      return res.status(400).json({ message: "Invalid meeting ID" });
    }
    
    const meeting = await storage.getMeeting(meetingId);
    if (!meeting) {
      return res.status(404).json({ message: "Meeting not found" });
    }
    
    // Check if user is a member of the group this meeting belongs to
    assertUser(req);
    const membership = await storage.getGroupMember(meeting.groupId, req.user.id);
    if (!membership && req.user.role !== "admin") {
      return res.status(403).json({ message: "You don't have access to this meeting's notes" });
    }
    
    const notes = await storage.getMeetingNotes(meetingId);
    res.json(notes);
  });
  
  // Add notes to a meeting
  app.post("/api/meetings/:meetingId/notes", isGroupMember, async (req, res, next) => {
    try {
      const meetingId = parseInt(req.params.meetingId);
      if (isNaN(meetingId)) {
        return res.status(400).json({ message: "Invalid meeting ID" });
      }
      
      const meeting = await storage.getMeeting(meetingId);
      if (!meeting) {
        return res.status(404).json({ message: "Meeting not found" });
      }
      
      // Check if user is a member of the group this meeting belongs to
      assertUser(req);
      const membership = await storage.getGroupMember(meeting.groupId, req.user.id);
      if (!membership && req.user.role !== "admin") {
        return res.status(403).json({ message: "You don't have permission to add notes to this meeting" });
      }
      
      const notesData = insertMeetingNotesSchema.parse({
        ...req.body,
        meetingId
      });
      
      const notes = await storage.createMeetingNotes(notesData);
      res.status(201).json(notes);
    } catch (error) {
      next(error);
    }
  });
  
  // Update meeting notes
  app.put("/api/meetings/:meetingId/notes/:noteId", isGroupMember, async (req, res, next) => {
    try {
      const meetingId = parseInt(req.params.meetingId);
      const noteId = parseInt(req.params.noteId);
      
      if (isNaN(meetingId) || isNaN(noteId)) {
        return res.status(400).json({ message: "Invalid meeting ID or note ID" });
      }
      
      const meeting = await storage.getMeeting(meetingId);
      if (!meeting) {
        return res.status(404).json({ message: "Meeting not found" });
      }
      
      // Check if user is a member of the group this meeting belongs to
      assertUser(req);
      const membership = await storage.getGroupMember(meeting.groupId, req.user.id);
      if (!membership && req.user.role !== "admin") {
        return res.status(403).json({ message: "You don't have permission to update notes for this meeting" });
      }
      
      const updates = insertMeetingNotesSchema.partial().parse(req.body);
      const updatedNotes = await storage.updateMeetingNotes(noteId, updates);
      
      if (!updatedNotes) {
        return res.status(404).json({ message: "Meeting notes not found" });
      }
      
      res.json(updatedNotes);
    } catch (error) {
      next(error);
    }
  });
  
  // Delete meeting notes
  app.delete("/api/meetings/:meetingId/notes/:noteId", isGroupLeader, async (req, res) => {
    const meetingId = parseInt(req.params.meetingId);
    const noteId = parseInt(req.params.noteId);
    
    if (isNaN(meetingId) || isNaN(noteId)) {
      return res.status(400).json({ message: "Invalid meeting ID or note ID" });
    }
    
    const meeting = await storage.getMeeting(meetingId);
    if (!meeting) {
      return res.status(404).json({ message: "Meeting not found" });
    }
    
    // Check if user is a leader of the group this meeting belongs to (already checked by middleware)
    const success = await storage.deleteMeetingNotes(noteId);
    if (!success) {
      return res.status(404).json({ message: "Meeting notes not found" });
    }
    
    res.status(204).send();
  });
  
  // Create prayer requests from meeting notes
  app.post("/api/meetings/:meetingId/create-requests", isGroupLeader, async (req, res) => {
    const meetingId = parseInt(req.params.meetingId);
    
    if (isNaN(meetingId)) {
      return res.status(400).json({ message: "Invalid meeting ID" });
    }
    
    const meeting = await storage.getMeeting(meetingId);
    if (!meeting) {
      return res.status(404).json({ message: "Meeting not found" });
    }
    
    // Create prayer requests from notes
    assertUser(req);
    const prayerRequests = await storage.createPrayerRequestsFromNotes(
      meetingId,
      meeting.groupId,
      req.user.id
    );
    
    if (prayerRequests.length === 0) {
      return res.status(400).json({ message: "No prayer requests could be created from meeting notes" });
    }
    
    res.status(201).json({ 
      message: `Created ${prayerRequests.length} prayer requests from meeting notes`,
      prayerRequests
    });
  });

  // Check for stale prayer requests (admin only)
  app.post("/api/admin/check-stale-requests", hasRole(["admin"]), async (req, res) => {
    try {
      const updatedCount = await storage.checkAndUpdateStalePrayerRequests();
      res.json({ 
        success: true, 
        message: `Checked prayer requests and marked ${updatedCount} as stale.` 
      });
    } catch (error) {
      console.error("Error checking stale prayer requests:", error);
      res.status(500).json({ 
        success: false, 
        message: "An error occurred while checking stale prayer requests."
      });
    }
  });

  const httpServer = createServer(app);
  
  // Schedule a daily check for stale prayer requests
  setInterval(async () => {
    try {
      const count = await storage.checkAndUpdateStalePrayerRequests();
      if (count > 0) {
        console.log(`[${new Date().toISOString()}] Marked ${count} prayer requests as stale`);
      }
    } catch (error) {
      console.error("Error in scheduled stale request check:", error);
    }
  }, 1000 * 60 * 60 * 24); // Run once every 24 hours
  
  return httpServer;
}
```

## File: server/storage.ts
```typescript
import { 
  users, type User, type InsertUser,
  organizations, type Organization, type InsertOrganization,
  organizationMembers, type OrganizationMember, type InsertOrganizationMember,
  organizationTags, type OrganizationTag, type InsertOrganizationTag,
  groupTags, type GroupTag, type InsertGroupTag,
  groups, type Group, type InsertGroup,
  groupMembers, type GroupMember, type InsertGroupMember,
  prayerRequests, type PrayerRequest, type InsertPrayerRequest,
  comments, type Comment, type InsertComment,
  notifications, type Notification, type InsertNotification,
  prayingFor, type PrayingFor, type InsertPrayingFor,
  passwordResetTokens, type PasswordResetToken, type InsertPasswordResetToken,
  notificationPreferences, type NotificationPreference, type InsertNotificationPreference,
  groupNotificationPreferences, type GroupNotificationPreference, type InsertGroupNotificationPreference,
  meetings, type Meeting, type InsertMeeting,
  meetingNotes, type MeetingNote, type InsertMeetingNote,
  favoriteGroups, type FavoriteGroup, type InsertFavoriteGroup
} from "@shared/schema";
import { eq, and, desc, sql, inArray } from "drizzle-orm";
import { db, pool } from "./db";
import session from "express-session";
import createMemoryStore from "memorystore";
import connectPg from "connect-pg-simple";
import crypto from "crypto";

const MemoryStore = createMemoryStore(session);
const PostgresSessionStore = connectPg(session);

export interface IStorage {
  // Users
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUsers(): Promise<User[]>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, userData: Partial<User>): Promise<User | undefined>;
  updateUserRole(id: number, role: string): Promise<User | undefined>;
  
  // Organizations
  createOrganization(organization: InsertOrganization): Promise<Organization>;
  getOrganization(id: number): Promise<Organization | undefined>;
  getUserOrganizations(userId: number): Promise<Organization[]>;
  updateOrganization(id: number, organization: Partial<InsertOrganization>): Promise<Organization | undefined>;
  deleteOrganization(id: number): Promise<boolean>;
  
  // Organization Members
  addOrganizationMember(member: InsertOrganizationMember): Promise<OrganizationMember>;
  getOrganizationMembers(organizationId: number): Promise<OrganizationMember[]>;
  getOrganizationMember(organizationId: number, userId: number): Promise<OrganizationMember | undefined>;
  updateOrganizationMember(organizationId: number, userId: number, role: string): Promise<OrganizationMember | undefined>;
  removeOrganizationMember(organizationId: number, userId: number): Promise<boolean>;
  
  // Organization Tags
  createOrganizationTag(tag: InsertOrganizationTag): Promise<OrganizationTag>;
  getOrganizationTags(organizationId: number): Promise<OrganizationTag[]>;
  getOrganizationTag(id: number): Promise<OrganizationTag | undefined>;
  updateOrganizationTag(id: number, tagData: Partial<InsertOrganizationTag>): Promise<OrganizationTag | undefined>;
  deleteOrganizationTag(id: number): Promise<boolean>;
  
  // Group Tags
  addGroupTag(groupTag: InsertGroupTag): Promise<GroupTag>;
  getGroupTags(groupId: number): Promise<GroupTag[]>;
  getGroupTagsWithDetails(groupId: number): Promise<OrganizationTag[]>;
  removeGroupTag(groupId: number, tagId: number): Promise<boolean>;
  
  // Groups
  createGroup(group: InsertGroup): Promise<Group>;
  getGroup(id: number): Promise<Group | undefined>;
  getGroups(): Promise<Group[]>;
  getGroupsByCategory(category: string): Promise<Group[]>;
  getGroupsByOrganization(organizationId: number): Promise<Group[]>;
  getUserGroups(userId: number): Promise<Group[]>;
  updateGroup(id: number, group: Partial<InsertGroup>): Promise<Group | undefined>;
  deleteGroup(id: number): Promise<boolean>;
  
  // Group Members
  addGroupMember(member: InsertGroupMember): Promise<GroupMember>;
  getGroupMembers(groupId: number): Promise<GroupMember[]>;
  getGroupMember(groupId: number, userId: number): Promise<GroupMember | undefined>;
  updateGroupMember(groupId: number, userId: number, role: string): Promise<GroupMember | undefined>;
  removeGroupMember(groupId: number, userId: number): Promise<boolean>;
  
  // Prayer Requests
  createPrayerRequest(request: InsertPrayerRequest): Promise<PrayerRequest>;
  getPrayerRequest(id: number): Promise<PrayerRequest | undefined>;
  getGroupPrayerRequests(groupId: number): Promise<PrayerRequest[]>;
  getUserPrayerRequests(userId: number, limit?: number | null): Promise<PrayerRequest[]>;
  getRecentPrayerRequests(userId: number, limit?: number): Promise<PrayerRequest[]>;
  getRecentPrayerRequestsByGroups(groupIds: number[], limit?: number): Promise<PrayerRequest[]>;
  updatePrayerRequest(id: number, request: Partial<InsertPrayerRequest>): Promise<PrayerRequest | undefined>;
  deletePrayerRequest(id: number): Promise<boolean>;
  checkAndUpdateStalePrayerRequests(): Promise<number>;
  
  // Comments
  createComment(comment: InsertComment): Promise<Comment>;
  getComment(id: number): Promise<Comment | undefined>;
  getPrayerRequestComments(prayerRequestId: number): Promise<Comment[]>;
  deleteComment(id: number): Promise<boolean>;
  
  // Notifications
  createNotification(notification: InsertNotification): Promise<Notification>;
  getUserNotifications(userId: number, organizationId?: number): Promise<Notification[]>;
  markNotificationRead(id: number): Promise<Notification | undefined>;
  markAllNotificationsRead(userId: number, organizationId?: number): Promise<boolean>;
  deleteNotification(id: number): Promise<boolean>;
  
  // Praying For
  addPrayingFor(prayingFor: InsertPrayingFor): Promise<PrayingFor>;
  removePrayingFor(prayerRequestId: number, userId: number): Promise<boolean>;
  isPrayingFor(prayerRequestId: number, userId: number): Promise<boolean>;
  getPrayingForCount(prayerRequestId: number): Promise<number>;
  
  // Password Reset
  createPasswordResetToken(userId: number): Promise<PasswordResetToken>;
  getUserByEmail(email: string): Promise<User | undefined>;
  getPasswordResetToken(token: string): Promise<PasswordResetToken | undefined>;
  markPasswordResetTokenUsed(id: number): Promise<PasswordResetToken | undefined>;
  
  // Notification Preferences
  getUserNotificationPreferences(userId: number): Promise<NotificationPreference | undefined>;
  createNotificationPreferences(preferences: InsertNotificationPreference): Promise<NotificationPreference>;
  updateNotificationPreferences(userId: number, preferences: Partial<InsertNotificationPreference>): Promise<NotificationPreference | undefined>;
  
  // Group Notification Preferences
  getGroupNotificationPreferences(userId: number, groupId: number): Promise<GroupNotificationPreference | undefined>;
  getUserGroupNotificationPreferences(userId: number): Promise<GroupNotificationPreference[]>;
  createGroupNotificationPreferences(preferences: InsertGroupNotificationPreference): Promise<GroupNotificationPreference>;
  updateGroupNotificationPreferences(userId: number, groupId: number, preferences: Partial<InsertGroupNotificationPreference>): Promise<GroupNotificationPreference | undefined>;
  
  // Meeting operations
  createMeeting(meeting: InsertMeeting): Promise<Meeting>;
  getMeeting(id: number): Promise<Meeting | undefined>;
  getGroupMeetings(groupId: number): Promise<Meeting[]>;
  getUpcomingMeetings(userId: number): Promise<Meeting[]>;
  updateMeeting(id: number, meeting: Partial<InsertMeeting>): Promise<Meeting | undefined>;
  deleteMeeting(id: number): Promise<boolean>;
  
  // Meeting Notes operations
  createMeetingNotes(notes: InsertMeetingNote): Promise<MeetingNote>;
  getMeetingNotes(meetingId: number): Promise<MeetingNote[]>;
  updateMeetingNotes(id: number, notes: Partial<InsertMeetingNote>): Promise<MeetingNote | undefined>;
  deleteMeetingNotes(id: number): Promise<boolean>;
  createPrayerRequestsFromNotes(meetingId: number, groupId: number, userId: number): Promise<PrayerRequest[]>;
  
  // Favorite Groups
  addFavoriteGroup(userId: number, groupId: number): Promise<FavoriteGroup>;
  removeFavoriteGroup(userId: number, groupId: number): Promise<boolean>;
  getUserFavoriteGroups(userId: number): Promise<Group[]>;
  isFavoriteGroup(userId: number, groupId: number): Promise<boolean>;
  
  // Session store
  sessionStore: any;
}

export class MemStorage implements IStorage {
  private usersMap: Map<number, User>;
  private organizationsMap: Map<number, Organization>;
  private organizationMembersMap: Map<number, OrganizationMember>;
  private organizationTagsMap: Map<number, OrganizationTag>;
  private groupTagsMap: Map<number, GroupTag>;
  private groupsMap: Map<number, Group>;
  private groupMembersMap: Map<number, GroupMember>;
  private prayerRequestsMap: Map<number, PrayerRequest>;
  private commentsMap: Map<number, Comment>;
  private notificationsMap: Map<number, Notification>;
  private prayingForMap: Map<number, PrayingFor>;
  private passwordResetTokensMap: Map<number, PasswordResetToken>;
  private notificationPreferencesMap = new Map<number, NotificationPreference>();
  private groupNotificationPreferencesMap = new Map<number, GroupNotificationPreference>();
  private meetingsMap = new Map<number, Meeting>();
  private meetingNotesMap = new Map<number, MeetingNote>();
  
  private userIdCounter: number;
  private organizationIdCounter: number;
  private organizationMemberIdCounter: number;
  private organizationTagIdCounter: number;
  private groupTagIdCounter: number;
  private groupIdCounter: number;
  private groupMemberIdCounter: number;
  private prayerRequestIdCounter: number;
  private commentIdCounter: number;
  private notificationIdCounter: number;
  private prayingForIdCounter: number;
  private passwordResetTokenIdCounter: number;
  private notificationPreferencesIdCounter: number;
  private groupNotificationPreferencesIdCounter: number;
  private meetingIdCounter: number;
  private meetingNotesIdCounter: number;
  private notificationPreferenceIdCounter: number;
  private groupNotificationPreferenceIdCounter: number;
  
  sessionStore: any;

  constructor() {
    this.usersMap = new Map();
    this.organizationsMap = new Map();
    this.organizationMembersMap = new Map();
    this.organizationTagsMap = new Map();
    this.groupTagsMap = new Map();
    this.groupsMap = new Map();
    this.groupMembersMap = new Map();
    this.prayerRequestsMap = new Map();
    this.commentsMap = new Map();
    this.notificationsMap = new Map();
    this.prayingForMap = new Map();
    this.passwordResetTokensMap = new Map();
    this.notificationPreferencesMap = new Map();
    this.groupNotificationPreferencesMap = new Map();
    this.meetingsMap = new Map();
    this.meetingNotesMap = new Map();
    
    this.userIdCounter = 1;
    this.organizationIdCounter = 1;
    this.organizationMemberIdCounter = 1;
    this.organizationTagIdCounter = 1;
    this.groupTagIdCounter = 1;
    this.groupIdCounter = 1;
    this.groupMemberIdCounter = 1;
    this.prayerRequestIdCounter = 1;
    this.commentIdCounter = 1;
    this.notificationIdCounter = 1;
    this.prayingForIdCounter = 1;
    this.passwordResetTokenIdCounter = 1;
    this.notificationPreferencesIdCounter = 1;
    this.groupNotificationPreferencesIdCounter = 1;
    this.meetingIdCounter = 1;
    this.meetingNotesIdCounter = 1;
    this.notificationPreferenceIdCounter = 1;
    this.groupNotificationPreferenceIdCounter = 1;
    
    this.sessionStore = new MemoryStore({
      checkPeriod: 86400000, // 24 hours
    });
  }

  // User methods
  async getUser(id: number): Promise<User | undefined> {
    return this.usersMap.get(id);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.usersMap.values()).find(
      (user) => user.username === username,
    );
  }
  
  async getUsers(): Promise<User[]> {
    return Array.from(this.usersMap.values());
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.userIdCounter++;
    
    // Validate role is one of the allowed values
    const validRole = insertUser.role && ["regular", "leader", "admin"].includes(insertUser.role)
      ? insertUser.role as "regular" | "leader" | "admin"
      : "regular";
    
    // Ensure all required fields have values
    const user: User = { 
      id,
      username: insertUser.username,
      password: insertUser.password,
      name: insertUser.name,
      email: insertUser.email,
      role: validRole,
      phone: insertUser.phone || null,
      avatar: insertUser.avatar || null,
      bio: insertUser.bio || null
    };
    this.usersMap.set(id, user);
    return user;
  }
  
  async updateUser(id: number, userData: Partial<User>): Promise<User | undefined> {
    const user = await this.getUser(id);
    if (!user) return undefined;
    
    // If updating the role, validate it's a permitted value
    let validatedUserData = { ...userData };
    if (userData.role) {
      validatedUserData.role = ["regular", "leader", "admin"].includes(userData.role) 
        ? userData.role as "regular" | "leader" | "admin"
        : user.role;
    }
    
    const updatedUser = { ...user, ...validatedUserData };
    this.usersMap.set(id, updatedUser);
    return updatedUser;
  }
  
  async updateUserRole(id: number, role: string): Promise<User | undefined> {
    const user = await this.getUser(id);
    if (!user) return undefined;
    
    // Validate role is one of the allowed values
    const validRole = ["regular", "leader", "admin"].includes(role) 
      ? role as "regular" | "leader" | "admin"
      : "regular";
    
    const updatedUser = { ...user, role: validRole };
    this.usersMap.set(id, updatedUser);
    return updatedUser;
  }
  
  // Organization methods
  async createOrganization(insertOrg: InsertOrganization): Promise<Organization> {
    const id = this.organizationIdCounter++;
    const now = new Date();
    const organization: Organization = {
      ...insertOrg,
      id,
      createdAt: now,
      description: insertOrg.description ?? null
    };
    
    this.organizationsMap.set(id, organization);
    
    // Add creator as admin
    await this.addOrganizationMember({
      organizationId: id,
      userId: insertOrg.createdBy,
      role: "admin"
    });
    
    return organization;
  }
  
  async getOrganization(id: number): Promise<Organization | undefined> {
    return this.organizationsMap.get(id);
  }
  
  async getUserOrganizations(userId: number): Promise<Organization[]> {
    // Get organizations where user is a member
    const userMemberships = Array.from(this.organizationMembersMap.values())
      .filter(member => member.userId === userId);
    
    // Get organization details for each membership
    const organizations = userMemberships
      .map(membership => this.organizationsMap.get(membership.organizationId))
      .filter((org): org is Organization => org !== undefined);
    
    return organizations;
  }
  
  async updateOrganization(id: number, orgUpdates: Partial<InsertOrganization>): Promise<Organization | undefined> {
    const organization = await this.getOrganization(id);
    if (!organization) return undefined;
    
    const updatedOrg = { ...organization, ...orgUpdates };
    this.organizationsMap.set(id, updatedOrg);
    return updatedOrg;
  }
  
  async deleteOrganization(id: number): Promise<boolean> {
    const success = this.organizationsMap.delete(id);
    
    // Clean up related data
    if (success) {
      // Delete organization members
      const orgMembers = Array.from(this.organizationMembersMap.values())
        .filter(member => member.organizationId === id);
      
      for (const member of orgMembers) {
        this.organizationMembersMap.delete(member.id);
      }
      
      // Delete groups that belong to this organization
      const orgGroups = Array.from(this.groupsMap.values())
        .filter(group => group.organizationId === id);
      
      for (const group of orgGroups) {
        await this.deleteGroup(group.id);
      }
    }
    
    return success;
  }
  
  // Organization Member methods
  async addOrganizationMember(insertMember: InsertOrganizationMember): Promise<OrganizationMember> {
    const id = this.organizationMemberIdCounter++;
    const now = new Date();
    
    // Validate role is one of the allowed values
    const validRole = insertMember.role && ["admin", "member"].includes(insertMember.role)
      ? insertMember.role as "admin" | "member"
      : "member";
    
    const member: OrganizationMember = {
      ...insertMember,
      id,
      joinedAt: now,
      role: validRole
    };
    
    this.organizationMembersMap.set(id, member);
    return member;
  }
  
  async getOrganizationMembers(organizationId: number): Promise<OrganizationMember[]> {
    return Array.from(this.organizationMembersMap.values())
      .filter(member => member.organizationId === organizationId);
  }
  
  async getOrganizationMember(organizationId: number, userId: number): Promise<OrganizationMember | undefined> {
    return Array.from(this.organizationMembersMap.values())
      .find(member => member.organizationId === organizationId && member.userId === userId);
  }
  
  async updateOrganizationMember(organizationId: number, userId: number, role: string): Promise<OrganizationMember | undefined> {
    const member = await this.getOrganizationMember(organizationId, userId);
    if (!member) return undefined;
    
    // Validate role is one of the allowed values
    const validRole = ["admin", "member"].includes(role) 
      ? role as "admin" | "member"
      : "member";
    
    const updatedMember = { ...member, role: validRole };
    this.organizationMembersMap.set(member.id, updatedMember);
    return updatedMember;
  }
  
  async removeOrganizationMember(organizationId: number, userId: number): Promise<boolean> {
    const member = await this.getOrganizationMember(organizationId, userId);
    if (!member) return false;
    
    return this.organizationMembersMap.delete(member.id);
  }
  
  // Organization Tag methods
  async createOrganizationTag(tag: InsertOrganizationTag): Promise<OrganizationTag> {
    const id = this.organizationTagIdCounter++;
    const now = new Date();
    const organizationTag: OrganizationTag = {
      ...tag,
      id,
      createdAt: now
    };
    
    this.organizationTagsMap.set(id, organizationTag);
    return organizationTag;
  }
  
  async getOrganizationTags(organizationId: number): Promise<OrganizationTag[]> {
    return Array.from(this.organizationTagsMap.values())
      .filter(tag => tag.organizationId === organizationId);
  }
  
  async getOrganizationTag(id: number): Promise<OrganizationTag | undefined> {
    return this.organizationTagsMap.get(id);
  }
  
  async updateOrganizationTag(id: number, tagData: Partial<InsertOrganizationTag>): Promise<OrganizationTag | undefined> {
    const tag = await this.getOrganizationTag(id);
    if (!tag) return undefined;
    
    const updatedTag = { ...tag, ...tagData };
    this.organizationTagsMap.set(id, updatedTag);
    return updatedTag;
  }
  
  async deleteOrganizationTag(id: number): Promise<boolean> {
    // First delete all group associations with this tag
    const groupTags = Array.from(this.groupTagsMap.values())
      .filter(groupTag => groupTag.tagId === id);
    
    for (const groupTag of groupTags) {
      this.groupTagsMap.delete(groupTag.id);
    }
    
    // Then delete the tag itself
    return this.organizationTagsMap.delete(id);
  }
  
  // Group Tag methods
  async addGroupTag(groupTag: InsertGroupTag): Promise<GroupTag> {
    const id = this.groupTagIdCounter++;
    const newGroupTag: GroupTag = {
      ...groupTag,
      id
    };
    
    this.groupTagsMap.set(id, newGroupTag);
    return newGroupTag;
  }
  
  async getGroupTags(groupId: number): Promise<GroupTag[]> {
    return Array.from(this.groupTagsMap.values())
      .filter(groupTag => groupTag.groupId === groupId);
  }
  
  async getGroupTagsWithDetails(groupId: number): Promise<OrganizationTag[]> {
    // Get all tag IDs associated with this group
    const groupTagEntries = await this.getGroupTags(groupId);
    
    if (groupTagEntries.length === 0) {
      return [];
    }
    
    // Get the details of each tag
    const tagIds = groupTagEntries.map(entry => entry.tagId);
    return Array.from(this.organizationTagsMap.values())
      .filter(tag => tagIds.includes(tag.id));
  }
  
  async removeGroupTag(groupId: number, tagId: number): Promise<boolean> {
    const groupTag = Array.from(this.groupTagsMap.values())
      .find(gt => gt.groupId === groupId && gt.tagId === tagId);
      
    if (!groupTag) return false;
    
    return this.groupTagsMap.delete(groupTag.id);
  }
  
  // Group methods
  async createGroup(insertGroup: InsertGroup): Promise<Group> {
    const id = this.groupIdCounter++;
    const now = new Date();
    const group: Group = { 
      ...insertGroup,
      id,
      createdAt: now,
      description: insertGroup.description ?? null,
      category: insertGroup.category || "other",
      privacy: insertGroup.privacy || "open",
      leaderRotation: insertGroup.leaderRotation ?? null
    };
    
    this.groupsMap.set(id, group);
    
    // Add creator as leader
    await this.addGroupMember({
      groupId: id,
      userId: insertGroup.createdBy,
      role: "leader" 
    });
    
    return group;
  }
  
  async getGroup(id: number): Promise<Group | undefined> {
    return this.groupsMap.get(id);
  }
  
  async getGroups(): Promise<Group[]> {
    return Array.from(this.groupsMap.values());
  }
  
  async getGroupsByCategory(category: string): Promise<Group[]> {
    return Array.from(this.groupsMap.values())
      .filter(group => group.category === category);
  }
  
  async getGroupsByOrganization(organizationId: number): Promise<Group[]> {
    return Array.from(this.groupsMap.values())
      .filter(group => group.organizationId === organizationId);
  }
  
  async getUserGroups(userId: number): Promise<Group[]> {
    // Get groups where user is a member
    const userMemberships = Array.from(this.groupMembersMap.values())
      .filter(member => member.userId === userId);
    
    // Get group details for each membership
    const groups = userMemberships
      .map(membership => this.groupsMap.get(membership.groupId))
      .filter((group): group is Group => group !== undefined);
    
    return groups;
  }
  
  async updateGroup(id: number, groupUpdates: Partial<InsertGroup>): Promise<Group | undefined> {
    const group = await this.getGroup(id);
    if (!group) return undefined;
    
    const updatedGroup = { ...group, ...groupUpdates };
    this.groupsMap.set(id, updatedGroup);
    return updatedGroup;
  }
  
  async deleteGroup(id: number): Promise<boolean> {
    const success = this.groupsMap.delete(id);
    
    // Clean up related data
    if (success) {
      // Delete group members
      const groupMembers = Array.from(this.groupMembersMap.values())
        .filter(member => member.groupId === id);
      
      for (const member of groupMembers) {
        this.groupMembersMap.delete(member.id);
      }
      
      // Delete prayer requests
      const requests = Array.from(this.prayerRequestsMap.values())
        .filter(request => request.groupId === id);
      
      for (const request of requests) {
        await this.deletePrayerRequest(request.id);
      }
    }
    
    return success;
  }
  
  // Group Member methods
  async addGroupMember(insertMember: InsertGroupMember): Promise<GroupMember> {
    const id = this.groupMemberIdCounter++;
    const now = new Date();
    
    // Validate role is one of the allowed values
    const validRole = insertMember.role && ["leader", "member"].includes(insertMember.role)
      ? insertMember.role as "leader" | "member"
      : "member";
    
    const member: GroupMember = {
      ...insertMember,
      id,
      joinedAt: now,
      role: validRole
    };
    
    this.groupMembersMap.set(id, member);
    return member;
  }
  
  async getGroupMembers(groupId: number): Promise<GroupMember[]> {
    return Array.from(this.groupMembersMap.values())
      .filter(member => member.groupId === groupId);
  }
  
  async getGroupMember(groupId: number, userId: number): Promise<GroupMember | undefined> {
    return Array.from(this.groupMembersMap.values())
      .find(member => member.groupId === groupId && member.userId === userId);
  }
  
  async updateGroupMember(groupId: number, userId: number, role: string): Promise<GroupMember | undefined> {
    const member = await this.getGroupMember(groupId, userId);
    if (!member) return undefined;
    
    // Validate role is one of the allowed values
    const validRole = ["leader", "member"].includes(role) 
      ? role as "leader" | "member"
      : "member";
    
    const updatedMember = { ...member, role: validRole };
    this.groupMembersMap.set(member.id, updatedMember);
    return updatedMember;
  }
  
  async removeGroupMember(groupId: number, userId: number): Promise<boolean> {
    const member = await this.getGroupMember(groupId, userId);
    if (!member) return false;
    
    return this.groupMembersMap.delete(member.id);
  }
  
  // Prayer Request methods
  async createPrayerRequest(insertRequest: InsertPrayerRequest): Promise<PrayerRequest> {
    const id = this.prayerRequestIdCounter++;
    const now = new Date();
    const request: PrayerRequest = {
      id, 
      groupId: insertRequest.groupId,
      userId: insertRequest.userId,
      title: insertRequest.title,
      description: insertRequest.description,
      urgency: insertRequest.urgency || "medium",
      isAnonymous: insertRequest.isAnonymous || false,
      status: insertRequest.status || "waiting",
      followUpDate: insertRequest.followUpDate !== undefined ? insertRequest.followUpDate : null,
      isStale: insertRequest.isStale || false,
      createdAt: now,
      updatedAt: now
    };
    
    this.prayerRequestsMap.set(id, request);
    
    // Create notifications for group members
    const groupMembers = await this.getGroupMembers(request.groupId);
    for (const member of groupMembers) {
      // Don't notify the creator
      if (member.userId !== request.userId) {
        const group = await this.getGroup(request.groupId);
        const requester = await this.getUser(request.userId);
        if (group && requester) {
          const requesterName = request.isAnonymous ? "Anonymous" : requester.name;
          await this.createNotification({
            userId: member.userId,
            type: "new_request",
            message: `New prayer request: ${request.title} in ${group.name} by ${requesterName}`,
            referenceId: id,
          });
        }
      }
    }
    
    return request;
  }
  
  async getPrayerRequest(id: number): Promise<PrayerRequest | undefined> {
    return this.prayerRequestsMap.get(id);
  }
  
  async getGroupPrayerRequests(groupId: number): Promise<PrayerRequest[]> {
    return Array.from(this.prayerRequestsMap.values())
      .filter(request => request.groupId === groupId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }
  
  async getUserPrayerRequests(userId: number, limit?: number | null): Promise<PrayerRequest[]> {
    const requests = Array.from(this.prayerRequestsMap.values())
      .filter(request => request.userId === userId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    
    return limit ? requests.slice(0, limit) : requests;
  }
  
  async getRecentPrayerRequests(userId: number, limit = 5): Promise<PrayerRequest[]> {
    // Get groups the user is a member of
    const userGroups = await this.getUserGroups(userId);
    const groupIds = userGroups.map(group => group.id);
    
    // Get prayer requests from those groups
    const requests = Array.from(this.prayerRequestsMap.values())
      .filter(request => groupIds.includes(request.groupId))
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice(0, limit);
    
    return requests;
  }
  
  async getRecentPrayerRequestsByGroups(groupIds: number[], limit = 5): Promise<PrayerRequest[]> {
    // Get prayer requests from the specified groups
    const requests = Array.from(this.prayerRequestsMap.values())
      .filter(request => groupIds.includes(request.groupId))
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice(0, limit);
    
    return requests;
  }
  
  async updatePrayerRequest(id: number, requestUpdates: Partial<InsertPrayerRequest>): Promise<PrayerRequest | undefined> {
    const request = await this.getPrayerRequest(id);
    if (!request) return undefined;
    
    const now = new Date();
    const updatedRequest = { 
      ...request, 
      ...requestUpdates,
      updatedAt: now 
    };
    
    this.prayerRequestsMap.set(id, updatedRequest);
    
    // If status was updated, create notification
    if (requestUpdates.status && requestUpdates.status !== request.status) {
      const requester = await this.getUser(request.userId);
      const group = await this.getGroup(request.groupId);
      
      if (requester && group) {
        // Notify group members about status update
        const groupMembers = await this.getGroupMembers(request.groupId);
        for (const member of groupMembers) {
          // No need to notify the requester if they updated their own status
          if (member.userId !== request.userId) {
            let statusText = "updated to";
            if (requestUpdates.status === "answered") statusText = "marked as answered";
            if (requestUpdates.status === "declined") statusText = "marked as declined";
            
            await this.createNotification({
              userId: member.userId,
              type: "status_update",
              message: `Prayer request "${request.title}" in ${group.name} was ${statusText}`,
              referenceId: id,
            });
          }
        }
      }
    }
    
    return updatedRequest;
  }
  
  async deletePrayerRequest(id: number): Promise<boolean> {
    const success = this.prayerRequestsMap.delete(id);
    
    // Clean up related data
    if (success) {
      // Delete comments
      const comments = Array.from(this.commentsMap.values())
        .filter(comment => comment.prayerRequestId === id);
      
      for (const comment of comments) {
        this.commentsMap.delete(comment.id);
      }
      
      // Delete "praying for" records
      const prayingForRecords = Array.from(this.prayingForMap.values())
        .filter(record => record.prayerRequestId === id);
      
      for (const record of prayingForRecords) {
        this.prayingForMap.delete(record.id);
      }
      
      // Delete notifications referencing this request
      const notifications = Array.from(this.notificationsMap.values())
        .filter(notification => notification.referenceId === id);
      
      for (const notification of notifications) {
        this.notificationsMap.delete(notification.id);
      }
    }
    
    return success;
  }
  
  // Comment methods
  async createComment(insertComment: InsertComment): Promise<Comment> {
    const id = this.commentIdCounter++;
    const now = new Date();
    const comment: Comment = {
      ...insertComment,
      id,
      createdAt: now,
      isPrivate: insertComment.isPrivate || false
    };
    
    this.commentsMap.set(id, comment);
    
    // Create notification for prayer request owner
    const request = await this.getPrayerRequest(insertComment.prayerRequestId);
    if (request && request.userId !== insertComment.userId) {
      const commenter = await this.getUser(insertComment.userId);
      if (commenter) {
        await this.createNotification({
          userId: request.userId,
          type: "new_comment",
          message: `${commenter.name} commented on your prayer request "${request.title}"`,
          referenceId: insertComment.prayerRequestId,
        });
      }
    }
    
    return comment;
  }
  
  async getComment(id: number): Promise<Comment | undefined> {
    return this.commentsMap.get(id);
  }
  
  async getPrayerRequestComments(prayerRequestId: number): Promise<Comment[]> {
    return Array.from(this.commentsMap.values())
      .filter(comment => comment.prayerRequestId === prayerRequestId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }
  
  async deleteComment(id: number): Promise<boolean> {
    const success = this.commentsMap.delete(id);
    
    // Clean up notifications related to this comment
    if (success) {
      const notifications = Array.from(this.notificationsMap.values())
        .filter(notification => 
          notification.type === "new_comment" && 
          notification.referenceId === id
        );
      
      for (const notification of notifications) {
        this.notificationsMap.delete(notification.id);
      }
    }
    
    return success;
  }
  
  // Notification methods
  async createNotification(insertNotification: InsertNotification): Promise<Notification> {
    const id = this.notificationIdCounter++;
    const now = new Date();
    const notification: Notification = {
      ...insertNotification,
      id,
      read: false,
      createdAt: now,
      referenceId: insertNotification.referenceId ?? null
    };
    
    this.notificationsMap.set(id, notification);
    return notification;
  }
  
  async getUserNotifications(userId: number, organizationId?: number): Promise<Notification[]> {
    const allNotifications = Array.from(this.notificationsMap.values())
      .filter(notification => notification.userId === userId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    
    // If no organizationId is provided, return all notifications
    if (!organizationId) {
      return allNotifications;
    }

    // Otherwise, filter notifications by organization
    // We need to check if notification.referenceId points to a group, prayer request,
    // or comment that belongs to the current organization
    const filteredNotifications = [];
    
    for (const notification of allNotifications) {
      // Skip notifications with no referenceId
      if (!notification.referenceId) {
        filteredNotifications.push(notification);
        continue;
      }
      
      const refId = notification.referenceId;
      
      // Check if it's a notification about a group
      if (notification.type.includes('group')) {
        const group = await this.getGroup(refId);
        if (group && group.organizationId === organizationId) {
          filteredNotifications.push(notification);
        }
        continue;
      }
      
      // Check if it's a notification about a prayer request
      if (notification.type.includes('prayer') || notification.type.includes('request') || notification.type === 'status_update') {
        const request = await this.getPrayerRequest(refId);
        if (request) {
          const group = await this.getGroup(request.groupId);
          if (group && group.organizationId === organizationId) {
            filteredNotifications.push(notification);
          }
        }
        continue;
      }
      
      // Check if it's a notification about a comment
      if (notification.type === 'new_comment') {
        const comment = await this.getComment(refId);
        if (comment) {
          const request = await this.getPrayerRequest(comment.prayerRequestId);
          if (request) {
            const group = await this.getGroup(request.groupId);
            if (group && group.organizationId === organizationId) {
              filteredNotifications.push(notification);
            }
          }
        }
        continue;
      }
      
      // For organization-related notifications
      if (notification.type.includes('organization')) {
        if (refId === organizationId) {
          filteredNotifications.push(notification);
        }
        continue;
      }
      
      // For notifications we couldn't categorize, include them by default
      filteredNotifications.push(notification);
    }
    
    return filteredNotifications;
  }
  
  async markNotificationRead(id: number): Promise<Notification | undefined> {
    const notification = this.notificationsMap.get(id);
    if (!notification) return undefined;
    
    const updatedNotification = { ...notification, read: true };
    this.notificationsMap.set(id, updatedNotification);
    return updatedNotification;
  }
  
  async markAllNotificationsRead(userId: number, organizationId?: number): Promise<boolean> {
    const userNotifications = await this.getUserNotifications(userId, organizationId);
    
    for (const notification of userNotifications) {
      const updatedNotification = { ...notification, read: true };
      this.notificationsMap.set(notification.id, updatedNotification);
    }
    
    return true;
  }
  
  async deleteNotification(id: number): Promise<boolean> {
    return this.notificationsMap.delete(id);
  }
  
  // Praying For methods
  async addPrayingFor(insertPrayingFor: InsertPrayingFor): Promise<PrayingFor> {
    const id = this.prayingForIdCounter++;
    const now = new Date();
    const prayingFor: PrayingFor = {
      ...insertPrayingFor,
      id,
      timestamp: now,
    };
    
    this.prayingForMap.set(id, prayingFor);
    return prayingFor;
  }
  
  async removePrayingFor(prayerRequestId: number, userId: number): Promise<boolean> {
    const record = Array.from(this.prayingForMap.values())
      .find(p => p.prayerRequestId === prayerRequestId && p.userId === userId);
    
    if (!record) return false;
    
    return this.prayingForMap.delete(record.id);
  }
  
  async isPrayingFor(prayerRequestId: number, userId: number): Promise<boolean> {
    return Array.from(this.prayingForMap.values())
      .some(p => p.prayerRequestId === prayerRequestId && p.userId === userId);
  }
  
  async getPrayingForCount(prayerRequestId: number): Promise<number> {
    return Array.from(this.prayingForMap.values())
      .filter(p => p.prayerRequestId === prayerRequestId)
      .length;
  }
  
  // Password Reset methods
  async getUserByEmail(email: string): Promise<User | undefined> {
    return Array.from(this.usersMap.values()).find(
      (user) => user.email === email,
    );
  }
  
  async createPasswordResetToken(userId: number): Promise<PasswordResetToken> {
    const id = this.passwordResetTokenIdCounter++;
    const now = new Date();
    // Generate a random token
    const buffer = crypto.randomBytes(32);
    const token = buffer.toString('hex');
    const expiresAt = new Date(now.getTime() + 1000 * 60 * 60); // 1 hour from now
    
    const resetToken: PasswordResetToken = {
      id,
      userId,
      token,
      expiresAt,
      isUsed: false,
      createdAt: now
    };
    
    this.passwordResetTokensMap.set(id, resetToken);
    return resetToken;
  }
  
  async getPasswordResetToken(token: string): Promise<PasswordResetToken | undefined> {
    return Array.from(this.passwordResetTokensMap.values()).find(
      (resetToken) => resetToken.token === token && !resetToken.isUsed && resetToken.expiresAt > new Date()
    );
  }
  
  async markPasswordResetTokenUsed(id: number): Promise<PasswordResetToken | undefined> {
    const token = this.passwordResetTokensMap.get(id);
    if (!token) return undefined;
    
    const updatedToken = { ...token, isUsed: true };
    this.passwordResetTokensMap.set(id, updatedToken);
    return updatedToken;
  }

  // Initialize notification preferences maps and counters
  // Notification Preferences methods
  async getUserNotificationPreferences(userId: number): Promise<NotificationPreference | undefined> {
    return Array.from(this.notificationPreferencesMap.values())
      .find(prefs => prefs.userId === userId);
  }

  async createNotificationPreferences(preferences: InsertNotificationPreference): Promise<NotificationPreference> {
    const id = this.notificationPreferenceIdCounter++;
    const now = new Date();
    
    // Ensure all required fields have default values
    const newPrefs: NotificationPreference = {
      id,
      userId: preferences.userId,
      createdAt: now,
      updatedAt: now,
      emailNotifications: preferences.emailNotifications ?? true,
      pushNotifications: preferences.pushNotifications ?? true,
      inAppNotifications: preferences.inAppNotifications ?? true,
      prayerRequests: preferences.prayerRequests ?? true,
      groupInvitations: preferences.groupInvitations ?? true,
      comments: preferences.comments ?? true,
      statusUpdates: preferences.statusUpdates ?? true,
      groupUpdates: preferences.groupUpdates ?? true,
      stalePrayerReminders: preferences.stalePrayerReminders ?? true,
      reminderInterval: preferences.reminderInterval ?? 7
    };
    
    this.notificationPreferencesMap.set(id, newPrefs);
    return newPrefs;
  }

  async updateNotificationPreferences(userId: number, preferences: Partial<InsertNotificationPreference>): Promise<NotificationPreference | undefined> {
    const existing = await this.getUserNotificationPreferences(userId);
    if (!existing) return undefined;
    
    const updatedPrefs = { 
      ...existing, 
      ...preferences,
      updatedAt: new Date()
    };
    
    this.notificationPreferencesMap.set(existing.id, updatedPrefs);
    return updatedPrefs;
  }

  // Group Notification Preferences methods
  async getGroupNotificationPreferences(userId: number, groupId: number): Promise<GroupNotificationPreference | undefined> {
    return Array.from(this.groupNotificationPreferencesMap.values())
      .find(prefs => prefs.userId === userId && prefs.groupId === groupId);
  }

  async getUserGroupNotificationPreferences(userId: number): Promise<GroupNotificationPreference[]> {
    return Array.from(this.groupNotificationPreferencesMap.values())
      .filter(prefs => prefs.userId === userId);
  }

  async createGroupNotificationPreferences(preferences: InsertGroupNotificationPreference): Promise<GroupNotificationPreference> {
    const id = this.groupNotificationPreferenceIdCounter++;
    const now = new Date();
    
    // Ensure all required fields have default values
    const newPrefs: GroupNotificationPreference = {
      id,
      userId: preferences.userId,
      groupId: preferences.groupId,
      createdAt: now,
      updatedAt: now,
      muted: preferences.muted ?? false,
      newPrayerRequests: preferences.newPrayerRequests ?? true,
      prayerStatusUpdates: preferences.prayerStatusUpdates ?? true,
      newComments: preferences.newComments ?? true,
      groupUpdates: preferences.groupUpdates ?? true,
      meetingReminders: preferences.meetingReminders ?? true
    };
    
    this.groupNotificationPreferencesMap.set(id, newPrefs);
    return newPrefs;
  }

  async updateGroupNotificationPreferences(userId: number, groupId: number, preferences: Partial<InsertGroupNotificationPreference>): Promise<GroupNotificationPreference | undefined> {
    const existing = await this.getGroupNotificationPreferences(userId, groupId);
    if (!existing) return undefined;
    
    const updatedPrefs = { 
      ...existing, 
      ...preferences,
      updatedAt: new Date()
    };
    
    this.groupNotificationPreferencesMap.set(existing.id, updatedPrefs);
    return updatedPrefs;
  }
  
  // Meeting methods
  async createMeeting(meeting: InsertMeeting): Promise<Meeting> {
    const id = this.meetingIdCounter++;
    const now = new Date();
    
    const newMeeting: Meeting = {
      id,
      groupId: meeting.groupId,
      title: meeting.title,
      description: meeting.description || null,
      meetingType: meeting.meetingType,
      meetingLink: meeting.meetingLink,
      startTime: meeting.startTime,
      endTime: meeting.endTime || null,
      isRecurring: meeting.isRecurring || false,
      recurringPattern: meeting.recurringPattern || null,
      recurringDay: meeting.recurringDay || null,
      recurringUntil: meeting.recurringUntil || null,
      parentMeetingId: meeting.parentMeetingId || null,
      createdBy: meeting.createdBy,
      createdAt: now
    };
    
    this.meetingsMap.set(id, newMeeting);
    
    // If this is a recurring meeting, create recurring instances
    if (newMeeting.isRecurring && newMeeting.recurringPattern) {
      await this.generateRecurringMeetings(newMeeting);
    }
    
    return newMeeting;
  }
  
  // Helper method to generate recurring meeting instances
  async generateRecurringMeetings(parentMeeting: Meeting): Promise<Meeting[]> {
    if (!parentMeeting.isRecurring || !parentMeeting.recurringPattern) {
      return [];
    }
    
    const recurringMeetings: Meeting[] = [];
    const startDate = new Date(parentMeeting.startTime);
    const endDate = parentMeeting.recurringUntil || new Date(startDate.getTime() + (90 * 24 * 60 * 60 * 1000)); // Default to 90 days if no end date
    
    let currentDate = new Date(startDate);
    // Move to the next instance after the first one
    this.advanceToNextRecurringDate(currentDate, parentMeeting.recurringPattern, parentMeeting.recurringDay);
    
    // Generate up to 50 instances maximum
    let instanceCount = 0;
    const maxInstances = 50;
    
    while (currentDate <= endDate && instanceCount < maxInstances) {
      const meetingDuration = parentMeeting.endTime 
        ? new Date(parentMeeting.endTime).getTime() - new Date(parentMeeting.startTime).getTime() 
        : 60 * 60 * 1000; // Default 1 hour
      
      const endTime = parentMeeting.endTime 
        ? new Date(currentDate.getTime() + meetingDuration)
        : null;
      
      const meetingInstance: InsertMeeting = {
        groupId: parentMeeting.groupId,
        title: parentMeeting.title,
        description: parentMeeting.description,
        meetingType: parentMeeting.meetingType,
        meetingLink: parentMeeting.meetingLink,
        startTime: new Date(currentDate),
        endTime: endTime,
        isRecurring: false, // Instances are not themselves recurring
        createdBy: parentMeeting.createdBy,
        parentMeetingId: parentMeeting.id
      };
      
      const newInstance = await this.createMeeting(meetingInstance);
      recurringMeetings.push(newInstance);
      
      // Move to next instance
      this.advanceToNextRecurringDate(currentDate, parentMeeting.recurringPattern, parentMeeting.recurringDay);
      instanceCount++;
    }
    
    return recurringMeetings;
  }
  
  // Helper to calculate the next date based on recurrence pattern
  private advanceToNextRecurringDate(date: Date, pattern: string, recurringDay: number | null): void {
    switch (pattern) {
      case 'daily':
        date.setDate(date.getDate() + 1);
        break;
      case 'weekly':
        date.setDate(date.getDate() + 7);
        break;
      case 'biweekly':
        date.setDate(date.getDate() + 14);
        break;
      case 'monthly':
        // If recurringDay is set (1-31), use that day of the month
        if (recurringDay !== null && recurringDay >= 1 && recurringDay <= 31) {
          const currentMonth = date.getMonth();
          date.setMonth(currentMonth + 1);
          
          // Try to set the specific day, but account for months with fewer days
          const newMonth = date.getMonth();
          date.setDate(recurringDay);
          
          // If the month changed again, it means we went too far (e.g., trying to set Feb 31)
          // So go back to the last day of the intended month
          if (date.getMonth() !== newMonth) {
            date.setMonth(newMonth + 1, 0); // Last day of the intended month
          }
        } else {
          // Just add a month without changing the day
          const currentDate = date.getDate();
          date.setMonth(date.getMonth() + 1);
          
          // Adjust for months with fewer days
          if (date.getDate() !== currentDate) {
            date.setDate(0); // Last day of the previous month
          }
        }
        break;
      default:
        date.setDate(date.getDate() + 7); // Default to weekly
    }
  }
  
  async getMeeting(id: number): Promise<Meeting | undefined> {
    return this.meetingsMap.get(id);
  }
  
  async getGroupMeetings(groupId: number): Promise<Meeting[]> {
    return Array.from(this.meetingsMap.values())
      .filter(meeting => meeting.groupId === groupId)
      .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());
  }
  
  async getUpcomingMeetings(userId: number): Promise<Meeting[]> {
    // Get groups the user is a member of
    const userGroups = await this.getUserGroups(userId);
    
    if (userGroups.length === 0) {
      return [];
    }
    
    const now = new Date();
    const groupIds = userGroups.map(group => group.id);
    
    // Get meetings for these groups that are in the future
    return Array.from(this.meetingsMap.values())
      .filter(meeting => 
        groupIds.includes(meeting.groupId) && 
        new Date(meeting.startTime) > now
      )
      .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());
  }
  
  async updateMeeting(id: number, meetingUpdates: Partial<InsertMeeting>): Promise<Meeting | undefined> {
    const meeting = await this.getMeeting(id);
    if (!meeting) return undefined;
    
    const updatedMeeting = { ...meeting, ...meetingUpdates };
    this.meetingsMap.set(id, updatedMeeting);
    return updatedMeeting;
  }
  
  async deleteMeeting(id: number): Promise<boolean> {
    // First delete all meeting notes
    const meetingNotes = Array.from(this.meetingNotesMap.values())
      .filter(note => note.meetingId === id);
    
    for (const note of meetingNotes) {
      this.meetingNotesMap.delete(note.id);
    }
    
    // Then delete the meeting
    return this.meetingsMap.delete(id);
  }
  
  // Meeting Notes methods
  async createMeetingNotes(notes: InsertMeetingNote): Promise<MeetingNote> {
    const id = this.meetingNotesIdCounter++;
    const now = new Date();
    
    const newNote: MeetingNote = {
      id,
      meetingId: notes.meetingId,
      content: notes.content,
      summary: notes.summary || null,
      isAiGenerated: notes.isAiGenerated || false,
      createdAt: now
    };
    
    this.meetingNotesMap.set(id, newNote);
    return newNote;
  }
  
  async getMeetingNotes(meetingId: number): Promise<MeetingNote[]> {
    return Array.from(this.meetingNotesMap.values())
      .filter(note => note.meetingId === meetingId)
      .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
  }
  
  async updateMeetingNotes(id: number, notesUpdates: Partial<InsertMeetingNote>): Promise<MeetingNote | undefined> {
    const notes = this.meetingNotesMap.get(id);
    if (!notes) return undefined;
    
    const updatedNotes = { ...notes, ...notesUpdates };
    this.meetingNotesMap.set(id, updatedNotes);
    return updatedNotes;
  }
  
  async deleteMeetingNotes(id: number): Promise<boolean> {
    return this.meetingNotesMap.delete(id);
  }
  
  async createPrayerRequestsFromNotes(meetingId: number, groupId: number, userId: number): Promise<PrayerRequest[]> {
    const notes = await this.getMeetingNotes(meetingId);
    if (notes.length === 0) return [];
    
    // Create prayer requests from notes
    const meeting = await this.getMeeting(meetingId);
    if (!meeting) return [];
    
    const createdRequests: PrayerRequest[] = [];
    
    // Use the meeting title as context for the prayer requests
    for (const note of notes) {
      if (!note.content) continue;
      
      // Create a prayer request from the note
      const prayerRequest = await this.createPrayerRequest({
        groupId,
        userId,
        title: `From meeting: ${meeting.title}`,
        description: note.content,
        urgency: "medium",
        isAnonymous: false,
        status: "waiting"
      });
      
      createdRequests.push(prayerRequest);
    }
    
    return createdRequests;
  }

  // Stale prayer request management  
  async checkAndUpdateStalePrayerRequests(): Promise<number> {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    // Find prayer requests with a follow-up date in the past that haven't been marked as stale
    const staleRequests = Array.from(this.prayerRequestsMap.values())
      .filter(request => 
        !request.isStale && 
        request.status === "waiting" && 
        request.followUpDate !== null && 
        request.followUpDate < today
      );
    
    if (staleRequests.length === 0) {
      return 0;
    }
    
    // Mark requests as stale
    for (const request of staleRequests) {
      const updatedRequest = {
        ...request,
        isStale: true
      };
      
      this.prayerRequestsMap.set(request.id, updatedRequest);
      
      // Create notification for the prayer request owner
      await this.createNotification({
        userId: request.userId,
        type: "status_update",
        message: `Your prayer request "${request.title}" is now stale. Please update its status.`,
        referenceId: request.id,
      });
    }
    
    return staleRequests.length;
  }
  
  // Favorite Groups
  private favoriteGroupsMap = new Map<number, FavoriteGroup>();
  private favoriteGroupIdCounter = 1;
  
  async addFavoriteGroup(userId: number, groupId: number): Promise<FavoriteGroup> {
    // Check if it's already a favorite
    const existing = Array.from(this.favoriteGroupsMap.values())
      .find(fav => fav.userId === userId && fav.groupId === groupId);
      
    if (existing) {
      return existing;
    }
    
    const id = this.favoriteGroupIdCounter++;
    const now = new Date();
    
    const favoriteGroup: FavoriteGroup = {
      id,
      userId,
      groupId,
      createdAt: now
    };
    
    this.favoriteGroupsMap.set(id, favoriteGroup);
    return favoriteGroup;
  }
  
  async removeFavoriteGroup(userId: number, groupId: number): Promise<boolean> {
    const favorite = Array.from(this.favoriteGroupsMap.values())
      .find(fav => fav.userId === userId && fav.groupId === groupId);
      
    if (!favorite) {
      return false;
    }
    
    return this.favoriteGroupsMap.delete(favorite.id);
  }
  
  async getUserFavoriteGroups(userId: number): Promise<Group[]> {
    const favoriteGroupIds = Array.from(this.favoriteGroupsMap.values())
      .filter(fav => fav.userId === userId)
      .map(fav => fav.groupId);
      
    return Array.from(this.groupsMap.values())
      .filter(group => favoriteGroupIds.includes(group.id));
  }
  
  async isFavoriteGroup(userId: number, groupId: number): Promise<boolean> {
    return Array.from(this.favoriteGroupsMap.values())
      .some(fav => fav.userId === userId && fav.groupId === groupId);
  }
}

export class DatabaseStorage implements IStorage {
  sessionStore: any;

  constructor() {
    // Session store setup
    this.sessionStore = new PostgresSessionStore({
      conObject: {
        connectionString: process.env.DATABASE_URL as string,
        ssl: { rejectUnauthorized: false }
      },
      createTableIfMissing: true
    });
  }
  
  // Meeting methods
  async createMeeting(meeting: InsertMeeting): Promise<Meeting> {
    const [newMeeting] = await db.insert(meetings)
      .values(meeting)
      .returning();
      
    // If this is a recurring meeting, create recurring instances
    if (newMeeting.isRecurring && newMeeting.recurringPattern) {
      await this.generateRecurringMeetings(newMeeting);
    }
      
    return newMeeting;
  }
  
  // Helper method to generate recurring meeting instances
  async generateRecurringMeetings(parentMeeting: Meeting): Promise<Meeting[]> {
    if (!parentMeeting.isRecurring || !parentMeeting.recurringPattern) {
      return [];
    }
    
    const recurringMeetings: Meeting[] = [];
    const startDate = new Date(parentMeeting.startTime);
    const endDate = parentMeeting.recurringUntil || new Date(startDate.getTime() + (90 * 24 * 60 * 60 * 1000)); // Default to 90 days if no end date
    
    let currentDate = new Date(startDate);
    // Move to the next instance after the first one
    this.advanceToNextRecurringDate(currentDate, parentMeeting.recurringPattern, parentMeeting.recurringDay);
    
    // Generate up to 50 instances maximum
    let instanceCount = 0;
    const maxInstances = 50;
    
    while (currentDate <= endDate && instanceCount < maxInstances) {
      const meetingDuration = parentMeeting.endTime 
        ? new Date(parentMeeting.endTime).getTime() - new Date(parentMeeting.startTime).getTime() 
        : 60 * 60 * 1000; // Default 1 hour
      
      const endTime = parentMeeting.endTime 
        ? new Date(currentDate.getTime() + meetingDuration)
        : null;
      
      const meetingInstance: InsertMeeting = {
        groupId: parentMeeting.groupId,
        title: parentMeeting.title,
        description: parentMeeting.description,
        meetingType: parentMeeting.meetingType,
        meetingLink: parentMeeting.meetingLink,
        startTime: new Date(currentDate),
        endTime: endTime,
        isRecurring: false, // Instances are not themselves recurring
        createdBy: parentMeeting.createdBy,
        parentMeetingId: parentMeeting.id
      };
      
      // Insert directly to avoid recursion
      const [newInstance] = await db.insert(meetings)
        .values(meetingInstance)
        .returning();
        
      recurringMeetings.push(newInstance);
      
      // Move to next instance
      this.advanceToNextRecurringDate(currentDate, parentMeeting.recurringPattern, parentMeeting.recurringDay);
      instanceCount++;
    }
    
    return recurringMeetings;
  }
  
  // Helper to calculate the next date based on recurrence pattern
  private advanceToNextRecurringDate(date: Date, pattern: string, recurringDay: number | null): void {
    switch (pattern) {
      case 'daily':
        date.setDate(date.getDate() + 1);
        break;
      case 'weekly':
        date.setDate(date.getDate() + 7);
        break;
      case 'biweekly':
        date.setDate(date.getDate() + 14);
        break;
      case 'monthly':
        // If recurringDay is set (1-31), use that day of the month
        if (recurringDay !== null && recurringDay >= 1 && recurringDay <= 31) {
          const currentMonth = date.getMonth();
          date.setMonth(currentMonth + 1);
          
          // Try to set the specific day, but account for months with fewer days
          const newMonth = date.getMonth();
          date.setDate(recurringDay);
          
          // If the month changed again, it means we went too far (e.g., trying to set Feb 31)
          // So go back to the last day of the intended month
          if (date.getMonth() !== newMonth) {
            date.setMonth(newMonth + 1, 0); // Last day of the intended month
          }
        } else {
          // Just add a month without changing the day
          const currentDate = date.getDate();
          date.setMonth(date.getMonth() + 1);
          
          // Adjust for months with fewer days
          if (date.getDate() !== currentDate) {
            date.setDate(0); // Last day of the previous month
          }
        }
        break;
      default:
        date.setDate(date.getDate() + 7); // Default to weekly
    }
  }
  
  async getMeeting(id: number): Promise<Meeting | undefined> {
    const [meeting] = await db.select()
      .from(meetings)
      .where(eq(meetings.id, id));
    return meeting;
  }
  
  async getGroupMeetings(groupId: number): Promise<Meeting[]> {
    return db.select()
      .from(meetings)
      .where(eq(meetings.groupId, groupId))
      .orderBy(meetings.startTime);
  }
  
  async getUpcomingMeetings(userId: number): Promise<Meeting[]> {
    // Get groups the user is a member of
    const userGroups = await this.getUserGroups(userId);
    
    if (userGroups.length === 0) {
      return [];
    }
    
    const now = new Date();
    const groupIds = userGroups.map(group => group.id);
    
    // Get meetings for these groups that are in the future
    return db.select()
      .from(meetings)
      .where(and(
        inArray(meetings.groupId, groupIds),
        sql`${meetings.startTime} > ${now}`
      ))
      .orderBy(meetings.startTime);
  }
  
  async updateMeeting(id: number, meetingUpdates: Partial<InsertMeeting>): Promise<Meeting | undefined> {
    const [updatedMeeting] = await db.update(meetings)
      .set(meetingUpdates)
      .where(eq(meetings.id, id))
      .returning();
    return updatedMeeting;
  }
  
  async deleteMeeting(id: number): Promise<boolean> {
    // First delete all meeting notes
    await db.delete(meetingNotes)
      .where(eq(meetingNotes.meetingId, id));
    
    // Then delete the meeting
    const result = await db.delete(meetings)
      .where(eq(meetings.id, id))
      .returning();
    return result.length > 0;
  }
  
  // Meeting Notes methods
  async createMeetingNotes(notes: InsertMeetingNote): Promise<MeetingNote> {
    const [newNote] = await db.insert(meetingNotes)
      .values(notes)
      .returning();
    return newNote;
  }
  
  async getMeetingNotes(meetingId: number): Promise<MeetingNote[]> {
    return db.select()
      .from(meetingNotes)
      .where(eq(meetingNotes.meetingId, meetingId))
      .orderBy(meetingNotes.createdAt);
  }
  
  async updateMeetingNotes(id: number, notesUpdates: Partial<InsertMeetingNote>): Promise<MeetingNote | undefined> {
    const [updatedNotes] = await db.update(meetingNotes)
      .set(notesUpdates)
      .where(eq(meetingNotes.id, id))
      .returning();
    return updatedNotes;
  }
  
  async deleteMeetingNotes(id: number): Promise<boolean> {
    const result = await db.delete(meetingNotes)
      .where(eq(meetingNotes.id, id))
      .returning();
    return result.length > 0;
  }
  
  async createPrayerRequestsFromNotes(meetingId: number, groupId: number, userId: number): Promise<PrayerRequest[]> {
    const notes = await this.getMeetingNotes(meetingId);
    if (notes.length === 0) return [];
    
    // Create prayer requests from notes
    const meeting = await this.getMeeting(meetingId);
    if (!meeting) return [];
    
    const createdRequests: PrayerRequest[] = [];
    
    // Use the meeting title as context for the prayer requests
    for (const note of notes) {
      if (!note.content) continue;
      
      // Create a prayer request from the note
      const prayerRequest = await this.createPrayerRequest({
        groupId,
        userId,
        title: `From meeting: ${meeting.title}`,
        description: note.content,
        urgency: "medium",
        isAnonymous: false,
        status: "waiting"
      });
      
      createdRequests.push(prayerRequest);
    }
    
    return createdRequests;
  }

  // User methods
  async getUser(id: number): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.username, username));
    return result[0];
  }
  
  async getUsers(): Promise<User[]> {
    return await db.select().from(users);
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    // Validate role is one of the allowed values
    const validRole = insertUser.role && ["regular", "leader", "admin"].includes(insertUser.role)
      ? insertUser.role as "regular" | "leader" | "admin"
      : "regular";
    
    const userToInsert = {
      username: insertUser.username,
      password: insertUser.password,
      name: insertUser.name,
      email: insertUser.email,
      role: validRole,
      phone: insertUser.phone || null,
      avatar: insertUser.avatar || null,
      bio: insertUser.bio || null
    };
    
    const result = await db.insert(users).values(userToInsert).returning();
    return result[0];
  }
  
  async updateUser(id: number, userData: Partial<User>): Promise<User | undefined> {
    // If updating the role, validate it's a permitted value
    let validatedUserData = { ...userData };
    if (userData.role) {
      validatedUserData.role = ["regular", "leader", "admin"].includes(userData.role) 
        ? userData.role as "regular" | "leader" | "admin"
        : userData.role;
    }
    
    const result = await db.update(users)
      .set(validatedUserData)
      .where(eq(users.id, id))
      .returning();
    
    return result[0];
  }
  
  async updateUserRole(id: number, role: string): Promise<User | undefined> {
    // Validate role is one of the allowed values
    const validRole = ["regular", "leader", "admin"].includes(role) 
      ? role as "regular" | "leader" | "admin"
      : "regular";
    
    const result = await db.update(users)
      .set({ role: validRole })
      .where(eq(users.id, id))
      .returning();
    
    return result[0];
  }
  
  // Organization methods
  async createOrganization(insertOrg: InsertOrganization): Promise<Organization> {
    const result = await db.insert(organizations)
      .values({
        name: insertOrg.name,
        description: insertOrg.description,
        createdBy: insertOrg.createdBy,
      })
      .returning();
    
    const org = result[0];
    
    // Add creator as admin
    await this.addOrganizationMember({
      organizationId: org.id,
      userId: org.createdBy,
      role: "admin"
    });
    
    return org;
  }
  
  async getOrganization(id: number): Promise<Organization | undefined> {
    const result = await db.select().from(organizations).where(eq(organizations.id, id));
    return result[0];
  }
  
  async getUserOrganizations(userId: number): Promise<Organization[]> {
    // Get organization memberships for the user
    const memberships = await db.select()
      .from(organizationMembers)
      .where(eq(organizationMembers.userId, userId));
    
    if (memberships.length === 0) {
      return [];
    }
    
    // Get organizations for these memberships
    const orgIds = memberships.map(m => m.organizationId);
    
    // Use in operator for PostgreSQL array comparison
    return await db.select()
      .from(organizations)
      .where(inArray(organizations.id, orgIds));
  }
  
  async updateOrganization(id: number, orgUpdates: Partial<InsertOrganization>): Promise<Organization | undefined> {
    const result = await db.update(organizations)
      .set(orgUpdates)
      .where(eq(organizations.id, id))
      .returning();
    
    return result[0];
  }
  
  async deleteOrganization(id: number): Promise<boolean> {
    // Delete organization members
    await db.delete(organizationMembers)
      .where(eq(organizationMembers.organizationId, id));
    
    // Find groups in this organization
    const orgGroups = await db.select()
      .from(groups)
      .where(eq(groups.organizationId, id));
    
    // Delete each group
    for (const group of orgGroups) {
      await this.deleteGroup(group.id);
    }
    
    // Delete the organization
    const result = await db.delete(organizations)
      .where(eq(organizations.id, id))
      .returning();
    
    return result.length > 0;
  }
  
  // Organization Member methods
  async addOrganizationMember(insertMember: InsertOrganizationMember): Promise<OrganizationMember> {
    // Validate role is one of the allowed values
    const validRole = insertMember.role && ["admin", "member"].includes(insertMember.role)
      ? insertMember.role as "admin" | "member"
      : "member";
    
    const result = await db.insert(organizationMembers)
      .values({
        organizationId: insertMember.organizationId,
        userId: insertMember.userId,
        role: validRole,
      })
      .returning();
    
    return result[0];
  }
  
  async getOrganizationMembers(organizationId: number): Promise<OrganizationMember[]> {
    return await db.select()
      .from(organizationMembers)
      .where(eq(organizationMembers.organizationId, organizationId));
  }
  
  async getOrganizationMember(organizationId: number, userId: number): Promise<OrganizationMember | undefined> {
    const result = await db.select()
      .from(organizationMembers)
      .where(
        and(
          eq(organizationMembers.organizationId, organizationId),
          eq(organizationMembers.userId, userId)
        )
      );
    
    return result[0];
  }
  
  async updateOrganizationMember(organizationId: number, userId: number, role: string): Promise<OrganizationMember | undefined> {
    // Validate role is one of the allowed values
    const validRole = ["admin", "member"].includes(role) 
      ? role as "admin" | "member"
      : "member";
    
    const result = await db.update(organizationMembers)
      .set({ role: validRole })
      .where(
        and(
          eq(organizationMembers.organizationId, organizationId),
          eq(organizationMembers.userId, userId)
        )
      )
      .returning();
    
    return result[0];
  }
  
  async removeOrganizationMember(organizationId: number, userId: number): Promise<boolean> {
    const result = await db.delete(organizationMembers)
      .where(
        and(
          eq(organizationMembers.organizationId, organizationId),
          eq(organizationMembers.userId, userId)
        )
      )
      .returning();
    
    return result.length > 0;
  }
  
  // Organization Tag methods
  async createOrganizationTag(tag: InsertOrganizationTag): Promise<OrganizationTag> {
    const [newTag] = await db.insert(organizationTags)
      .values(tag)
      .returning();
    return newTag;
  }
  
  async getOrganizationTags(organizationId: number): Promise<OrganizationTag[]> {
    return db.select()
      .from(organizationTags)
      .where(eq(organizationTags.organizationId, organizationId));
  }
  
  async getOrganizationTag(id: number): Promise<OrganizationTag | undefined> {
    const [tag] = await db.select()
      .from(organizationTags)
      .where(eq(organizationTags.id, id));
    return tag;
  }
  
  async updateOrganizationTag(id: number, tagData: Partial<InsertOrganizationTag>): Promise<OrganizationTag | undefined> {
    const [updatedTag] = await db.update(organizationTags)
      .set(tagData)
      .where(eq(organizationTags.id, id))
      .returning();
    return updatedTag;
  }
  
  async deleteOrganizationTag(id: number): Promise<boolean> {
    // First delete all group associations with this tag
    await db.delete(groupTags)
      .where(eq(groupTags.tagId, id));
      
    // Then delete the tag itself
    const result = await db.delete(organizationTags)
      .where(eq(organizationTags.id, id))
      .returning();
    return result.length > 0;
  }
  
  // Group Tag methods
  async addGroupTag(groupTag: InsertGroupTag): Promise<GroupTag> {
    const [newGroupTag] = await db.insert(groupTags)
      .values(groupTag)
      .returning();
    return newGroupTag;
  }
  
  async getGroupTags(groupId: number): Promise<GroupTag[]> {
    return db.select()
      .from(groupTags)
      .where(eq(groupTags.groupId, groupId));
  }
  
  async getGroupTagsWithDetails(groupId: number): Promise<OrganizationTag[]> {
    // Get all tag IDs associated with this group
    const groupTagEntries = await this.getGroupTags(groupId);
    
    if (groupTagEntries.length === 0) {
      return [];
    }
    
    // Get the details of each tag
    const tagIds = groupTagEntries.map(entry => entry.tagId);
    return db.select()
      .from(organizationTags)
      .where(inArray(organizationTags.id, tagIds));
  }
  
  async removeGroupTag(groupId: number, tagId: number): Promise<boolean> {
    const result = await db.delete(groupTags)
      .where(and(
        eq(groupTags.groupId, groupId),
        eq(groupTags.tagId, tagId)
      ))
      .returning();
    return result.length > 0;
  }
  
  // Group methods
  async createGroup(insertGroup: InsertGroup): Promise<Group> {
    const now = new Date();
    const groupToInsert = {
      ...insertGroup,
      createdAt: now,
      description: insertGroup.description ?? null,
      category: insertGroup.category || "other",
      privacy: insertGroup.privacy || "open",
      leaderRotation: insertGroup.leaderRotation ?? null
    };
    
    const result = await db.insert(groups).values(groupToInsert).returning();
    const group = result[0];
    
    // Add creator as leader
    await this.addGroupMember({
      groupId: group.id,
      userId: insertGroup.createdBy,
      role: "leader" 
    });
    
    return group;
  }
  
  async getGroup(id: number): Promise<Group | undefined> {
    const result = await db.select().from(groups).where(eq(groups.id, id));
    return result[0];
  }
  
  async getGroups(): Promise<Group[]> {
    return await db.select().from(groups);
  }
  
  async getGroupsByCategory(category: string): Promise<Group[]> {
    return await db.select()
      .from(groups)
      .where(sql`${groups.category} = ${category}`);
  }
  
  async getGroupsByOrganization(organizationId: number): Promise<Group[]> {
    return await db.select()
      .from(groups)
      .where(eq(groups.organizationId, organizationId));
  }
  
  async getUserGroups(userId: number): Promise<Group[]> {
    // Join group_members and groups tables to get user's groups
    const result = await db
      .select({
        id: groups.id,
        name: groups.name,
        description: groups.description,
        createdAt: groups.createdAt,
        createdBy: groups.createdBy,
        organizationId: groups.organizationId,
        privacy: groups.privacy,
        category: groups.category,
        leaderRotation: groups.leaderRotation
      })
      .from(groupMembers)
      .innerJoin(groups, eq(groupMembers.groupId, groups.id))
      .where(eq(groupMembers.userId, userId));
    
    return result;
  }
  
  async updateGroup(id: number, groupUpdates: Partial<InsertGroup>): Promise<Group | undefined> {
    const result = await db.update(groups)
      .set(groupUpdates)
      .where(eq(groups.id, id))
      .returning();
    
    return result[0];
  }
  
  async deleteGroup(id: number): Promise<boolean> {
    try {
      // Start a transaction to ensure all related records are deleted
      await db.transaction(async (tx) => {
        // Delete related records in proper order to respect foreign keys
        
        // 1. First delete comments on prayer requests in this group
        const groupRequests = await tx.select({ id: prayerRequests.id })
          .from(prayerRequests)
          .where(eq(prayerRequests.groupId, id));
        
        const requestIds = groupRequests.map((r: { id: number }) => r.id);
        
        if (requestIds.length > 0) {
          // Delete comments
          await tx.delete(comments)
            .where(sql`${comments.prayerRequestId} IN (${sql.join(requestIds)})`);
          
          // Delete praying for records
          await tx.delete(prayingFor)
            .where(sql`${prayingFor.prayerRequestId} IN (${sql.join(requestIds)})`);
          
          // Delete notifications referring to these requests
          await tx.delete(notifications)
            .where(sql`${notifications.referenceId} IN (${sql.join(requestIds)})`);
          
          // Delete prayer requests
          await tx.delete(prayerRequests)
            .where(eq(prayerRequests.groupId, id));
        }
        
        // 2. Delete group members
        await tx.delete(groupMembers)
          .where(eq(groupMembers.groupId, id));
        
        // 3. Finally delete the group
        await tx.delete(groups)
          .where(eq(groups.id, id));
      });
      
      return true;
    } catch (error) {
      console.error("Error deleting group:", error);
      return false;
    }
  }
  
  // Group Member methods
  async addGroupMember(insertMember: InsertGroupMember): Promise<GroupMember> {
    const now = new Date();
    
    // Validate role is one of the allowed values
    const validRole = insertMember.role && ["leader", "member"].includes(insertMember.role)
      ? insertMember.role as "leader" | "member"
      : "member";
    
    const memberToInsert = {
      ...insertMember,
      joinedAt: now,
      role: validRole
    };
    
    const result = await db.insert(groupMembers).values(memberToInsert).returning();
    return result[0];
  }
  
  async getGroupMembers(groupId: number): Promise<GroupMember[]> {
    return await db.select()
      .from(groupMembers)
      .where(eq(groupMembers.groupId, groupId));
  }
  
  async getGroupMember(groupId: number, userId: number): Promise<GroupMember | undefined> {
    const result = await db.select()
      .from(groupMembers)
      .where(
        and(
          eq(groupMembers.groupId, groupId),
          eq(groupMembers.userId, userId)
        )
      );
    
    return result[0];
  }
  
  async updateGroupMember(groupId: number, userId: number, role: string): Promise<GroupMember | undefined> {
    // Validate role is one of the allowed values
    const validRole = ["leader", "member"].includes(role) 
      ? role as "leader" | "member"
      : "member";
    
    const result = await db.update(groupMembers)
      .set({ role: validRole })
      .where(
        and(
          eq(groupMembers.groupId, groupId),
          eq(groupMembers.userId, userId)
        )
      )
      .returning();
    
    return result[0];
  }
  
  async removeGroupMember(groupId: number, userId: number): Promise<boolean> {
    try {
      await db.delete(groupMembers)
        .where(
          and(
            eq(groupMembers.groupId, groupId),
            eq(groupMembers.userId, userId)
          )
        );
      
      return true;
    } catch (error) {
      console.error("Error removing group member:", error);
      return false;
    }
  }
  
  // Prayer Request methods
  async createPrayerRequest(insertRequest: InsertPrayerRequest): Promise<PrayerRequest> {
    const now = new Date();
    const requestToInsert = {
      groupId: insertRequest.groupId,
      userId: insertRequest.userId,
      title: insertRequest.title,
      description: insertRequest.description,
      urgency: insertRequest.urgency || "medium",
      isAnonymous: insertRequest.isAnonymous || false,
      status: insertRequest.status || "waiting",
      followUpDate: insertRequest.followUpDate !== undefined ? insertRequest.followUpDate : null,
      isStale: insertRequest.isStale || false,
      createdAt: now,
      updatedAt: now
    };
    
    const result = await db.insert(prayerRequests).values(requestToInsert).returning();
    const request = result[0];
    
    // Create notifications for group members
    const groupMembers = await this.getGroupMembers(request.groupId);
    for (const member of groupMembers) {
      // Don't notify the creator
      if (member.userId !== request.userId) {
        const group = await this.getGroup(request.groupId);
        const requester = await this.getUser(request.userId);
        if (group && requester) {
          const requesterName = request.isAnonymous ? "Anonymous" : requester.name;
          await this.createNotification({
            userId: member.userId,
            type: "new_request",
            message: `New prayer request: ${request.title} in ${group.name} by ${requesterName}`,
            referenceId: request.id,
          });
        }
      }
    }
    
    return request;
  }
  
  async getPrayerRequest(id: number): Promise<PrayerRequest | undefined> {
    try {
      // Use standard Drizzle query to avoid missing column errors
      const result = await db.select()
        .from(prayerRequests)
        .where(eq(prayerRequests.id, id));
      
      if (result.length === 0) {
        return undefined;
      }
      
      // Add missing properties with default values
      const request = result[0];
      return {
        ...request,
        isStale: false, // Default value since column doesn't exist in DB
        followUpDate: null, // Default value since column doesn't exist in DB
        content: request.description // Ensure content is set for backward compatibility
      } as PrayerRequest;
    } catch (error) {
      console.error("Error in getPrayerRequest:", error);
      return undefined;
    }
  }
  
  async getGroupPrayerRequests(groupId: number): Promise<PrayerRequest[]> {
    try {
      // Use standard Drizzle query to avoid missing column errors
      const requests = await db.select()
        .from(prayerRequests)
        .where(eq(prayerRequests.groupId, groupId))
        .orderBy(desc(prayerRequests.createdAt));
      
      // Add missing properties with default values
      return requests.map(request => ({
        ...request,
        isStale: false, // Default value since column doesn't exist in DB
        followUpDate: null, // Default value since column doesn't exist in DB
        content: request.description // Ensure content is set for backward compatibility
      }));
    } catch (error) {
      console.error("Error in getGroupPrayerRequests:", error);
      return [];
    }
  }
  
  async getUserPrayerRequests(userId: number): Promise<PrayerRequest[]> {
    try {
      // Use standard Drizzle query to avoid missing column errors
      const requests = await db.select()
        .from(prayerRequests)
        .where(eq(prayerRequests.userId, userId))
        .orderBy(desc(prayerRequests.createdAt));
      
      // Add missing properties with default values
      return requests.map(request => ({
        ...request,
        isStale: false, // Default value since column doesn't exist in DB
        followUpDate: null, // Default value since column doesn't exist in DB
        content: request.description // Ensure content is set for backward compatibility
      }));
    } catch (error) {
      console.error("Error in getUserPrayerRequests:", error);
      return [];
    }
  }
  
  async getRecentPrayerRequests(userId: number, limit = 5): Promise<PrayerRequest[]> {
    try {
      // Get groups the user is a member of
      const userGroups = await this.getUserGroups(userId);
      const groupIds = userGroups.map(group => group.id);
      
      if (groupIds.length === 0) {
        return [];
      }
      
      // Use a more primitive query approach to avoid column-related issues
      // Strictly limit to the 5 most recent requests
      const { rows } = await pool.query(
        `SELECT 
          id, group_id as "groupId", user_id as "userId", title, description, 
          urgency, is_anonymous as "isAnonymous", status, 
          created_at as "createdAt", updated_at as "updatedAt"
        FROM prayer_requests
        WHERE group_id = ANY($1)
        ORDER BY created_at DESC
        LIMIT $2`,
        [groupIds, Math.min(limit, 5)] // Ensure we never return more than 5 requests
      );
      
      // Add default/missing properties
      return rows.map((request: any) => ({
        ...request,
        isStale: false, // Default value since column doesn't exist in DB
        followUpDate: null, // Default value since column doesn't exist in DB
        content: request.description // Ensure content is set for backward compatibility
      }));
    } catch (error) {
      console.error('Error in getRecentPrayerRequests:', error);
      return [];
    }
  }
  
  async getRecentPrayerRequestsByGroups(groupIds: number[], limit = 5): Promise<PrayerRequest[]> {
    try {
      if (groupIds.length === 0) {
        return [];
      }
      
      // Use a more primitive query approach to avoid column-related issues
      // Strictly limit to the 5 most recent requests
      const { rows } = await pool.query(
        `SELECT 
          id, group_id as "groupId", user_id as "userId", title, description, 
          urgency, is_anonymous as "isAnonymous", status, 
          created_at as "createdAt", updated_at as "updatedAt"
        FROM prayer_requests
        WHERE group_id = ANY($1)
        ORDER BY created_at DESC
        LIMIT $2`,
        [groupIds, Math.min(limit, 5)] // Ensure we never return more than 5 requests
      );
      
      // Add default/missing properties
      return rows.map((request: any) => ({
        ...request,
        isStale: false, // Default value since column doesn't exist in DB
        followUpDate: null, // Default value since column doesn't exist in DB
        content: request.description // Ensure content is set for backward compatibility
      }));
    } catch (error) {
      console.error('Error in getRecentPrayerRequestsByGroups:', error);
      return [];
    }
  }
  
  async updatePrayerRequest(id: number, requestUpdates: Partial<InsertPrayerRequest>): Promise<PrayerRequest | undefined> {
    const now = new Date();
    const updates = {
      ...requestUpdates,
      updatedAt: now
    };
    
    const result = await db.update(prayerRequests)
      .set(updates)
      .where(eq(prayerRequests.id, id))
      .returning();
    
    const updatedRequest = result[0];
    
    // If status was updated, create notification
    if (requestUpdates.status) {
      const request = await this.getPrayerRequest(id);
      if (request && requestUpdates.status !== request.status) {
        const requester = await this.getUser(request.userId);
        const group = await this.getGroup(request.groupId);
        
        if (requester && group) {
          // Notify group members about status update
          const groupMembers = await this.getGroupMembers(request.groupId);
          for (const member of groupMembers) {
            // No need to notify the requester if they updated their own status
            if (member.userId !== request.userId) {
              let statusText = "updated to";
              if (requestUpdates.status === "answered") statusText = "marked as answered";
              if (requestUpdates.status === "declined") statusText = "marked as declined";
              
              await this.createNotification({
                userId: member.userId,
                type: "status_update",
                message: `Prayer request "${request.title}" in ${group.name} was ${statusText}`,
                referenceId: id,
              });
            }
          }
        }
      }
    }
    
    return updatedRequest;
  }
  
  async deletePrayerRequest(id: number): Promise<boolean> {
    try {
      // Start a transaction to delete prayer request and related records
      await db.transaction(async (tx) => {
        // Delete comments
        await tx.delete(comments)
          .where(eq(comments.prayerRequestId, id));
        
        // Delete praying for records
        await tx.delete(prayingFor)
          .where(eq(prayingFor.prayerRequestId, id));
        
        // Delete notifications
        await tx.delete(notifications)
          .where(eq(notifications.referenceId, id));
        
        // Delete the prayer request
        await tx.delete(prayerRequests)
          .where(eq(prayerRequests.id, id));
      });
      
      return true;
    } catch (error) {
      console.error("Error deleting prayer request:", error);
      return false;
    }
  }
  
  // Comment methods
  async createComment(insertComment: InsertComment): Promise<Comment> {
    const now = new Date();
    const commentToInsert = {
      ...insertComment,
      createdAt: now,
      isPrivate: insertComment.isPrivate || false
    };
    
    const result = await db.insert(comments).values(commentToInsert).returning();
    const comment = result[0];
    
    // Create notification for prayer request owner
    const request = await this.getPrayerRequest(comment.prayerRequestId);
    if (request && request.userId !== comment.userId) {
      const commenter = await this.getUser(comment.userId);
      if (commenter) {
        await this.createNotification({
          userId: request.userId,
          type: "new_comment",
          message: `${commenter.name} commented on your prayer request "${request.title}"`,
          referenceId: comment.prayerRequestId,
        });
      }
    }
    
    return comment;
  }
  
  async getComment(id: number): Promise<Comment | undefined> {
    const result = await db.select()
      .from(comments)
      .where(eq(comments.id, id));
    
    return result[0];
  }
  
  async getPrayerRequestComments(prayerRequestId: number): Promise<Comment[]> {
    return await db.select()
      .from(comments)
      .where(eq(comments.prayerRequestId, prayerRequestId))
      .orderBy(comments.createdAt);
  }
  
  async deleteComment(id: number): Promise<boolean> {
    try {
      await db.delete(comments)
        .where(eq(comments.id, id));
      
      return true;
    } catch (error) {
      console.error("Error deleting comment:", error);
      return false;
    }
  }
  
  // Notifications
  async createNotification(insertNotification: InsertNotification): Promise<Notification> {
    const now = new Date();
    const notificationToInsert = {
      ...insertNotification,
      createdAt: now,
      read: false
    };
    
    const result = await db.insert(notifications).values(notificationToInsert).returning();
    return result[0];
  }
  
  async getUserNotifications(userId: number, organizationId?: number): Promise<Notification[]> {
    // Get all notifications for this user
    const userNotifications = await db.select()
      .from(notifications)
      .where(eq(notifications.userId, userId))
      .orderBy(desc(notifications.createdAt));
    
    // If no organizationId is provided, return all notifications
    if (!organizationId) {
      return userNotifications;
    }
    
    // Otherwise, filter notifications by organization
    const filteredNotifications = [];
    
    for (const notification of userNotifications) {
      // Skip notifications with no referenceId
      if (notification.referenceId === null) {
        filteredNotifications.push(notification);
        continue;
      }
      
      const refId = notification.referenceId;
      
      // Check if it's a notification about a group
      if (notification.type.includes('group')) {
        const [group] = await db.select()
          .from(groups)
          .where(eq(groups.id, refId));
          
        if (group && group.organizationId === organizationId) {
          filteredNotifications.push(notification);
        }
        continue;
      }
      
      // Check if it's a notification about a prayer request
      if (notification.type.includes('prayer') || notification.type.includes('request') || notification.type === 'status_update') {
        const [request] = await db.select()
          .from(prayerRequests)
          .where(eq(prayerRequests.id, refId));
          
        if (request) {
          const [group] = await db.select()
            .from(groups)
            .where(eq(groups.id, request.groupId));
            
          if (group && group.organizationId === organizationId) {
            filteredNotifications.push(notification);
          }
        }
        continue;
      }
      
      // Check if it's a notification about a comment
      if (notification.type === 'new_comment') {
        const [comment] = await db.select()
          .from(comments)
          .where(eq(comments.id, refId));
          
        if (comment) {
          const [request] = await db.select()
            .from(prayerRequests)
            .where(eq(prayerRequests.id, comment.prayerRequestId));
            
          if (request) {
            const [group] = await db.select()
              .from(groups)
              .where(eq(groups.id, request.groupId));
              
            if (group && group.organizationId === organizationId) {
              filteredNotifications.push(notification);
            }
          }
        }
        continue;
      }
      
      // For organization-related notifications
      if (notification.type.includes('organization')) {
        if (refId === organizationId) {
          filteredNotifications.push(notification);
        }
        continue;
      }
      
      // For notifications we couldn't categorize, include them by default
      filteredNotifications.push(notification);
    }
    
    return filteredNotifications;
  }
  
  async markNotificationRead(id: number): Promise<Notification | undefined> {
    const result = await db.update(notifications)
      .set({ read: true })
      .where(eq(notifications.id, id))
      .returning();
    
    return result[0];
  }
  
  async markAllNotificationsRead(userId: number, organizationId?: number): Promise<boolean> {
    try {
      // If no organizationId provided, mark all as read
      if (!organizationId) {
        await db.update(notifications)
          .set({ read: true })
          .where(eq(notifications.userId, userId));
        
        return true;
      }
      
      // Otherwise, first get the notifications filtered by organization
      const filteredNotifications = await this.getUserNotifications(userId, organizationId);
      
      // If there are no notifications to mark, return success
      if (filteredNotifications.length === 0) {
        return true;
      }
      
      // Mark each notification as read
      const notificationIds = filteredNotifications.map(n => n.id);
      
      await db.update(notifications)
        .set({ read: true })
        .where(
          and(
            eq(notifications.userId, userId), 
            inArray(notifications.id, notificationIds)
          )
        );
      
      return true;
    } catch (error) {
      console.error("Error marking notifications as read:", error);
      return false;
    }
  }
  
  async deleteNotification(id: number): Promise<boolean> {
    try {
      await db.delete(notifications)
        .where(eq(notifications.id, id));
      
      return true;
    } catch (error) {
      console.error("Error deleting notification:", error);
      return false;
    }
  }
  
  // Praying For
  async addPrayingFor(insertPrayingFor: InsertPrayingFor): Promise<PrayingFor> {
    const now = new Date();
    const prayingForToInsert = {
      ...insertPrayingFor,
      createdAt: now
    };
    
    const result = await db.insert(prayingFor).values(prayingForToInsert).returning();
    return result[0];
  }
  
  async removePrayingFor(prayerRequestId: number, userId: number): Promise<boolean> {
    try {
      await db.delete(prayingFor)
        .where(
          and(
            eq(prayingFor.prayerRequestId, prayerRequestId),
            eq(prayingFor.userId, userId)
          )
        );
      
      return true;
    } catch (error) {
      console.error("Error removing praying for record:", error);
      return false;
    }
  }
  
  async isPrayingFor(prayerRequestId: number, userId: number): Promise<boolean> {
    const result = await db.select()
      .from(prayingFor)
      .where(
        and(
          eq(prayingFor.prayerRequestId, prayerRequestId),
          eq(prayingFor.userId, userId)
        )
      );
    
    return result.length > 0;
  }
  
  async getPrayingForCount(prayerRequestId: number): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` })
      .from(prayingFor)
      .where(eq(prayingFor.prayerRequestId, prayerRequestId));
    
    return result[0]?.count || 0;
  }
  
  // Password Reset methods
  async getUserByEmail(email: string): Promise<User | undefined> {
    const result = await db.select()
      .from(users)
      .where(eq(users.email, email));
    
    return result[0];
  }
  
  async createPasswordResetToken(userId: number): Promise<PasswordResetToken> {
    const now = new Date();
    // Generate a random token
    const buffer = crypto.randomBytes(32);
    const token = buffer.toString('hex');
    const expiresAt = new Date(now.getTime() + 1000 * 60 * 60); // 1 hour from now
    
    const tokenToInsert: InsertPasswordResetToken = {
      userId,
      token,
      expiresAt
    };
    
    const result = await db.insert(passwordResetTokens)
      .values(tokenToInsert)
      .returning();
    
    return result[0];
  }
  
  async getPasswordResetToken(token: string): Promise<PasswordResetToken | undefined> {
    const now = new Date();
    
    const result = await db.select()
      .from(passwordResetTokens)
      .where(
        and(
          eq(passwordResetTokens.token, token),
          eq(passwordResetTokens.isUsed, false),
          sql`${passwordResetTokens.expiresAt} > ${now}`
        )
      );
    
    return result[0];
  }
  
  async markPasswordResetTokenUsed(id: number): Promise<PasswordResetToken | undefined> {
    const result = await db.update(passwordResetTokens)
      .set({ isUsed: true })
      .where(eq(passwordResetTokens.id, id))
      .returning();
    
    return result[0];
  }

  // Notification Preferences methods
  async getUserNotificationPreferences(userId: number): Promise<NotificationPreference | undefined> {
    const result = await db.select()
      .from(notificationPreferences)
      .where(eq(notificationPreferences.userId, userId));
    
    return result[0];
  }

  async createNotificationPreferences(preferences: InsertNotificationPreference): Promise<NotificationPreference> {
    const result = await db.insert(notificationPreferences)
      .values(preferences)
      .returning();
    
    return result[0];
  }

  async updateNotificationPreferences(userId: number, preferences: Partial<InsertNotificationPreference>): Promise<NotificationPreference | undefined> {
    const result = await db.update(notificationPreferences)
      .set(preferences)
      .where(eq(notificationPreferences.userId, userId))
      .returning();
    
    return result[0];
  }

  // Group Notification Preferences methods
  async getGroupNotificationPreferences(userId: number, groupId: number): Promise<GroupNotificationPreference | undefined> {
    const result = await db.select()
      .from(groupNotificationPreferences)
      .where(and(
        eq(groupNotificationPreferences.userId, userId),
        eq(groupNotificationPreferences.groupId, groupId)
      ));
    
    return result[0];
  }

  async getUserGroupNotificationPreferences(userId: number): Promise<GroupNotificationPreference[]> {
    return db.select()
      .from(groupNotificationPreferences)
      .where(eq(groupNotificationPreferences.userId, userId));
  }

  async createGroupNotificationPreferences(preferences: InsertGroupNotificationPreference): Promise<GroupNotificationPreference> {
    const result = await db.insert(groupNotificationPreferences)
      .values(preferences)
      .returning();
    
    return result[0];
  }

  async updateGroupNotificationPreferences(userId: number, groupId: number, preferences: Partial<InsertGroupNotificationPreference>): Promise<GroupNotificationPreference | undefined> {
    const result = await db.update(groupNotificationPreferences)
      .set(preferences)
      .where(and(
        eq(groupNotificationPreferences.userId, userId),
        eq(groupNotificationPreferences.groupId, groupId)
      ))
      .returning();
    
    return result[0];
  }

  // Stale prayer request management
  async checkAndUpdateStalePrayerRequests(): Promise<number> {
    // Since we don't have is_stale or follow_up_date columns in the database,
    // we'll just check for prayers that haven't been updated in a while
    const now = new Date();
    const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000); // Two weeks ago
    
    // Find prayer requests that have been waiting for over two weeks
    const staleRequests = await db.select()
      .from(prayerRequests)
      .where(
        and(
          eq(prayerRequests.status, "waiting"),
          sql`${prayerRequests.updatedAt} < ${twoWeeksAgo}`
        )
      );
    
    if (staleRequests.length === 0) {
      return 0;
    }
    
    // We can't mark them as stale since the column doesn't exist,
    // but we can notify the owners
    for (const request of staleRequests) {
      // Create notification for the prayer request owner
      await this.createNotification({
        userId: request.userId,
        type: "status_update",
        message: `Your prayer request "${request.title}" hasn't been updated in two weeks. Please update its status.`,
        referenceId: request.id,
      });
    }
    
    return staleRequests.length;
  }
  
  // Favorite Groups methods
  async addFavoriteGroup(userId: number, groupId: number): Promise<FavoriteGroup> {
    // Check if it's already a favorite
    const existing = await db.select()
      .from(favoriteGroups)
      .where(
        and(
          eq(favoriteGroups.userId, userId),
          eq(favoriteGroups.groupId, groupId)
        )
      );
      
    if (existing.length > 0) {
      return existing[0];
    }
    
    // Add as favorite
    const [favoriteGroup] = await db.insert(favoriteGroups)
      .values({
        userId,
        groupId
      })
      .returning();
      
    return favoriteGroup;
  }
  
  async removeFavoriteGroup(userId: number, groupId: number): Promise<boolean> {
    const result = await db.delete(favoriteGroups)
      .where(
        and(
          eq(favoriteGroups.userId, userId),
          eq(favoriteGroups.groupId, groupId)
        )
      )
      .returning();
      
    return result.length > 0;
  }
  
  async getUserFavoriteGroups(userId: number): Promise<Group[]> {
    // Get all favorited group IDs for this user
    const favorites = await db.select()
      .from(favoriteGroups)
      .where(eq(favoriteGroups.userId, userId));
      
    if (favorites.length === 0) {
      return [];
    }
    
    const groupIds = favorites.map(fav => fav.groupId);
    
    // Get the group details
    return db.select()
      .from(groups)
      .where(inArray(groups.id, groupIds));
  }
  
  async isFavoriteGroup(userId: number, groupId: number): Promise<boolean> {
    const result = await db.select()
      .from(favoriteGroups)
      .where(
        and(
          eq(favoriteGroups.userId, userId),
          eq(favoriteGroups.groupId, groupId)
        )
      );
      
    return result.length > 0;
  }
}

// Use PostgreSQL database if DATABASE_URL is available, otherwise use in-memory storage
const useDatabase = process.env.DATABASE_URL !== undefined && process.env.USE_DATABASE !== 'false';
export const storage = useDatabase ? new DatabaseStorage() : new MemStorage();
```

## File: server/vite.ts
```typescript
import express, { type Express } from "express";
import fs from "fs";
import path, { dirname } from "path";
import { fileURLToPath } from "url";
import { createServer as createViteServer, createLogger } from "vite";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        __dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(__dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}
```

## File: shared/schema.ts
```typescript
import { pgTable, text, serial, integer, boolean, timestamp, time } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Users table
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  role: text("role").default("regular").notNull(),
  phone: text("phone"),
  avatar: text("avatar"),
  bio: text("bio"),
});

// Password reset tokens table
export const passwordResetTokens = pgTable("password_reset_tokens", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  token: text("token").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  isUsed: boolean("is_used").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Organizations table
export const organizations = pgTable("organizations", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  createdBy: integer("created_by").notNull(),
});

// Organization members table
export const organizationMembers = pgTable("organization_members", {
  id: serial("id").primaryKey(),
  organizationId: integer("organization_id").notNull(),
  userId: integer("user_id").notNull(),
  role: text("role").default("member").notNull(),
  joinedAt: timestamp("joined_at").defaultNow().notNull(),
});

// Groups table
export const groups = pgTable("groups", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  organizationId: integer("organization_id").notNull(),
  category: text("category").default("other").notNull(),
  privacy: text("privacy").default("open").notNull(),
  leaderRotation: integer("leader_rotation").default(0), // 0 = no rotation, 30 = 30 days, etc.
  createdAt: timestamp("created_at").defaultNow().notNull(),
  createdBy: integer("created_by").notNull(),
});

// Organization tags table
export const organizationTags = pgTable("organization_tags", {
  id: serial("id").primaryKey(),
  organizationId: integer("organization_id").notNull(),
  name: text("name").notNull(),
  color: text("color").notNull(), // hexadecimal color code
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Group tags junction table
export const groupTags = pgTable("group_tags", {
  id: serial("id").primaryKey(),
  groupId: integer("group_id").notNull(),
  tagId: integer("tag_id").notNull(),
});

// Group members table
export const groupMembers = pgTable("group_members", {
  id: serial("id").primaryKey(),
  groupId: integer("group_id").notNull(),
  userId: integer("user_id").notNull(),
  role: text("role").default("member").notNull(),
  joinedAt: timestamp("joined_at").defaultNow().notNull(),
});

// Prayer requests table
export const prayerRequests = pgTable("prayer_requests", {
  id: serial("id").primaryKey(),
  groupId: integer("group_id").notNull(),
  userId: integer("user_id").notNull(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  urgency: text("urgency").default("medium").notNull(),
  isAnonymous: boolean("is_anonymous").default(false).notNull(),
  status: text("status").default("waiting").notNull(),
  followUpDate: timestamp("follow_up_date"),
  isStale: boolean("is_stale").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Comments table
export const comments = pgTable("comments", {
  id: serial("id").primaryKey(),
  prayerRequestId: integer("prayer_request_id").notNull(),
  userId: integer("user_id").notNull(),
  text: text("text").notNull(),
  isPrivate: boolean("is_private").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Notifications table
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  type: text("type").notNull(),
  message: text("message").notNull(),
  read: boolean("read").default(false).notNull(),
  referenceId: integer("reference_id"), // ID of the related entity (request, comment, etc.)
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Prayer tracking
export const prayingFor = pgTable("praying_for", {
  id: serial("id").primaryKey(),
  prayerRequestId: integer("prayer_request_id").notNull(),
  userId: integer("user_id").notNull(),
  timestamp: timestamp("timestamp").defaultNow().notNull(),
});

// Push notification subscriptions
export const subscriptions = pgTable("push_subscriptions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  endpoint: text("endpoint").notNull().unique(),
  p256dh: text("p256dh").notNull(),
  auth: text("auth").notNull(),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Table for mobile push notification tokens (Expo)
export const pushTokens = pgTable("push_tokens", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  token: text("token").notNull().unique(),
  deviceType: text("device_type").notNull(), // 'ios', 'android', 'web'
  createdAt: timestamp("created_at").defaultNow().notNull(),
  lastUsed: timestamp("last_used").defaultNow().notNull(),
});

// User notification preferences
export const notificationPreferences = pgTable("notification_preferences", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  // App-level notification settings
  emailNotifications: boolean("email_notifications").default(true).notNull(),
  pushNotifications: boolean("push_notifications").default(true).notNull(),
  inAppNotifications: boolean("in_app_notifications").default(true).notNull(),
  // Per-type notification settings
  prayerRequests: boolean("prayer_requests").default(true).notNull(),
  groupInvitations: boolean("group_invitations").default(true).notNull(),
  comments: boolean("comments").default(true).notNull(),
  statusUpdates: boolean("status_updates").default(true).notNull(),
  groupUpdates: boolean("group_updates").default(true).notNull(),
  // Stale prayer request reminder settings
  stalePrayerReminders: boolean("stale_prayer_reminders").default(true).notNull(),
  reminderInterval: integer("reminder_interval").default(7).notNull(), // Days before a prayer request is considered stale
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Group-specific notification preferences
export const groupNotificationPreferences = pgTable("group_notification_preferences", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  groupId: integer("group_id").notNull(),
  // Notification settings for this specific group
  muted: boolean("muted").default(false).notNull(),
  newPrayerRequests: boolean("new_prayer_requests").default(true).notNull(),
  prayerStatusUpdates: boolean("prayer_status_updates").default(true).notNull(),
  newComments: boolean("new_comments").default(true).notNull(),
  groupUpdates: boolean("group_updates").default(true).notNull(),
  meetingReminders: boolean("meeting_reminders").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Favorite groups table
export const favoriteGroups = pgTable("favorite_groups", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  groupId: integer("group_id").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Zod schemas
export const insertUserSchema = createInsertSchema(users)
  .pick({
    username: true,
    password: true,
    name: true,
    email: true,
    role: true,
    phone: true,
    avatar: true,
    bio: true,
  })
  .extend({
    email: z.string().email("Please enter a valid email address"),
    phone: z.string().optional(),
    avatar: z.string().optional(),
    bio: z.string().optional(),
  });

export const insertOrganizationSchema = createInsertSchema(organizations).pick({
  name: true,
  description: true,
  createdBy: true,
});

export const insertOrganizationMemberSchema = createInsertSchema(organizationMembers).pick({
  organizationId: true,
  userId: true,
  role: true,
});

export const insertOrganizationTagSchema = createInsertSchema(organizationTags).pick({
  organizationId: true,
  name: true,
  color: true,
});

export const insertGroupTagSchema = createInsertSchema(groupTags).pick({
  groupId: true,
  tagId: true,
});

export const insertGroupSchema = createInsertSchema(groups).pick({
  name: true,
  description: true,
  organizationId: true,
  category: true,
  privacy: true,
  leaderRotation: true,
  createdBy: true,
});

export const insertGroupMemberSchema = createInsertSchema(groupMembers).pick({
  groupId: true,
  userId: true,
  role: true,
});

export const insertPrayerRequestSchema = createInsertSchema(prayerRequests).pick({
  groupId: true,
  userId: true,
  title: true,
  description: true,
  urgency: true,
  isAnonymous: true,
  status: true,
  followUpDate: true,
  isStale: true,
});

export const insertCommentSchema = createInsertSchema(comments).pick({
  prayerRequestId: true,
  userId: true,
  text: true,
  isPrivate: true,
});

export const insertNotificationSchema = createInsertSchema(notifications).pick({
  userId: true,
  type: true,
  message: true,
  referenceId: true,
});

export const insertPrayingForSchema = createInsertSchema(prayingFor).pick({
  prayerRequestId: true,
  userId: true,
});

export const insertSubscriptionSchema = createInsertSchema(subscriptions).pick({
  userId: true,
  endpoint: true,
  p256dh: true,
  auth: true,
  userAgent: true,
});

export const insertPushTokenSchema = createInsertSchema(pushTokens).pick({
  userId: true,
  token: true,
  deviceType: true,
});

export const insertPasswordResetTokenSchema = createInsertSchema(passwordResetTokens).pick({
  userId: true,
  token: true,
  expiresAt: true,
});

export const insertNotificationPreferencesSchema = createInsertSchema(notificationPreferences).pick({
  userId: true,
  emailNotifications: true,
  pushNotifications: true,
  inAppNotifications: true,
  prayerRequests: true,
  groupInvitations: true,
  comments: true,
  statusUpdates: true,
  groupUpdates: true,
  stalePrayerReminders: true,
  reminderInterval: true,
});

export const insertGroupNotificationPreferencesSchema = createInsertSchema(groupNotificationPreferences).pick({
  userId: true,
  groupId: true,
  muted: true,
  newPrayerRequests: true,
  prayerStatusUpdates: true,
  newComments: true,
  groupUpdates: true,
  meetingReminders: true,
});

export const insertFavoriteGroupSchema = createInsertSchema(favoriteGroups).pick({
  userId: true,
  groupId: true,
});

// Types
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;

export type PasswordResetToken = typeof passwordResetTokens.$inferSelect;
export type InsertPasswordResetToken = z.infer<typeof insertPasswordResetTokenSchema>;

export type Organization = typeof organizations.$inferSelect;
export type InsertOrganization = z.infer<typeof insertOrganizationSchema>;

export type OrganizationMember = typeof organizationMembers.$inferSelect;
export type InsertOrganizationMember = z.infer<typeof insertOrganizationMemberSchema>;

export type OrganizationTag = typeof organizationTags.$inferSelect;
export type InsertOrganizationTag = z.infer<typeof insertOrganizationTagSchema>;

export type GroupTag = typeof groupTags.$inferSelect;
export type InsertGroupTag = z.infer<typeof insertGroupTagSchema>;

export type Subscription = typeof subscriptions.$inferSelect;
export type InsertSubscription = z.infer<typeof insertSubscriptionSchema>;

export type PushToken = typeof pushTokens.$inferSelect;
export type InsertPushToken = z.infer<typeof insertPushTokenSchema>;

export type Group = typeof groups.$inferSelect;
export type InsertGroup = z.infer<typeof insertGroupSchema>;

export type GroupMember = typeof groupMembers.$inferSelect;
export type InsertGroupMember = z.infer<typeof insertGroupMemberSchema>;

export type PrayerRequest = typeof prayerRequests.$inferSelect;
export type InsertPrayerRequest = z.infer<typeof insertPrayerRequestSchema>;

export type Comment = typeof comments.$inferSelect;
export type InsertComment = z.infer<typeof insertCommentSchema>;

export type Notification = typeof notifications.$inferSelect;
export type InsertNotification = z.infer<typeof insertNotificationSchema>;

export type PrayingFor = typeof prayingFor.$inferSelect;
export type InsertPrayingFor = z.infer<typeof insertPrayingForSchema>;

export type NotificationPreference = typeof notificationPreferences.$inferSelect;
export type InsertNotificationPreference = z.infer<typeof insertNotificationPreferencesSchema>;

export type GroupNotificationPreference = typeof groupNotificationPreferences.$inferSelect;
export type InsertGroupNotificationPreference = z.infer<typeof insertGroupNotificationPreferencesSchema>;

export type FavoriteGroup = typeof favoriteGroups.$inferSelect;
export type InsertFavoriteGroup = z.infer<typeof insertFavoriteGroupSchema>;

// Auth schemas
export const loginSchema = z.object({
  username: z.string().min(1, "Username is required"),
  password: z.string().min(1, "Password is required"),
});

export type LoginData = z.infer<typeof loginSchema>;

export const registerSchema = insertUserSchema.extend({
  confirmPassword: z.string().min(1, "Please confirm your password"),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords do not match",
  path: ["confirmPassword"],
});

export type RegisterData = z.infer<typeof registerSchema>;

export const forgotPasswordSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
});

export type ForgotPasswordData = z.infer<typeof forgotPasswordSchema>;

export const resetPasswordSchema = z.object({
  token: z.string().min(1, "Token is required"),
  password: z.string().min(6, "Password must be at least 6 characters"),
  confirmPassword: z.string().min(1, "Please confirm your password"),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords do not match",
  path: ["confirmPassword"],
});

export type ResetPasswordData = z.infer<typeof resetPasswordSchema>;

// Meetings table
export const meetings = pgTable("meetings", {
  id: serial("id").primaryKey(),
  groupId: integer("group_id").notNull(),
  title: text("title").notNull(),
  description: text("description"),
  meetingType: text("meeting_type").notNull(),
  meetingLink: text("meeting_link").notNull(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time"),
  isRecurring: boolean("is_recurring").default(false).notNull(),
  recurringPattern: text("recurring_pattern"),
  recurringDay: integer("recurring_day"), // 0-6 for weekly (0 = Sunday), 1-31 for monthly
  recurringUntil: timestamp("recurring_until"), // When the recurring series ends, null for indefinite
  createdBy: integer("created_by").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  parentMeetingId: integer("parent_meeting_id"), // For recurring instances, points to the original meeting
});

// Meeting notes table
export const meetingNotes = pgTable("meeting_notes", {
  id: serial("id").primaryKey(),
  meetingId: integer("meeting_id").notNull(),
  content: text("content").notNull(),
  summary: text("summary"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  isAiGenerated: boolean("is_ai_generated").default(false).notNull(),
});

// Insert schemas
export const insertMeetingSchema = createInsertSchema(meetings).pick({
  groupId: true,
  title: true,
  description: true,
  meetingType: true,
  meetingLink: true,
  startTime: true,
  endTime: true,
  isRecurring: true,
  recurringPattern: true,
  recurringDay: true,
  recurringUntil: true,
  createdBy: true,
  parentMeetingId: true,
});

export const insertMeetingNotesSchema = createInsertSchema(meetingNotes).pick({
  meetingId: true,
  content: true,
  summary: true,
  isAiGenerated: true,
});

// Types
export type Meeting = typeof meetings.$inferSelect;
export type InsertMeeting = z.infer<typeof insertMeetingSchema>;

export type MeetingNote = typeof meetingNotes.$inferSelect;
export type InsertMeetingNote = z.infer<typeof insertMeetingNotesSchema>;

// Prayer Reminders table
export const prayerReminders = pgTable("prayer_reminders", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  title: text("title").notNull(),
  description: text("description"),
  reminderTime: time("reminder_time").notNull(), // Time of day for reminder
  isRecurring: boolean("is_recurring").default(false).notNull(),
  recurringDays: text("recurring_days"), // JSON string of days: ["monday", "wednesday", "friday"] etc.
  activeUntil: timestamp("active_until"), // When to stop sending reminders
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  isActive: boolean("is_active").default(true).notNull(),
});

export const insertPrayerReminderSchema = createInsertSchema(prayerReminders).pick({
  userId: true,
  title: true,
  description: true,
  reminderTime: true,
  isRecurring: true,
  recurringDays: true,
  activeUntil: true,
  isActive: true,
});

export type PrayerReminder = typeof prayerReminders.$inferSelect;
export type InsertPrayerReminder = z.infer<typeof insertPrayerReminderSchema>;
```

## File: .gitignore
```
node_modules
dist
.DS_Store
server/public
vite.config.ts.*
*.tar.gz
```

## File: .replit
```
modules = ["nodejs-20", "web", "postgresql-16"]
run = "npm run dev"
hidden = [".config", ".git", "generated-icon.png", "node_modules", "dist"]

[nix]
channel = "stable-24_05"

[deployment]
deploymentTarget = "autoscale"
build = ["npm", "run", "build"]
run = ["npm", "run", "start"]

[[ports]]
localPort = 5000
externalPort = 80

[[ports]]
localPort = 8081
externalPort = 8081

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Start application"

[[workflows.workflow]]
name = "Start application"
author = "agent"

[workflows.workflow.metadata]
agentRequireRestartOnSave = false

[[workflows.workflow.tasks]]
task = "packager.installForAll"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "npm run dev"
waitForPort = 5000
```

## File: db-migrate.js
```javascript
// This script performs a migration using Drizzle in a simpler way
// without the interactive prompt

import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import postgres from 'postgres';
import * as schema from './shared/schema.js';

// For migrations
const migrationClient = postgres(process.env.DATABASE_URL, { max: 1 });

// For query purposes
const client = postgres(process.env.DATABASE_URL);
const db = drizzle(client, { schema });

async function main() {
  // Perform the migration
  console.log('Running migration...');
  await migrate(drizzle(migrationClient), { migrationsFolder: './drizzle' });
  console.log('Migration complete!');
  
  process.exit(0);
}

main().catch(e => {
  console.error('Migration failed:');
  console.error(e);
  process.exit(1);
});
```

## File: drizzle.config.ts
```typescript
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
```

## File: package.json
```json
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.1",
    "@radix-ui/react-alert-dialog": "^1.1.2",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-collapsible": "^1.1.1",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-hover-card": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.2",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@replit/vite-plugin-shadcn-theme-json": "^0.0.4",
    "@tanstack/react-query": "^5.60.5",
    "@types/web-push": "^3.6.4",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.3.0",
    "expo-cli": "^6.3.12",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.453.0",
    "memorystore": "^1.6.7",
    "metro": "^0.82.1",
    "metro-core": "^0.82.1",
    "node-fetch": "^3.3.2",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pg": "^8.14.1",
    "postgres": "^3.4.5",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.53.1",
    "react-icons": "^5.4.0",
    "react-native-web": "^0.19.13",
    "react-resizable-panels": "^2.1.4",
    "recharts": "^2.13.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.0",
    "web-push": "^3.6.7",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.23.8",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.0.11",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
```

## File: postcss.config.js
```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

## File: replit.nix
```
{pkgs}: {
  deps = [
    pkgs.jq
    pkgs.imagemagick
    pkgs.postgresql
  ];
}
```

## File: tailwind.config.ts
```typescript
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;
```

## File: theme.json
```json
{
  "variant": "professional",
  "primary": "hsl(231, 48%, 48%)",
  "appearance": "light",
  "radius": 0.5
}
```

## File: tsconfig.json
```json
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
```

## File: update-schema.cjs
```
// Script to update the database schema from enum types to text types

const { Pool } = require('pg');

async function main() {
  console.log('Starting schema update...');
  const pool = new Pool({ connectionString: process.env.DATABASE_URL });
  const client = await pool.connect();
  
  try {
    // Begin transaction
    await client.query('BEGIN');
    
    // Update meetings table
    console.log('Updating meetings.recurring_pattern...');
    await client.query(`
      ALTER TABLE meetings 
      ALTER COLUMN recurring_pattern TYPE text
    `);
    
    // Update groups table
    console.log('Updating groups.category and groups.privacy...');
    await client.query(`
      ALTER TABLE groups 
      ALTER COLUMN category TYPE text,
      ALTER COLUMN privacy TYPE text
    `);
    
    // Update prayer_requests table
    console.log('Updating prayer_requests.urgency and prayer_requests.status...');
    await client.query(`
      ALTER TABLE prayer_requests 
      ALTER COLUMN urgency TYPE text,
      ALTER COLUMN status TYPE text
    `);
    
    // Commit transaction
    await client.query('COMMIT');
    console.log('Schema update completed successfully!');
    
  } catch (error) {
    // Rollback in case of error
    await client.query('ROLLBACK');
    console.error('Error updating schema:', error);
    throw error;
  } finally {
    // Release client back to pool
    client.release();
  }
  
  // Close pool
  await pool.end();
}

main().catch(e => {
  console.error('Migration failed:', e);
  process.exit(1);
});
```

## File: vite.config.ts
```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets"),
    },
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true,
  },
});
```
