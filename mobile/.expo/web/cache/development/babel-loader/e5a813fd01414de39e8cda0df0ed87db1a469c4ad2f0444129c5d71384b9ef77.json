{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar STORAGE_PREFIX = 'prayer_pipeline_secure_';\nvar storage = {};\nvar storageMethod = 'in-memory';\nif (typeof window !== 'undefined' && window.localStorage) {\n  storageMethod = 'localStorage';\n  console.log('Using localStorage for secure storage');\n} else {\n  console.warn('localStorage not available, using in-memory storage');\n}\nexport function setItemAsync(_x, _x2, _x3) {\n  return _setItemAsync.apply(this, arguments);\n}\nfunction _setItemAsync() {\n  _setItemAsync = _asyncToGenerator(function* (key, value, options) {\n    var prefixedKey = `${STORAGE_PREFIX}${key}`;\n    if (storageMethod === 'localStorage') {\n      try {\n        localStorage.setItem(prefixedKey, value);\n      } catch (error) {\n        console.error('Error storing in localStorage:', error);\n        storage[prefixedKey] = value;\n      }\n    } else {\n      storage[prefixedKey] = value;\n    }\n  });\n  return _setItemAsync.apply(this, arguments);\n}\nexport function getItemAsync(_x4, _x5) {\n  return _getItemAsync.apply(this, arguments);\n}\nfunction _getItemAsync() {\n  _getItemAsync = _asyncToGenerator(function* (key, options) {\n    var prefixedKey = `${STORAGE_PREFIX}${key}`;\n    if (storageMethod === 'localStorage') {\n      try {\n        return localStorage.getItem(prefixedKey);\n      } catch (error) {\n        console.error('Error retrieving from localStorage:', error);\n        return storage[prefixedKey] || null;\n      }\n    } else {\n      return storage[prefixedKey] || null;\n    }\n  });\n  return _getItemAsync.apply(this, arguments);\n}\nexport function deleteItemAsync(_x6, _x7) {\n  return _deleteItemAsync.apply(this, arguments);\n}\nfunction _deleteItemAsync() {\n  _deleteItemAsync = _asyncToGenerator(function* (key, options) {\n    var prefixedKey = `${STORAGE_PREFIX}${key}`;\n    if (storageMethod === 'localStorage') {\n      try {\n        localStorage.removeItem(prefixedKey);\n      } catch (error) {\n        console.error('Error deleting from localStorage:', error);\n        delete storage[prefixedKey];\n      }\n    } else {\n      delete storage[prefixedKey];\n    }\n  });\n  return _deleteItemAsync.apply(this, arguments);\n}\nexport function isAvailableAsync() {\n  return _isAvailableAsync.apply(this, arguments);\n}\nfunction _isAvailableAsync() {\n  _isAvailableAsync = _asyncToGenerator(function* () {\n    return true;\n  });\n  return _isAvailableAsync.apply(this, arguments);\n}\nexport default {\n  setItemAsync: setItemAsync,\n  getItemAsync: getItemAsync,\n  deleteItemAsync: deleteItemAsync,\n  isAvailableAsync: isAvailableAsync\n};","map":{"version":3,"names":["STORAGE_PREFIX","storage","storageMethod","window","localStorage","console","log","warn","setItemAsync","_x","_x2","_x3","_setItemAsync","apply","arguments","_asyncToGenerator","key","value","options","prefixedKey","setItem","error","getItemAsync","_x4","_x5","_getItemAsync","getItem","deleteItemAsync","_x6","_x7","_deleteItemAsync","removeItem","isAvailableAsync","_isAvailableAsync"],"sources":["/home/runner/workspace/mobile/src/mocks/expo-secure-store.ts"],"sourcesContent":["/**\n * Enhanced implementation of expo-secure-store for React Native\n * Uses localStorage for web environments with prefix to avoid collisions\n */\n\nconst STORAGE_PREFIX = 'prayer_pipeline_secure_';\n\n// Try to use localStorage if available, otherwise use in-memory storage\nlet storage: Record<string, string> = {};\nlet storageMethod = 'in-memory';\n\n// Check if we're in a browser environment with localStorage\nif (typeof window !== 'undefined' && window.localStorage) {\n  storageMethod = 'localStorage';\n  console.log('Using localStorage for secure storage');\n} else {\n  console.warn('localStorage not available, using in-memory storage');\n}\n\n// setItemAsync implementation\nexport async function setItemAsync(key: string, value: string, options?: object): Promise<void> {\n  const prefixedKey = `${STORAGE_PREFIX}${key}`;\n  \n  if (storageMethod === 'localStorage') {\n    try {\n      localStorage.setItem(prefixedKey, value);\n    } catch (error) {\n      console.error('Error storing in localStorage:', error);\n      // Fallback to in-memory if localStorage fails\n      storage[prefixedKey] = value;\n    }\n  } else {\n    storage[prefixedKey] = value;\n  }\n}\n\n// getItemAsync implementation\nexport async function getItemAsync(key: string, options?: object): Promise<string | null> {\n  const prefixedKey = `${STORAGE_PREFIX}${key}`;\n  \n  if (storageMethod === 'localStorage') {\n    try {\n      return localStorage.getItem(prefixedKey);\n    } catch (error) {\n      console.error('Error retrieving from localStorage:', error);\n      // Fallback to in-memory if localStorage fails\n      return storage[prefixedKey] || null;\n    }\n  } else {\n    return storage[prefixedKey] || null;\n  }\n}\n\n// deleteItemAsync implementation\nexport async function deleteItemAsync(key: string, options?: object): Promise<void> {\n  const prefixedKey = `${STORAGE_PREFIX}${key}`;\n  \n  if (storageMethod === 'localStorage') {\n    try {\n      localStorage.removeItem(prefixedKey);\n    } catch (error) {\n      console.error('Error deleting from localStorage:', error);\n      // Fallback to in-memory if localStorage fails\n      delete storage[prefixedKey];\n    }\n  } else {\n    delete storage[prefixedKey];\n  }\n}\n\n// isAvailableAsync implementation\nexport async function isAvailableAsync(): Promise<boolean> {\n  return true; // We always have some form of storage available\n}\n\nexport default {\n  setItemAsync,\n  getItemAsync,\n  deleteItemAsync,\n  isAvailableAsync,\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}