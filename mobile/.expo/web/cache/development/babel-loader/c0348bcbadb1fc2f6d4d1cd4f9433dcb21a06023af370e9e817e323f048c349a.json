{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as Device from 'expo-device';\nimport * as Notifications from 'expo-notifications';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Constants from 'expo-constants';\nimport { apiRequest } from \"../api/queryClient\";\nNotifications.setNotificationHandler({\n  handleNotification: function () {\n    var _handleNotification = _asyncToGenerator(function* () {\n      return {\n        shouldShowAlert: true,\n        shouldPlaySound: true,\n        shouldSetBadge: true\n      };\n    });\n    function handleNotification() {\n      return _handleNotification.apply(this, arguments);\n    }\n    return handleNotification;\n  }()\n});\nexport function checkNotificationPermissions() {\n  return _checkNotificationPermissions.apply(this, arguments);\n}\nfunction _checkNotificationPermissions() {\n  _checkNotificationPermissions = _asyncToGenerator(function* () {\n    if (!Device.isDevice) {\n      console.log('Push notifications are not available on simulators/emulators');\n      return false;\n    }\n    var _yield$Notifications$ = yield Notifications.getPermissionsAsync(),\n      existingStatus = _yield$Notifications$.status;\n    var finalStatus = existingStatus;\n    if (existingStatus !== 'granted') {\n      var _yield$Notifications$2 = yield Notifications.requestPermissionsAsync(),\n        status = _yield$Notifications$2.status;\n      finalStatus = status;\n    }\n    if (finalStatus !== 'granted') {\n      console.log('Failed to get push token for push notification!');\n      return false;\n    }\n    return true;\n  });\n  return _checkNotificationPermissions.apply(this, arguments);\n}\nexport function registerForPushNotifications() {\n  return _registerForPushNotifications.apply(this, arguments);\n}\nfunction _registerForPushNotifications() {\n  _registerForPushNotifications = _asyncToGenerator(function* () {\n    try {\n      var _Constants$expoConfig, _Constants$expoConfig2, _Constants$expoConfig3;\n      var hasPermission = yield checkNotificationPermissions();\n      if (!hasPermission) {\n        return null;\n      }\n      var pushToken = yield Notifications.getExpoPushTokenAsync({\n        projectId: (_Constants$expoConfig = Constants.expoConfig) == null ? void 0 : (_Constants$expoConfig2 = _Constants$expoConfig.extra) == null ? void 0 : (_Constants$expoConfig3 = _Constants$expoConfig2.eas) == null ? void 0 : _Constants$expoConfig3.projectId\n      });\n      try {\n        yield apiRequest('POST', '/api/push/register-token', {\n          token: pushToken.data,\n          deviceType: Platform.OS\n        });\n        console.log('Push token registered with backend:', pushToken.data);\n      } catch (error) {\n        console.error('Failed to register push token with backend:', error);\n      }\n      return pushToken.data;\n    } catch (error) {\n      console.error('Error registering for push notifications:', error);\n      return null;\n    }\n  });\n  return _registerForPushNotifications.apply(this, arguments);\n}\nexport function unregisterFromPushNotifications(_x) {\n  return _unregisterFromPushNotifications.apply(this, arguments);\n}\nfunction _unregisterFromPushNotifications() {\n  _unregisterFromPushNotifications = _asyncToGenerator(function* (token) {\n    try {\n      yield apiRequest('POST', '/api/push/unregister-token', {\n        token: token\n      });\n      return true;\n    } catch (error) {\n      console.error('Failed to unregister push token with backend:', error);\n      return false;\n    }\n  });\n  return _unregisterFromPushNotifications.apply(this, arguments);\n}\nexport function setupNotificationListeners(onNotificationReceived, onNotificationResponseReceived) {\n  var receivedSubscription = Notifications.addNotificationReceivedListener(function (notification) {\n    if (onNotificationReceived) {\n      onNotificationReceived(notification);\n    }\n  });\n  var responseSubscription = Notifications.addNotificationResponseReceivedListener(function (response) {\n    if (onNotificationResponseReceived) {\n      onNotificationResponseReceived(response);\n    }\n    var data = response.notification.request.content.data;\n    handleNotificationNavigation(data);\n  });\n  return function () {\n    receivedSubscription.remove();\n    responseSubscription.remove();\n  };\n}\nexport function handleNotificationNavigation(data) {\n  console.log('Notification navigation data:', data);\n}\nexport function sendLocalNotification(_x2, _x3, _x4) {\n  return _sendLocalNotification.apply(this, arguments);\n}\nfunction _sendLocalNotification() {\n  _sendLocalNotification = _asyncToGenerator(function* (title, body, data) {\n    yield Notifications.scheduleNotificationAsync({\n      content: {\n        title: title,\n        body: body,\n        data: data || {}\n      },\n      trigger: null\n    });\n  });\n  return _sendLocalNotification.apply(this, arguments);\n}\nexport function scheduleNotification(_x5, _x6, _x7, _x8) {\n  return _scheduleNotification.apply(this, arguments);\n}\nfunction _scheduleNotification() {\n  _scheduleNotification = _asyncToGenerator(function* (title, body, scheduledTime, data) {\n    return yield Notifications.scheduleNotificationAsync({\n      content: {\n        title: title,\n        body: body,\n        data: data || {}\n      },\n      trigger: {\n        date: scheduledTime\n      }\n    });\n  });\n  return _scheduleNotification.apply(this, arguments);\n}\nexport function cancelNotification(_x9) {\n  return _cancelNotification.apply(this, arguments);\n}\nfunction _cancelNotification() {\n  _cancelNotification = _asyncToGenerator(function* (notificationId) {\n    yield Notifications.cancelScheduledNotificationAsync(notificationId);\n  });\n  return _cancelNotification.apply(this, arguments);\n}\nexport function cancelAllNotifications() {\n  return _cancelAllNotifications.apply(this, arguments);\n}\nfunction _cancelAllNotifications() {\n  _cancelAllNotifications = _asyncToGenerator(function* () {\n    yield Notifications.cancelAllScheduledNotificationsAsync();\n  });\n  return _cancelAllNotifications.apply(this, arguments);\n}","map":{"version":3,"names":["Device","Notifications","Platform","Constants","apiRequest","setNotificationHandler","handleNotification","_handleNotification","_asyncToGenerator","shouldShowAlert","shouldPlaySound","shouldSetBadge","apply","arguments","checkNotificationPermissions","_checkNotificationPermissions","isDevice","console","log","_yield$Notifications$","getPermissionsAsync","existingStatus","status","finalStatus","_yield$Notifications$2","requestPermissionsAsync","registerForPushNotifications","_registerForPushNotifications","_Constants$expoConfig","_Constants$expoConfig2","_Constants$expoConfig3","hasPermission","pushToken","getExpoPushTokenAsync","projectId","expoConfig","extra","eas","token","data","deviceType","OS","error","unregisterFromPushNotifications","_x","_unregisterFromPushNotifications","setupNotificationListeners","onNotificationReceived","onNotificationResponseReceived","receivedSubscription","addNotificationReceivedListener","notification","responseSubscription","addNotificationResponseReceivedListener","response","request","content","handleNotificationNavigation","remove","sendLocalNotification","_x2","_x3","_x4","_sendLocalNotification","title","body","scheduleNotificationAsync","trigger","scheduleNotification","_x5","_x6","_x7","_x8","_scheduleNotification","scheduledTime","date","cancelNotification","_x9","_cancelNotification","notificationId","cancelScheduledNotificationAsync","cancelAllNotifications","_cancelAllNotifications","cancelAllScheduledNotificationsAsync"],"sources":["/home/runner/workspace/mobile/src/services/notificationService.ts"],"sourcesContent":["import * as Device from 'expo-device';\nimport * as Notifications from 'expo-notifications';\nimport { Platform } from 'react-native';\nimport Constants from 'expo-constants';\nimport { apiRequest } from '@/api/queryClient';\n\n// Configure how notifications appear when the app is in the foreground\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true,\n  }),\n});\n\n// Check if the device can receive push notifications\nexport async function checkNotificationPermissions(): Promise<boolean> {\n  if (!Device.isDevice) {\n    console.log('Push notifications are not available on simulators/emulators');\n    return false;\n  }\n\n  const { status: existingStatus } = await Notifications.getPermissionsAsync();\n  let finalStatus = existingStatus;\n\n  // If we don't have permission yet, ask for it\n  if (existingStatus !== 'granted') {\n    const { status } = await Notifications.requestPermissionsAsync();\n    finalStatus = status;\n  }\n\n  // If we still don't have permission, we can't send notifications\n  if (finalStatus !== 'granted') {\n    console.log('Failed to get push token for push notification!');\n    return false;\n  }\n\n  return true;\n}\n\n// Register for push notifications\nexport async function registerForPushNotifications(): Promise<string | null> {\n  try {\n    const hasPermission = await checkNotificationPermissions();\n    \n    if (!hasPermission) {\n      return null;\n    }\n\n    // Get the token that uniquely identifies this device\n    const pushToken = await Notifications.getExpoPushTokenAsync({\n      projectId: Constants.expoConfig?.extra?.eas?.projectId,\n    });\n\n    // Register the token with our backend\n    try {\n      await apiRequest('POST', '/api/push/register-token', {\n        token: pushToken.data,\n        deviceType: Platform.OS,\n      });\n      console.log('Push token registered with backend:', pushToken.data);\n    } catch (error) {\n      console.error('Failed to register push token with backend:', error);\n    }\n\n    // Return the token\n    return pushToken.data;\n  } catch (error) {\n    console.error('Error registering for push notifications:', error);\n    return null;\n  }\n}\n\n// Unregister from push notifications (e.g., on logout)\nexport async function unregisterFromPushNotifications(token: string): Promise<boolean> {\n  try {\n    await apiRequest('POST', '/api/push/unregister-token', {\n      token,\n    });\n    return true;\n  } catch (error) {\n    console.error('Failed to unregister push token with backend:', error);\n    return false;\n  }\n}\n\n// Setup notification listeners to handle received notifications\nexport function setupNotificationListeners(\n  onNotificationReceived?: (notification: Notifications.Notification) => void,\n  onNotificationResponseReceived?: (response: Notifications.NotificationResponse) => void\n) {\n  // Get notification when received while app is foregrounded\n  const receivedSubscription = Notifications.addNotificationReceivedListener(\n    (notification) => {\n      if (onNotificationReceived) {\n        onNotificationReceived(notification);\n      }\n    }\n  );\n\n  // Get notification when user taps/interacts with the notification\n  const responseSubscription = Notifications.addNotificationResponseReceivedListener(\n    (response) => {\n      if (onNotificationResponseReceived) {\n        onNotificationResponseReceived(response);\n      }\n      \n      // Handle notification action here\n      // You can extract data from the notification and navigate accordingly\n      const data = response.notification.request.content.data;\n      handleNotificationNavigation(data);\n    }\n  );\n\n  // Return cleanup function to remove listeners\n  return () => {\n    receivedSubscription.remove();\n    responseSubscription.remove();\n  };\n}\n\n// Handle navigation based on notification data\nexport function handleNotificationNavigation(data: any) {\n  // This would be integrated with your navigation system\n  // Example:\n  // if (data.type === 'prayer_request' && data.requestId) {\n  //   navigation.navigate('RequestDetails', { requestId: data.requestId });\n  // }\n  console.log('Notification navigation data:', data);\n}\n\n// Send a local notification for testing\nexport async function sendLocalNotification(\n  title: string,\n  body: string,\n  data?: any\n): Promise<void> {\n  await Notifications.scheduleNotificationAsync({\n    content: {\n      title,\n      body,\n      data: data || {},\n    },\n    trigger: null, // null means send immediately\n  });\n}\n\n// Schedule a notification for a specific time\nexport async function scheduleNotification(\n  title: string,\n  body: string,\n  scheduledTime: Date,\n  data?: any\n): Promise<string> {\n  return await Notifications.scheduleNotificationAsync({\n    content: {\n      title,\n      body,\n      data: data || {},\n    },\n    trigger: {\n      date: scheduledTime,\n    },\n  });\n}\n\n// Cancel a specific notification by ID\nexport async function cancelNotification(notificationId: string): Promise<void> {\n  await Notifications.cancelScheduledNotificationAsync(notificationId);\n}\n\n// Cancel all notifications\nexport async function cancelAllNotifications(): Promise<void> {\n  await Notifications.cancelAllScheduledNotificationsAsync();\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}